.pl 51
.nf
.bp 1
.ft                                                       A-%
                                                       Appendix A

                                         The Microcomputer Development System Basic Input/Output System (BIOS)



  1                       ;        mds-800 i/o drivers for cp/m 2.2
  2                       ;        (four drive single density version)
  3                       ;
  4                       ;        version 2.2 february, 1980
  5                       ;
  6      0016 =           vers     equ   22             ;version 2.2
  7                       ;
  8                       ;        copyright (c) 1980
  9                       ;        digital research
 10                       ;        box 579, pacific grove
 11                       ;        california, 93950
 12                       ;
 13                       ;
 14      ffff =           true     equ      0fffh      ;value of "true"
 15      0000 =           false    equ      not true   ;"false"
 16      0000 =           test     equ      false      ;true if test bios
 17                       ;
 18                                if       test
 19                       bias     equ      03400h     ;base of ccp in test system
 20                                endif
 21                                if       not test
 22      0000 =           bias     equ      0000h      ;generate relocatable cp/m system
 23                                endif
 24                       ;
 25      1600 =           patch    equ      1600h
 26                       ;
 27      1600                      org      patch
 28      0000 =           cpmb     equ      $-patch    ;base of cpm console processor
 29      0806 =           bdos     equ      806h+cpmb  ;basic dos (resident portion)
 30      1600 =           cpml     equ      $-cpmb     ;length (in bytes) of cpm system
 31      002c =           nsects   equ      cpml/128   ;number of sectors to load
 32      0002 =           offset   equ      2          ;number of disk tracks used by cp/m
 33      0004 =           cdisk    equ      0004h      ;address of last logged disk on warm start
 34      0080 =           buff     equ      0080h      ;default buffer address
 35      000a =           retry    equ      10         ;max retries on disk i/o before error
 36                       ;
 37                       ;        perform following functions
 38                       ;        boot     cold start
 39                       ;        wboot warm start (save i/o byte)
 40                       ;        (boot and wboot are the same for mds)
 41                       ;        const    console status
 42                       ;                 reg-a = 00 if no character ready
 43                       ;                 reg-a = ff if character ready
 44                       ;        conin    console character in (result in reg-a)
 45                       ;        conout   console character out (char in reg-c)
 46                       ;        list     list out (char in reg-c)
 47                       ;        punch    punch out (char in reg-c)
 48                       ;        reader   paper tape reader in (result to reg-a)
 49                       ;        home     move to track 00
 50                       ;
 51                       ;        (the following calls set-up the io parameter block for the
 52                       ;        mds, which is used to perform subsequent reads and writes)
 53                       ;        seldsk   select disk given by reg-c (0, 1, 2...)
 54                       ;        settrk   set track address (0,...76) for subsequent read-write
 55                       ;        setsec   set sector address (1,...,26) for subsequent read-write
 56                       ;        setdma   set subsequent dma address (initially 80h)
 57                       ;
 58                       ;        (read and write assume previous calls to set up the io parameters)
 59                       ;        read     read track/sector to preset dma address
 60                       ;        write    track/sector from preset dma address
 61                       ;
 62                       ;        jump vector for individual routines
 63      1600 c3b316               jmp      boot
 64      1603 c3c316      wboote:  jmp      wboot
 65      1606 c36117               jmp      const
 66      1609 c36417               jmp      conin
 67      160c c36a17               jmp      conout
 68      160f c36d17               jmp      list
 69      1612 c37217               jmp      punch
 70      1615 c37517               jmp      reader
 71      1618 c37817               jmp      home
 72      161b c37d17               jmp      seldsk
 73      161e c3a717               jmp      settrk
 74      1621 c3ac17               jmp      setsec
 75      1624 c3bb17               jmp      setdma
 76      1627 c3c117               jmp      read
 77      162a c3ca17               jmp      write
 78      162d c37017               jmp      listst     ;list status
 79      1630 c3b117               jmp      sectran
 80                       ;
 81                                maclib   diskdef    ;load the disk definition library
 82                                disks    4          ;four disks
 83      1633+=           dpbase   equ      $          ;base of disk parameter blocks
 84      1633+82160000    dpe0:    dw       xlt0, 0000h      ;translate table
 85      1637+00000000             dw       0000h, 0000h     ;scratch area
 86      163b+6e187316             dw       dirbuf, dpb0     ;dir buff, parm block
 87      163f+0d19ee18             dw       csv0, alv0       ;check, alloc vectors
 88      1643+82160000    dpe1:    dw       xlt1, 0000h      ;translate table
 89      1647+00000000             dw       0000h, 0000h     ;scratch area
 90      164b+6e187316             dw       dirbuf, dpb1     ;dir buff, parm block
 91      164f+3c191d19             dw       csv1, alv1       ;check, alloc vectors
 92      1653+82160000    dpe2:    dw       xlt2, 0000h      ;translate table
 93      1657+00000000             dw       0000h, 0000h     ;scratch area
 94      165b+6e187316             dw       dirbuf, dpb2     ;dir buff, parm block
 95      165f+6b194c19             dw       csv2, alv2       ;check, alloc vectors
 96      1663+82160000    dpe3:    dw       xlt3, 0000h      ;translate table
 97      1667+00000000             dw       0000h, 0000h     ;scratch area
 98      166b+6e187316             dw       dirbuf, dpb3     ;check, alloc block
 99      166f+9a197b19             dw       csv3, alv3       ;dir buff, parm vectors
100                                diskdef  0, 1, 26, 6, 1024, 243, 64, 64, offset
101      1673+=           dpb0     equ      $                ;disk parm block
102      1673+1a00                 dw       26               ;sec per track
103      1675+03                   db       3                ;block shift
104      1676+07                   db       7                ;block mask
105      1677+00                   db       0                ;extnt mask
106      1678+f200                 dw       242              ;disk size-1
107      167a+3f00                 dw       63               ;directory max
108      167c+c0                   db       192              ;alloc0
109      167d+00                   db       0                ;alloc1
110      167e+1000                 dw       16               ;check size
111      1680+0200                 dw       2                ;offset
112      1682+=           xlt0     equ      $                ;translate table
113      1682+01                   db       1
114      1683+07                   db       7
115      1684+0d                   db       13
116      1685+13                   db       19
117      1686+19                   db       25
118      1687+05                   db       5
119      1688+0b                   db       11
120      1689+11                   db       17
121      168a+17                   db       23
122      168b+03                   db       3
123      168c+09                   db       9
124      168d+0f                   db       15
125      168e+15                   db       21
126      168f+02                   db       2
127      1690+08                   db       8
128      1691+0e                   db       14
129      1692+14                   db       20
130      1693+1a                   db       26
131      1694+06                   db       6
132      1695+0c                   db       12
133      1696+12                   db       18
134      1697+18                   db       24
135      1698+04                   db       4
136      1699+0a                   db       10
137      169a+10                   db       16
138      169b+16                   db       22
139                                diskdef  1,0
140      1673+ =          dpb1     equ      dpb0       ;equivalent parameters
141      001f+ =          als1     equ      als0       ;same allocation vector size
142      0010+ =          css1     equ      css0       ;same checksum vector size
143      1682+ =          xlt1     equ      xlt0       ;same translate table
144                                diskdef  2, 0
145      1673+ =          dpb2     equ      dpb0       ;equivalent parameters
146      001f+ =          als2     equ      als0       ;same allocation vector size
147      0010+ =          css2     equ      css0       ;same checksum vector size
148      1682+ =          xlt2     equ      xlt0       ;same translate table
149                                diskdef  3, 0
150      1673+ =          dpb3     equ      dpb0       ;equivalent parameters
151      001f+ =          als3     equ      als0       ;same allocation vector size
152      0010+ =          css3     equ      css0       ;same checksum vector size
153      1682+ =          xlt3     equ      xlt0       ;same translate table
154                       ;        endef occurs at end of assembly
155                       ;
156                       ;        end of controller--independent code, the remaining subroutines
157                       ;        are tailored to the particular operating environment, and must
158                       ;        be altered for any system which differs from the intel mds.
159                       ;
160                       ;        the following code assumes the mds monitor exists at 0f800h
161                       ;        and uses the i/o subroutines within the monitor
162                       ;
163                       ;        we also assume the mds system has four disk drives
164      00fd =           revrt    equ      0fdh       ;interrupt revert port
165      00fc =           intc     equ      0fch       ;interrupt mask port
166      00f3 =           icon     equ      0f3h       ;interrupt control port
167      007E =           inte     equ      0111$1110b       ;enable rst 0 (warm boot), rst 7 (monitor)
168                       ;
169                       ;        mds monitor equates
170      f800 =           mon80    equ      0f800h     ;mds monitor
171      ff0f =           rmon80   equ      0ff0fh     ;restart mon80 (boot error)
172      f803 =           ci       equ      0f803h     ;console character to reg-a
173      f806 =           ri       equ      0f806h     ;reader in to reg-a
174      f809 =           co       equ      0f809h     ;console char from c to console out
175      f80c =           po       equ      0f80ch     ;punch char from c to punch device
176      f80f =           lo       equ      0f80fh     ;list from c to list device
177      f812 =           csts     equ      0f812h     ;console status 00/ff to register a
178                       ;
179                       ;        disk ports and commands
180      0078 =           base     equ      78h        ;base of disk command io ports
181      0078 =           dstat    equ      base       ;disk status (input)
182      0079 =           rtype    equ      base+1     ;result type (input)
183      007b =           rbyte    equ      base+3     ;result byte (input)
184                       ;
185      0079 =           ilow     equ      base+1     ;iopb low address (output)
186      007a =           ihigh    equ      base+2     ;iopb high address (output)
187                       ;
188      0004 =           readf    equ      4h         ;read function
189      0006 =           writf    equ      6h         ;write function
190      0003 =           recal    equ      3h         ;recalibrate drive
191      0004 =           iordy    equ      4h         ;i/o finished mask
192      000d =           cr       equ      0dh        ;carriage return
193      000a =           lf       equ      0ah        ;line-feed
194                       ;
195                       signon:  ;signon message: xxk cp/m vers y.y
196      169c 0d0a0a               db       cr, lf, lf
197                                if       test
198                                db       '32'       ;32k example bios
199                       endif
200                                if       not test
201      169f 3030                 db       '00'       ;memory size filled by relocator
202                                endif
203      16a1 6b2043502f           db       'k cp/m vers '
204      16ad 322e32               db       ver/10+'0', ',' vers mod 10+'0'
205      16b0 0d0a00               db       cr, lf, 0
206                       ;
207                       boot:    ;print signon message and go to ccp
208                       ;        (note: mds boot initialized iobyte at 0003h)
209      16b3 310001               lxi      sp, buff+80h
210      16b6 219c16               lxi      h, signon
211      16b9 cdd317               call     prmsg      ;print message
212      16bc af                   xra      a          ;clear accumulator
213      16bd 320400               sta      cdisk      ;set initially to disk a
214      16c0 c30f17               jmp      gocpm      ;go to cp/m
215                       ;
216                       ;
217                       wboot:;  loader on track 0, sector 1, which will be skipped for warm
218                       ;        read cp/m from disk--assuming there is a 128 byte cold start
219                       ;        start
220                       ;
221      16c3 318000               lxi      sp, buff   ;using dma--thus 80 thru ff available for stack
222                       ;
223      16c6 0e0a                 mvi      c, retry   ;max retries
224      16c8 c5                   push     b
225                       wboot0:  ;enter here on error retries
226      16c9 010000               lxi      b, cpmb    ;set dma address to start of disk system
227      16cc cdbb17               call     setdma
228      16cf 0e00                 mvi      c, 0       ;boot from drive 0
229      16d1 cd7d17               call     seldsk
230      16d4 0e00                 mvi      c, 0
231      16d6 cda717               call     settrk     ;start with track 0
232      16d9 0e02                 mvi      c, 2       ;start reading sector 2
233      16db cdac17               call     setsec
234                       ;
235                       ;        read sectors, count nsects to zero
236      16de c1                   pop      b          ;10-error count
237      16df 062c                 mvi      b, nsects
238                       rdsec:   ;read next sector
239      16e1 c5                   push     b          ;save sector count
240      16e2 cdc117               call     read
241      16e5 c24917               jnz      booterr    ;retry if errors occur
242      16e8 2a6c18               lhld     iod        ;increment dma address
243      16eb 118000               lxi      d, 128     ;sector size
244      16ee 19                   dad      d          ;incremented dma address in hl
245      16ef 44                   mov      b, h
246      16f0 4d                   mov      c, l       ;ready for call to set dma
247      16f1 cdbb17               call     setdma
248      16f4 3a6b18               lda      ios        ;sector number just read
249      16f7 fe1a                 cpi      26         ;read last sector?
250      16f9 da0517               jc       rd1
251                       ;        must be sector 26, zero and go to next track
252      16fc 3a6a18               lda      iot        ;get track to register a
253      16ff 3c                   inr      a
254      1700 4f                   mov      c, a       ;read for call
255      1701 cda717               call     settrk
256      1704 af                   xra      a          ;clear sector number
257      1705 3c          rd1:     inr      a          ;to next sector
258      1706 4f                   mov      c, a       ;ready for call
259      1707 cdac17               call     setsec
260      170a c1                   pop      b          ;recall sector count
261      170b 05                   dcr      b          ;done?
262      170c c2e116               jnz      rdsec
263                       ;
264                       ;        done with the load, reset default buffer address
265                       gocpm:   ;(enter here from cold start boot)
266                       ;        enable rst0 and rst7
267      170f f3                   di
268      1710 3e12                 mvi      a, 12h     ;initialize command
269      1712 d3fd                 out      revrt
270      1714 af                   xra      a
271      1715 d3fc                 out      intc       ;cleared
272      1717 3e7e                 mvi      a, inte    ;rst0 and rst7 bits on
273      1719 d3fc                 out      intc
274      171b af                   xra      a
275      171c d3f3                 out      icon       ;interrupt control
276                       ;
277                       ;        set default buffer address to 80h
278      171e 018000               lxi      b, buff
279      1721 cdbb17               call     setdma
280                       ;
281                       ;        reset monitor entry points
282      1724 3ec3                 mvi      a, jmp
283      1726 320000               sta      0
284      1729 210316               lxi      h, wboote
285      172c 220100               shld     1          ;jump wboot at location 00
286      172f 320500               sta      5
287      1732 210608               lxi      h, bdos
288      1735 220600               shld     6          ;jmp bdos at location 5
289                                if       not test
290      1738 323800               sta      7*8        ;jmp to mon80 (may have changed by ddt)
291      173b 2100f8               lxi      h, mon80
292      173e 223900               shld     7*8+1
293                                endif
294                       ;        leave iobyte set
295                       ;        previously selected disk was b, send parameter to cpm
296      1741 3a0400               lda      cdisk      ;last logged disk number
297      1744 4f                   mov      c, a       ;send to ccp to log it in
298      1745 fb                   ei
299      1746 c30000               jmp      cpmb
300                       ;
301                       ;        error condition occurred, print message and retry
302                       booterr:
303      1749 c1                   pop      b          ;recall counts
304      174a 0d                   dcr      c
305      174b ca5217               jz       booter0
306                       ;        try again
307      174e c5                   push     b
308      174f c3c916               jmp      wboot0
309                       ;
310                       booter0:
311                       ;        otherwise too many retries
312      1752 215b17               lxi      h, bootmsg
313      1755 cdd317               call     prmsg
314      1758 c30fff               jmp      rmon80     ;mds hardware monitor
315                       ;
316                       bootmsg:
317      175b 3f626f6f74           db       '?boot', 0
318                       ;
319                       ;
320                       const:   console status to reg-a
321                       ;        (exactly the same as mds call)
322      1761 c312f8               jmp      csts
323                       ;
324                       conin:   ;console character to reg-a
325      1764 cd03f8               call     ci
326      1767 e67f                 ani      7fh        ;remove parity bit
327      1769 c9                   ret
328                       ;
329                       conout:  ;console character from c to console out
330      176a c309f8               jmp      co
331                       ;
332                       list:    ;list device out
333                       ;        (exactly the same as mds call)
334      176d c30ff8               jmp      lo
335                       ;
336                       listst:
337                                ;return list status
338      1770 af                   xra      a
339      1771 c9                   ret                 ;always not ready
340                       ;
341                       punch:   ;punch device out
342                       ;        (exactly the same as mds call)
343      1772 c30cf8               jmp      po
344                       ;
345                       reader:  ;reader character in to reg-a
346                       ;        (exactly the same as mds call)
347      1775 c306f8               jmp      ri
348                       ;
349                       home:    ;move to home position
350                       ;        treat as track 00 seek
351      1778 0e00                 mvi      c, 0
352      177a c3a717               jmp      settrk
353                       ;
354                       seldsk:  ;select disk given by register c
355      177d 210000               lxi      h, 0000h   ;return 0000 if error
356      1780 79                   mov      a, c
357      1781 fe04                 cpi      ndisks     ;too large?
358      1783 d0                   rnc                 ;leave hl = 0000
359                       ;
360      1784 e602                 ani      10b        ;00 00 for drive 0, 1 and 10 10 for drive 2, 3
361      1786 326618               sta      dbank      ;to select drive bank
362      1789 79                   mov      a, c       ;00, 01, 10, 11
363      178a e601                 ani      1b         ;mds has 0, 1 at 78, 2, 3 at 88
364      178c b7                   ora      a          ;result 00?
365      178d ca9217               jz       setdrive
366      1790 3e30                 mvi      a, 00110000b     ;selects drive 1 in bank
367                       setdrive:
368      1792 47                   mov      b, a       ;save the function
369      1793 216818               lxi      h, iof     ;io function
370      1796 7e                   mov      a, m
371      1797 e6cf                 ani      11001111b  ;mask out disk number
372      1799 b0                   ora      b          ;mask in new disk number
373      179a 77                   mov      m, a       ;save it in iopb
374      179b 69                   mov      l, c
375      179c 2600                 mvi      h, 0       ;hl=disk number
376      179e 29                   dad      h          ;*2
377      179f 29                   dad      h          ;*4
378      17a0 29                   dad      h          ;*8
379      17a1 29                   dad      h          ;*16
380      17a2 113316               lxi      d, dpbase
381      17a5 19                   dad      d          ;hl=disk header table address
382      17a6 c9                   ret
383                       ;
384                       ;
385                       settrk:  ;set track address given by c
386      17a7 216a18               lxi      h, iot
387      17aa 71                   mov      m, c
388      17ab c9                   ret
389                       ;
390                       setsec:  ;set sector number given by c
391      17ac 216b18               lxi      h, ios
392      17af 71                   mov      m, c
393      17b0 c9                   ret
394                       sectran:
395                                         ;translate sector bc using table at de
396      17b1 0600                 mvi      b, 0       ;double-precision sector number in bc
397      17b3 eb                   xchg                ;translate table address to hl
398      17b4 09                   dad      b          ;translate (sector) address
399      17b5 7e                   mov      a, m       ;translated sector number to a
400      17b6 326b18               sta      ios
401      17b9 6f                   mov      l, a       ;return sector number in l
402      17ba c9                   ret
403                       ;
404                       setdma:  ;set dma address given by regs b, c
405      17bb 69                   mov      l, c
406      17bc 60                   mov      h, b
407      17bd 226c18               shld     iod
408      17c0 c9                   ret
409                       ;
410                       read:    ;read next disk record (assuming disk/trk/sec/dma set)
411      17c1 0e04                 mvi      c, readf   ;set to read function
412      17c3 cde017               call     setfunc
413      17c6 cdf017               call     waitio     ;perform read function
414      17c9 c9                   ret                 ;may have error set in reg-a
415                       ;
416                       ;
417                       write:   ;disk write function
418      17ca 0e06                 mvi      c, writf
419      17cc cde017               call     setfunc    ;set to write function
420      17cf cdf017               call     waitio
421      17d2 c9                   ret                 ;may have error set
422                       ;
423                       ;
424                       ;        utility subroutines
425                       prmsg:   ;print message at h, l to 0
426      17d3 7e                   mov      a, m
427      17d4 b7                   ora      a          zero?
428      17d5 c8                   rz
429                       ;        more to print
430      17d6 e5                   push     h
431      17d7 4f                   mov      c,a
432      17d8 cd6a17               call     conout
433      17db e1                   pop      h
434      17dc 23                   inx      h
435      17dd c3d317               jmp      prmsg
436                       ;
437                       setfunc:
438                       ;        set function for next i/o (command in reg-c)
439      17e0 216818               lxi      h, iof     ;io function address
440      17e3 7e                   mov      a, m       ;get it to accumulator for masking
441      17e4 e6f8                 ani      11111000b  ;remove previous command
442      17e6 b1                   ora      c          ;set to new command
443      17e7 77                   mov      m, a       ;replaced in iopb
444                       ;        the mds-800 controller requires disk bank bit in sector byte
445                       ;        mask the bit from the current i/o function
446      17e8 e620                 ani      00100000b        ;mask the disk select bit
447      17ea 216b18               lxi      h, ios           ;address the sector select byte
448      17ed b6                   ora      m                ;select proper disk bank
449      17ee 77                   mov      m, a             ;set disk select bit on/off
450      17ef c9                   ret
451                       ;
452                       waitio:
453      17f0 0e0a                 mvi      c, retry   ;max retries before perm error
454                       rewait:
455                       ;        start the i/o function and wait for completion
456      17f2 cd3f18               call     intype     ;in rtype
457      17f5 cd4c18               call     inbyte     ;clears the controller
458                       ;
459      17f8 3a6618               lda      dbank            ;set bank flags
460      17fb b7                   ora      a                ;zero if drive 0, 1 and nz if 2, 3
461      17fc 3e67                 mvi      a, iopb and offh ;low address for iopb
462      17fe 0618                 mvi      b, iopb shr 8    ;high address for iopb
463      1800 c20b18               jnz      iodr1      ;drive bank 1?
464      1803 d379                 out      ilow             ;low address to controller
465      1805 78                   mov      a, b
466      1806 d37a                 out      ihigh      ;high address
467      1808 c31018               jmp      waito            ;to wait for complete
468                       ;
469                       iodr1:   ;drive bank 1
470      180b d389                 out      ilow+10h         ;88 for drive bank 10
471      180d 78                   mov      a, b
472      180e d38a                 out      ihigh+10h
473                       ;
474      1810 cd5918      waito:   call     instat           ;wait for completion
475      1813 e604                 ani      iordy            ;ready?
476      1815 ca1018               jz       waito
477                       ;
478                       ;        check io completion ok
479      1818 cd3f18               call     intype           ;must be io complete (00) unlinked
480                       ;        00 unlinked i/o complete, 01 linked i/o complete (not used)
481                       ;        io disk status changed    11 (not used)
482      181b fe02                 cpi      10b              ;ready status change?
483      181d ca3218               jz       wready
484                       ;
485                       ;        must be 00 in the accumulator
486      1820 b7                   ora      a
487      1821 c23818               jnz      werror           ;some other condition, retry
488                       ;
489                       ;        check i/o error bits
490      1824 cd4c18               call     inbyte
491      1827 17                   ral
492      1828 da3218               jc       wready           ;unit not ready
493      182b 1f                   rar
494      182c e6fe                 ani      11111110b        ;any other errors? (deleted data ok)
495      182e c23818               jnz      werror
496                       ;
497                       ;        read or write is ok, accumulator contains zero
498      1831 c9                   ret
499                       ;
500                       wready:  ;not ready, treat as error for now
501      1832 cd4c18               call     inbyte           ;clear result byte
502      1835 c33818               jmp      trycount
503                       ;
504                       werror:  ;return hardware malfunction (crc, track, seek, etc.)
505                       ;        the mds controller has returned a bit in each position
506                       ;        of the accumulator, corresponding to the conditions:
507                       ;        0        -deleted data (accepted as ok above)
508                       ;        1        -crc error
509                       ;        2        -seek error
510                       ;        3        -address error (hardware malfunction)
511                       ;        4        -data over/under flow (hardware malfunction)
512                       ;        5        -write protect (treated as not ready)
513                       ;        6        -write error (hardware malfunction)
514                       ;        j        -not ready
515                       ;        (accumulator bits are numbered 7 6 5 4 3 2 1 0)
516                       ;
517                       ;        it may be useful to filter out the various conditions,
518                       ;        but we will get a permanent error message if it is not
519                       ;        recoverable.  in any case, the not ready condition is
520                       ;        treated as a separated condition for later improvement
521                       trycount:
522                       ;        register c contains retry count, decrement 'til zero
523      1838 0d                   dcr      c
524      1839 c2f217               jnz      rewait     ;for another try
525                       ;
526                       ;        cannot recover from error
527      183c 3e01                 mvi      a, 1       ;error code
528      183e c9                   ret
529                       ;
530                       ;        intype, inbyte, instat read drive bank 00 or 10
531      183f 3a6618      intype:  lda      dbank
532      1842 b7                   ora      a
533      1843 c24918               jnz      intyp1     ;skip to bank 10
534      1846 db79                 in       rtype
535      1848 c9                   ret
536      1849 db89        intyp1:  in       rtype+10h        ;78 for 0, 1 88 for 2, 3
537      184b c9                   ret
538                       ;
539      184c 3a6618      inbyte:  lda      dbank
540      184f b7                   ora      a
541      1850 c25618               jnz      inbyt1
542      1853 db7b                 in       rbyte
543      1855 c9                   ret
544      1856 db8b        inbyt1:  in       rbyte+10h
545      1858 c9                   ret
546                       ;
547      1859 3a6618      instat:  lda      dbank
548      185c b7                   ora      a
549      185d c26318               jnz      insta1
550      1860 db78                 in       dstat
551      1862 c9                   ret
552      1863 db88        insta1:  in       dstat+10h
553      1865 c9                   ret
554                       ;
555                       ;
556                       ;
557                       ;        data areas (must be in ram)
558      1866 00          dbank:   db       0          ;disk bank 00 if drive 0, 1
559                                                    ;          10 if drive 2, 3
560                       iopb:    ;io parameter block
561      1867 80                   db       80h        ;normal i/o operation
562      1868 04          iof:     db       readf      ;io function, initial read
563      1869 01          ion:     db       1          ;number of sectors to read
564      186a 02          iot:     db       offset     ;track number
565      186b 01          ios:     db       1          ;sector number
566      186c 8000        iod:     dw       buff       ;io address
567                       ;
568                       ;
569                       ;        define ram areas for bdos operation
570                                endef
571      186e+=           begdat   equ      $
572      186e+            dirbuf:  ds       128        ;directory access buffer
573      18ee+            alv0:    ds       31
574      190d+            csv0:    ds       16
575      191d+            alv1:    ds       31
576      193c+            csv1:    ds       16
577      194c+            alv2:    ds       31
578      196b+            csv2:    ds       16
579      197b+            alv3:    ds       31
580      199a+            csv3:    ds       16
581      19aa+=           enddat   equ      $
582      013c+=           datsiz   equ      $-begdat
583      19aa                      end


als1            001f    141#
als2            001f    146#
als3            001f    151#
alv0            18ee     87     573#
alv1            191d     91     575#
alv2            194c     95     577#
alv3            197b     99     579#
base            0078    180#    181     182     183    185    186
bdos            0806     29#    287
begdat          186e    571#    582
bias            0000     19#     22#
boot            16b3     63     207#
booter0         1752    305     310#
booterr         1749    241     302#
bootmsg         175b    312     316#
buff            0080     34#    209     221     278     566
cdisk           0004     33#    213     296
ci              f803    172#    325
co              f809    174#    330
conin           1764     66     324#
conout          176a     67     329#    432
const           1761     65     320#
cpmb            0000     28#     29      30     226     299
cpml            1600     30#     31
cr              000d    192#    196     205
css1            0010    142#
css2            0010    147#
css3            0010    152#
csts            f812    177#    322
csv0            190d     87     574#
csv1            193c     91     576#
csv2            196b     95     578#
csv3            199a     99     580#
datsiz          013c    582#
dbank           1866    361     459     531     539     539     547     558#
dirbuf          186e     86      90      94      98     572#
dpb0            1673     86     101#    140     145     150
dpb1            1673     90     140#
dpb2            1673     94     145#
dpb3            1673     98     150#
dpbase          1633     83#    380
dpe0            1633     84#
dpe1            1643     88#
dpe2            1653     92#
dpe3            1663     96#
dstat           0078    181#    550     552
enddat          19aa    581#
false           0000     15#     16
gocpm           170f    214     265#
home            1778     71     349#
icon            00fe    166#    275
ihigh           007a    186#    466     472
ilow            0079    185#    464     470
inbyt1          1856    541     544#
inbyte          184c    457     490     501     539#
insta1          1863    549     552#
instat          1859    474     547#
intc            00fc    165#    271     273
inte            007e    167#    272
intyp1          1849    533     536#
intype          183f    456     479     531#
iod             186c    242     407     566#
iodr1           180b    463     469#
iof             1868    369     439     562#
ion             1869    563#
iopb            1867    461     462     560#
iordy           0004    191#    475
ios             186b    248     391     400     447     565#
iot             186a    252     386     564#
lf              000a    193#    196     196     205
list            176d     68     332#
listst          1770     78     336#
lo              f80f    176#    334
mon80           f800    170#    291
nsects          002c     31#    237
offset          0002     32#    100     564
patch           1600     25#     27      28
po              f80c    175#    343
prmsg           17d3    211     313     425#    435
punch           1772     69     341#
rbyte           007b    183#    542     544
rd1             1705    250     257#
rdsec           16e1    238#    262
read            17c1     76     240     410#
reader          1775     70     345#
readf           0004    188#    411     562
recal           0003    190#
retry           000a     35#    223     453
revrt           00fd    164#    269
rewait          17f2    454#    524
ri              f806    173#    347
rmon80          ff0f    171#    314
rtype           0079    182#    534     536
sectran         17b1     79     394#
seldsk          177d     72     229     354#
setdma          17bb     75     227     247     279     404#
setdrive        1792    365     367#
setfunc         17e0    412     419     437#
setsec          17ac     74     233     259     390#
settrk          17a7     73     231     255     352     385#
signon          169c    195#    210
test            0000     16#     18      21     197     200     289
true            ffff     14#     15
trycount        1838    502     521#
vers            0016      6#    204     204
waito           1810    467     474#    476
waitio          17f0    413     420     452#
wboot           16c3     64     217#
wboot0          16c9    225#    308
wboote          1603     64#    284
werror          1838    487     495     504#
wready          1832    483     492     500#
write           17ca     77     417#
writf           0006    189#    418
xlt0            1682     84     112#    143     148     153
xlt1            1682     88     143#
xlt2            1682     92     148#
xlt3            1682     96     153#
.nx appb

