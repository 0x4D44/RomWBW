XS		9	N0




















=WCP/M

=&SWOperating System

=&SWManual










=&SCopyright (c) 1982

=Digital Research
=P.O. Box 579
=160 Central Avenue
=Pacific Grove, CA 93950
=(408) 649-3896
=TWX 910 360 5001




=All Rights Reserved

















	9	C0





=COPYRIGHT

MCopyright (c) 1976, 1977, 1978, 1979, 1982, 1983,
XMand 1984 by Digital Research Inc.  All rights
XMreserved.  No part of this publication may be
XMreproduced, transmitted, transcribed, stored in a
XMretrieval system, or translated into any language or
XMcomputer language, in any form or by any means,
XMelectronic, mechanical, magnetic, optical, chemical,
XMmanual or otherwise, without the prior written
XMpermission of Digital Research Inc., Post Office Box
X579, Pacific Grove, California, 93950.

MThus, readers are granted permission to include the
XMexample programs, either in whole or in part, in
Xtheir own programs.


=DISCLAIMER

MDigital Research Inc. makes no representations or
XMwarranties with respect to the contents hereof and
XMspecifically disclaims any implied warranties of
XMmerchantability or fitness for any particular
XMpurpose.  Further, Digital Research Inc. reserves
XMthe right to revise this publication and to make
XMchanges from time to time in the content hereof
XMwithout obligation of Digital Research Inc. to
Xnotify any person of such revision or changes.


=TRADEMARKS

MCP/M, CP/NET, and Digital Research and its logo are
XMregistered trademarks of Digital Research.  ASM,
XMDESPOOL, DDT, LINK-80, MAC, MP/M, PL/I-80 and SID
XMare trademarks of Digital Research.  IBM is a
XMregistered trademark of International Business
XMMachines.  Intel is a registered trademark of Intel
XMCorporation.  TI Silent 700 is a trademark of Texas
XMInstruments Incorporated.  Zilog and Z80 are
Xregistered trademarks of Zilog, Inc.



MThe ECP/M Operating System ManualR was prepared using
XMthe Digital Research TEX Text Formatter and printed
Xin the United States of America.


=*********************************
=*   First Edition:  1976        *
=*  Second Edition:  July 1982   *
=*   Third Edition:  March 1983  *
=*  Fourth Edition:  March 1984  *
=*********************************




	9	K0




=WTable of Contents



&SW1  CP/M Features and Facilities

&S   1.1  Introduction  . . . . . . . . . . . . . . . . . . .   1-1

   1.2  Functional Description  . . . . . . . . . . . . . .   1-3

        1.2.1  General Command Structure  . . . . . . . . .   1-3
        1.2.2  File References  . . . . . . . . . . . . . .   1-3

   1.3  Switching Disks . . . . . . . . . . . . . . . . . .   1-5
   1.4  Built-in Commands . . . . . . . . . . . . . . . . .   1-6

        1.4.1  ERA Command  . . . . . . . . . . . . . . . .   1-6
        1.4.2  DIR Command  . . . . . . . . . . . . . . . .   1-7
        1.4.3  REN Command  . . . . . . . . . . . . . . . .   1-8
        1.4.4  SAVE Command . . . . . . . . . . . . . . . .   1-8
        1.4.5  TYPE Command . . . . . . . . . . . . . . . .   1-9
        1.4.6  USER Command . . . . . . . . . . . . . . . .   1-9

   1.5  Line Editing and Output Control . . . . . . . . . .  1-10

   1.6  Transient Commands  . . . . . . . . . . . . . . . .  1-11

        1.6.1  STAT Command . . . . . . . . . . . . . . . .  1-12
        1.6.2  ASM Command  . . . . . . . . . . . . . . . .  1-18
        1.6.3  LOAD Command . . . . . . . . . . . . . . . .  1-19
        1.6.4  PIP  . . . . . . . . . . . . . . . . . . . .  1-20
        1.6.5  ED Command . . . . . . . . . . . . . . . . .  1-29
        1.6.6  SYSGEN Command . . . . . . . . . . . . . . .  1-31
        1.6.7  SUBMIT Command . . . . . . . . . . . . . . .  1-33
        1.6.8  DUMP Command . . . . . . . . . . . . . . . .  1-35
        1.6.9  MOVCPM Command . . . . . . . . . . . . . . .  1-35

   1.7  BDOS Error Messages . . . . . . . . . . . . . . . .  1-37

   1.8  CP/M Operation on the Model 800 . . . . . . . . . .  1-38


W2  The CP/M Editor

&S   2.1  Introduction to ED  . . . . . . . . . . . . . . . .   2-1

        2.1.1  ED Operation . . . . . . . . . . . . . . . .   2-1
        2.1.2  Text Transfer Functions  . . . . . . . . . .   2-3
        2.1.3  Memory Buffer Organization . . . . . . . . .   2-4
        2.1.4  Line Numbers and ED Start-up . . . . . . . .   2-5
        2.1.5  Memory Buffer Operation  . . . . . . . . . .   2-6
        2.1.6  Command Strings  . . . . . . . . . . . . . .   2-7
        2.1.7  Text Search and Alteration . . . . . . . . .  2-10
        2.1.8  Source Libraries . . . . . . . . . . . . . .  2-13
        2.1.9  Repetitive Command Execution . . . . . . . .  2-14


                               iii








=WTable of Contents

=&SW(continued)



&S   2.2  ED Error Conditions . . . . . . . . . . . . . . . .  2-14

   2.3  Control Characters and Commands . . . . . . . . . .  2-16


W3  CP/M Assembler

&S   3.1  Introduction  . . . . . . . . . . . . . . . . . . .   3-1

   3.2  Program Format  . . . . . . . . . . . . . . . . . .   3-3

   3.3  Forming the Operand . . . . . . . . . . . . . . . .   3-4

        3.3.1  Labels . . . . . . . . . . . . . . . . . . .   3-4
        3.3.2  Numeric Constants  . . . . . . . . . . . . .   3-5
        3.3.3  Reserved Words . . . . . . . . . . . . . . .   3-5
        3.3.4  String Constants . . . . . . . . . . . . . .   3-6
        3.3.5  Arithmetic and Logical Operators . . . . . .   3-7
        3.3.6  Precedence of Operators  . . . . . . . . . .   3-8

   3.4  Assembler Directives  . . . . . . . . . . . . . . .   3-9

        3.4.1  The ORG Directive  . . . . . . . . . . . . .  3-10
        3.4.2  The END Directive  . . . . . . . . . . . . .  3-10
        3.4.3  The EQU Directive  . . . . . . . . . . . . .  3-11
        3.4.4  The SET Directive  . . . . . . . . . . . . .  3-11
        3.4.5  The IF and ENDIF Directives  . . . . . . . .  3-12
        3.4.6  The DB Directive . . . . . . . . . . . . . .  3-13
        3.4.7  The DW Directive . . . . . . . . . . . . . .  3-14
        3.4.8  The DS Directive . . . . . . . . . . . . . .  3-14

   3.5  Operation Codes . . . . . . . . . . . . . . . . . .  3-15

        3.5.1  Jumps, Calls, and Returns  . . . . . . . . .  3-15
        3.5.2  Immediate Operand Instructions . . . . . . .  3-17
        3.5.3  Increment and Decrement Instructions . . . .  3-17
        3.5.4  Data Movement Instructions . . . . . . . . .  3-18
        3.5.5  Arithmetic Logic Unit Operations . . . . . .  3-19
        3.5.6  Control Instructions . . . . . . . . . . . .  3-21

   3.6  Error Messages  . . . . . . . . . . . . . . . . . .  3-21

   3.7  A Sample Session  . . . . . . . . . . . . . . . . .  3-23








                               iv








=WTable of Contents

=&SW(continued)



&SW4  CP/M Dynamic Debugging Tool

&S   4.1  Introduction  . . . . . . . . . . . . . . . . . . .   4-1

   4.2  DDT Commands  . . . . . . . . . . . . . . . . . . .   4-3

        4.2.1  The A (Assembly) Command . . . . . . . . . .   4-3
        4.2.2  The D (Display) Command  . . . . . . . . . .   4-4
        4.2.3  The F (Fill) Command . . . . . . . . . . . .   4-5
        4.2.4  The G (Go) Command . . . . . . . . . . . . .   4-5
        4.2.5  The I (Input) Command  . . . . . . . . . . .   4-6
        4.2.6  The L (List) Command . . . . . . . . . . . .   4-6
        4.2.7  The M (Move) Command . . . . . . . . . . . .   4-7
        4.2.8  The R (Read) Command . . . . . . . . . . . .   4-7
        4.2.9  The S (Set) Command  . . . . . . . . . . . .   4-8
        4.2.1- The T (Trace) Command  . . . . . . . . . . .   4-8
        4.2.11 The U (Untrace) Command  . . . . . . . . . .   4-9
        4.2.12 The X (Examine) Command  . . . . . . . . . .   4-9

   4.3  Implementation Notes  . . . . . . . . . . . . . . .  4-10

   4.4  A Sample Program  . . . . . . . . . . . . . . . . .  4-11


W5  CP/M 2 System Interface

&S   5.1  Introduction  . . . . . . . . . . . . . . . . . . .   5-1

   5.2  Operating System Call Conventions . . . . . . . . .   5-3

   5.3  A Sample File-to-File Copy Program  . . . . . . . .  5-35

   5.4  A Sample File Dump Utility  . . . . . . . . . . . .  5-38

   5.5  A Sample Random Access Program  . . . . . . . . . .  5-42

   5.6  System Function Summary . . . . . . . . . . . . . .  5-50


W6  CP/M 2 Alteration

&S   6.1  Introduction  . . . . . . . . . . . . . . . . . . .   6-1

   6.2  First-level System Regeneration . . . . . . . . . .   6-2

   6.3  Second-level System Generation  . . . . . . . . . .   6-5

   6.4  Sample GETSYS and PUTSYS Programs . . . . . . . . .   6-9



                               v








=WTable of Contents

=&SW(continued)



&S   6.5  Disk Organization . . . . . . . . . . . . . . . . .  6-11

   6.6  The BIOS Entry Points . . . . . . . . . . . . . . .  6-13

   6.7  A Sample BIOS . . . . . . . . . . . . . . . . . . .  6-21

   6.8  A Sample Cold Start Loader  . . . . . . . . . . . .  6-21

   6.9  Reserved Locations in Page Zero . . . . . . . . . .  6-22

   6.10  Disk Parameter Tables  . . . . . . . . . . . . . .  6-23

   6.11  The DISKDEF Macro Library  . . . . . . . . . . . .  6-28

   6.12  Sector Blocking and Deblocking . . . . . . . . . .  6-32




































                               vi








=WAppendixes



&SWA  &SBasic Input/Output System (BIOS)  . . . . . . . . . . .   A-1


WB  &SA Skeletal CBIOS  . . . . . . . . . . . . . . . . . . .   B-1


WC  &SA Skeletal GETSYS/PUTSYS Program  . . . . . . . . . . .   C-1


WD  &SThe Model 800 Cold Start Loader for CP/M 2  . . . . . .   D-1


WE  &SA Skeletal Cold Start Loader  . . . . . . . . . . . . .   E-1


WF  &SCP/M Disk Definition Library  . . . . . . . . . . . . .   F-1


WG  &SBlocking and Deblocking Algorithms  . . . . . . . . . .   G-1


WH  &SGlossary  . . . . . . . . . . . . . . . . . . . . . . .   H-1


WI  &SCP/M Error Messages . . . . . . . . . . . . . . . . . .   I-1




























                               vii








=WTables, Figures, and Listings



&SWTables

&S     1-1.   Line-editing Control Characters . . . . . . . .  1-10
     1-2.   CP/M Transient Commands . . . . . . . . . . . .  1-11
     1-3.   Physical Devices  . . . . . . . . . . . . . . .  1-14
     1-4.   PIP Parameters  . . . . . . . . . . . . . . . .  1-24

     2-1.   ED Text Transfer Commands . . . . . . . . . . .   2-3
     2-2.   Editing Commands  . . . . . . . . . . . . . . .   2-6
     2-3.   Line-editing Controls . . . . . . . . . . . . .   2-7
     2-4.   Error Message Symbols . . . . . . . . . . . . .  2-13
     2-5.   ED Control Characters . . . . . . . . . . . . .  2-14
     2-6.   ED Commands . . . . . . . . . . . . . . . . . .  2-15

     3-1.   Reserved Characters . . . . . . . . . . . . . .   3-6
     3-2.   Arithmetic and Logical Operators  . . . . . . .   3-7
     3-3.   Assembler Directives  . . . . . . . . . . . . .   3-9
     3-4.   Jumps, Calls, and Returns . . . . . . . . . . .  3-15
     3-5.   Immediate Operand Instructions  . . . . . . . .  3-16
     3-6.   Increment and Decrement Instructions  . . . . .  3-17
     3-7.   Data Movement Instructions  . . . . . . . . . .  3-17
     3-8.   Arithmetic Logic Unit Operations  . . . . . . .  3-18
     3-9.   Error Codes . . . . . . . . . . . . . . . . . .  3-20
     3-10.  Error Messages  . . . . . . . . . . . . . . . .  3-21

     4-1.   Line-editing Controls . . . . . . . . . . . . .   4-2
     4-2.   DDT Commands  . . . . . . . . . . . . . . . . .   4-2
     4-3.   CPU Registers . . . . . . . . . . . . . . . . .   4-9

     5-1.   CP/M Filetypes  . . . . . . . . . . . . . . . .   5-6
     5-2.   File Control Block Fields . . . . . . . . . . .   5-7
     5-3.   Edit Control Characters . . . . . . . . . . . .  5-20

     6-1.   Standard Memory Size Values . . . . . . . . . .   6-2
     6-2.   Common Values for CP/M Systems  . . . . . . . .   6-7
     6-3.   CP/M Disk Sector Allocation . . . . . . . . . .  6-11
     6-4.   IOBYTE Field Values . . . . . . . . . . . . . .  6-15
     6-5.   BIOS Entry Points . . . . . . . . . . . . . . .  6-16
     6-6.   Reserved Locations in Page Zero . . . . . . . .  6-21
     6-7.   Disk Parameter Headers  . . . . . . . . . . . .  6-23
     6-8.   BSH and BLM Values  . . . . . . . . . . . . . .  6-25
     6-9.   EXM Values  . . . . . . . . . . . . . . . . . .  6-25
     6-10.  BLS Tabluation  . . . . . . . . . . . . . . . .  6-26

     I-1.   CP/M Error Messages . . . . . . . . . . . . . .   I-1


WFigures

&S     2-1.   Overall ED Operation  . . . . . . . . . . . . .   2-2
     2-2.   Memory Buffer Organization  . . . . . . . . . .   2-2


                               viii








=WTables, Figures, and Listings

=&SW(continued)



&SWFigures

&S     2-3.   Logical Organization of Memory Buffer . . . . .   2-4

     5-1.   CP/M Memory Organization  . . . . . . . . . . .   5-1
     5-2.   File Control Block Format . . . . . . . . . . .   5-7

     6-1.   IOBYTE Fields . . . . . . . . . . . . . . . . .  6-15
     6-2.   Disk Parameter Header Format  . . . . . . . . .  6-22
     6-3.   Disk Parameter Header Table . . . . . . . . . .  6-23
     6-4.   Disk Parameter Block Format . . . . . . . . . .  6-24
     6-5.   AL0 and AL1 . . . . . . . . . . . . . . . . . .  6-25


WListings

&S     6-1.   GETSYS Program  . . . . . . . . . . . . . . . .   6-9
     6-2.   BIOS Entry Points . . . . . . . . . . . . . . .  6-13

































                               ix








=WSection 1

=&SWCP/M Features and Facilities



&SW1.1  Introduction

     M&SCP/M  is a monitor control program for microcomputer system
XMdevelopment that uses floppy disks or Winchester hard disks for
XMbackup storage.  Using a computer system based on the Intel  8080
XMmicrocomputer, CP/M provides an environment for program
XMconstruction, storage, and editing, along with assembly and program
XMcheck-out facilities.  CP/M can be easily altered to execute with
XMany computer configuration that uses a Zilog  Z80  or an Intel 8080
XMCentral Processing Unit (CPU) and has at least 20K bytes of main
XMmemory with up to 16 disk drives.  A detailed discussion of the
XMmodifications required for any particular hardware environment is
XMgiven in Section 6.  Although the standard Digital Research version
XMoperates on a single-density Intel Model 800, microcomputer
XMdevelopment system several different hardware manufacturers support
Xtheir own input-output (I/O) drivers for CP/M.

     MThe CP/M monitor provides rapid access to programs through a
XMcomprehensive file management package.  The file subsystem supports
XMa named file structure, allowing dynamic allocation of file space as
XMwell as sequential and random file access.  Using this file system,
XMa large number of programs can be stored in both source and machine-
Xexecutable form.

     MCP/M 2 is a high-performance, single console operating system
XMthat uses table-driven techniques to allow field reconfiguration to
XMmatch a wide variety of disk capacities.  All fundamental file
XMrestrictions are removed, maintaining upward compatibility from
Xprevious versions of release 1.

     MFeatures of CP/M 2 include field specification of one to
XMsixteen logical drives, each containing up to eight megabytes.  Any
XMparticular file can reach the full drive size with the capability of
XMexpanding to thirty-two megabytes in future releases.  The directory
XMsize can be field-configured to contain any reasonable number of
XMentries, and each file is optionally tagged with Read-Only and
XMsystem attributes.  Users of CP/M 2 are physically separated by user
XMnumbers, with facilities for file copy operations from one user area
XMto another.  Powerful relative-record random access functions are
XMpresent in CP/M 2 that provide direct access to any of the 65536
Xrecords of an eight-megabyte file.

     MCP/M also supports ED, a powerful context editor, ASM , an
XMIntel-compatible assembler, and DDT , debugger subsystems.  Optional
XMsoftware includes a powerful Intel-compatible macro assembler,
XMsymbolic debugger, along with various high-level languages.  When
XMcoupled with CP/M's Console Command Processor (CCP), the resulting
Xfacilities equal or exceed similar large computer facilities.



                               1-1





CP/M Operating System Manual                    1.1  Introduction


     CP/M is logically divided into several distinct parts:

   o BIOS (Basic I/O System), hardware-dependent
   o BDOS (Basic Disk Operating System)
   o CCP (Console Command Processor)
   o TPA (Transient Program Area)

     MThe BIOS provides the primitive operations necessary to access
XMthe disk drives and to interface standard peripherals:  teletype,
XMCRT, paper tape reader/punch, and user-defined peripherals.  You can
XMtailor peripherals for any particular hardware environment by
XMpatching this portion of CP/M.  The BDOS provides disk management by
XMcontrolling one or more disk drives containing independent file
XMdirectories.  The BDOS implements disk allocation strategies that
XMprovide fully dynamic file construction while minimizing head
XMmovement across the disk during access.  The BDOS has entry points
XMthat include the following primitive operations, which the program
Xaccesses:

   o SEARCH looks for a particular disk file by name.
   o OPEN opens a file for further operations.
   o CLOSE closes a file after processing.
   o RENAME changes the name of a particular file.
   o READ reads a record from a particular file.
   o WRITE writes a record to a particular file.
   o MSELECT selects a particular disk drive for further operations.
X
     MThe CCP provides a symbolic interface between your console and
XMthe remainder of the CP/M system.  The CCP reads the console device
XMand processes commands, which include listing the file directory,
XMprinting the contents of files, and controlling the operation of
XMtransient programs, such as assemblers, editors, and debuggers.  The
XMstandard commands that are available in the CCP are listed in
XSection 1.2.1.

     MThe last segment of CP/M is the area called the Transient
XMProgram Area (TPA).  The TPA holds programs that are loaded from the
XMdisk under command of the CCP.  During program editing, for example,
XMthe TPA holds the CP/M text editor machine code and data areas.
XMSimilarly, programs created under CP/M can be checked out by loading
Xand executing these programs in the TPA.

     MAny or all of the CP/M component subsystems can be overlaid by
XMan executing program.  That is, once a user's program is loaded into
XMthe TPA, the CCP, BDOS, and BIOS areas can be used as the program's
XMdata area.  A bootstrap loader is programmatically accessible
XMwhenever the BIOS portion is not overlaid; thus, the user program
XMneed only branch to the bootstrap loader at the end of execution and
Xthe complete CP/M monitor is reloaded from disk.

     MThe CP/M operating system is partitioned into distinct modules,
XMincluding the BIOS portion that defines the hardware environment in
XMwhich CP/M is executing.  Thus, the standard system is easily
XMmodified to any nonstandard environment by changing the peripheral
Xdrivers to handle the custom system.


                               1-2





CP/M Operating System Manual          1.2  Functional Description


W1.2  Functional Description

     MY&Sou interact with CP/M primarily through the CCP, which reads
XMand interprets commands entered through the console.  In general,
XMthe CCP addresses one of several disks that are on-line.  The
XMstandard system addresses up to sixteen different disk drives.
XMThese disk drives are labeled A through P.  A disk is logged-in if
XMthe CCP is currently addressing the disk.  To clearly indicate which
XMdisk is the currently logged disk, the CCP always prompts the
XMoperator with the disk name followed by the symbol >, indicating
XMthat the CCP is ready for another command.  Upon initial start-up,
XMthe CP/M system is loaded from disk A, and the CCP displays the
Xfollowing message:

        CP/M VER x.x

Mwhere x.x is the CP/M version number.  All CP/M systems are
XMinitially set to operate in a 20K memory space, but can be easily
XMreconfigured to fit any memory size on the host system (see Section
XM1.6.9).  Following system sign-on, CP/M automatically logs in disk
XMA, prompts you with the symbol A>, indicating that CP/M is currently
XMaddressing disk A, and waits for a command.  The commands are
XMimplemented at two levels:  built-in commands and transient
Xcommands.


W1.2.1  General Command Structure

     MB&Suilt-in commands are a part of the CCP program, while
XMtransient commands are loaded into the TPA from disk and executed.
XThe following are built-in commands:

   o ERA erases specified files.
   o DIR lists filenames in the directory.
   o REN renames the specified file.
   o SAVE saves memory contents in a file.
   o TYPE types the contents of a file on the logged disk.

MMost of the commands reference a particular file or group of files.
XThe form of a file reference is specified in Section 1.2.2.


W1.2.2  File References

     MA&S file reference identifies a particular file or group of files
XMon a particular disk attached to CP/M.  These file references are
XMeither unambiguous (ufn) or ambiguous (afn).  An unambiguous file
XMreference uniquely identifies a single file, while an ambiguous file
Xreference is satisfied by a number of different files.

     MFile references consist of two parts:  the primary filename and
XMthe filetype.  Although the filetype is optional, it usually is
XMgeneric.  For example, the filetype ASM is used to denote that the
XMfile is an assembly language source file, while the primary filename
XMdistinguishes each particular source file.  The two names are
Xseparated by a period, as shown in the following example:

                               1-3





CP/M Operating System Manual          1.2  Functional Description


        filename.typ

MIn this example, filename is the primary filename of eight
XMcharacters or less, and typ is the filetype of no more than three
Xcharacters.  As mentioned above, the name

        filename

Mis also allowed and is equivalent to a filetype consisting of three
XMblanks.  The characters used in specifying an unambiguous file
Xreference cannot contain any of the following special characters:

        < > . , ; : = ? * [ ] _ % | ( ) / \textbackslash

Mwhile all alphanumerics and remaining special characters are
Xallowed.

     MAn ambiguous file reference is used for directory search and
XMpattern matching.  The form of an ambiguous file reference is
XMsimilar to an unambiguous reference, except the symbol ? can be
XMinterspersed throughout the primary and secondary names.  In various
XMcommands throughout CP/M, the ? symbol matches any character of a
Xfilename in the ? position.  Thus, the ambiguous reference

        X?Z.C?M

matches the following unambiguous filenames

        XYZ.COM

and

        X3Z.CAM

MThe * wildcard character can also be used in an ambiguous file
XMreference.  The * character replaces all or part of a filename or
Xfiletype.  Note that

        *.*

equals the ambiguous file reference

        ????????.???

while

        filename.*

and

        *.typ

are abbreviations for

        filename.???


                               1-4





CP/M Operating System Manual          1.2  Functional Description



and

        ????????.typ

respectively.  As an example,

        A>WDIR *.*

Mi&Ss interpreted by the CCP as a command to list the names of all disk
XMfiles in the directory.  The following example searches only for a
Xfile by the name X.Y:

        A>WDIR X,Y

S&Similarly, the command

        A>WDIR X?Y.C?M

Mc&Sauses a search for all unambiguous filenames on the disk that
Xsatisfy this ambiguous reference.

     MThe following file references are valid unambiguous file
Xreferences:

        X
        X.Y
        XYZ
        XYZ.COM
        GAMMA
        GAMMA.1

     MAs an added convenience, the programmer can generally specify
XMthe disk drive name along with the filename.  In this case, the
XMdrive name is given as a letter A through P followed by a colon (:).
XMThe specified drive is then logged-in before the file operation
XMoccurs.  Thus, the following are valid file references with disk
Xname prefixes:

        A:X.Y
        P:XYZ.COM
        B:XYZ
        B:X.A?M
        C:GAMMA
        C:*.ASM

MAll alphabetic lower-case letters in file and drive names are
Xtranslated to upper-case when they are processed by the CCP.


W1.3  Switching Disks

     MT&She operator can switch the currently logged disk by typing the
XMdisk drive name, A through P, followed by a colon when the CCP is
XMwaiting for console input.  The following sequence of prompts and
Xcommands can occur after the CP/M system is loaded from disk A:

                               1-5





CP/M Operating System Manual                 1.3  Switching Disks



        CP/M VER 2.2
        A>WDIR                     &SList all files on disk A.
        A:SAMPLE ASM SAMPLE PRN
        A>WB:                      &SSwitch to disk B.
        B>WDIR *.ASM               &SList all ASM files on B.
        B:DUMP ASM FILES ASM
        b>WA:                      &SSwitch back to A.


W1.4  Built-in Commands

     MT&She file and device reference forms described can now be used
XMto fully specify the structure of the built-in commands.  Assume the
Xfollowing abbreviations in the description below:

        ufn   unambiguous file reference
        afn   ambiguous file reference

MRecall that the CCP always translates lower-case characters to
XMupper-case characters internally.  Thus, lower-case alphabetics are
XMtreated as if they are upper-case in command names and file
Xreferences.


W1.4.1  ERA Command

S&Syntax:

        ERA afn

     MThe ERA (erase) command removes files from the currently 
XMlogged-in disk, for example, the disk name currently prompted by 
XMCP/M preceding the >.  The files that are erased are those that 
XMsatisfy the ambiguous file reference afn.  The followingE examplRes
Xillustrate the use of ERA:


        ERA X.Y         MThe file named X.Y on the currently logged
X                        Mdisk is removed from the disk directory and
X                        the space is returned.

        ERA X.*         MAll files with primary name X are removed
X                        from the current disk.

        ERA *.ASM       MAll files with secondary name ASM are
X                        removed from the current disk.

        ERA X?Y.C?M     MAll files on the current disk that satisfy
X                        Mthe ambiguous reference X?Y.C?M are
X                        deleted.






                               1-6





CP/M Operating System Manual               1.4  Built-in Commands


        ERA *.*         MErase all files on the current disk.  In
X                        Mthis case, the CCP prompts the console with
X                        the message

                        ALL FILES (Y/N)?

                        Mwhich requires a Y response before files
X                        are actually removed.

        ERA b:*.PRN     MAll files on drive B that satisfy the
X                        Mambiguous reference ????????.PRN are
X                        Mdeleted, independently of the currently
X                        logged disk.



W1.4.2  DIR Command

S&Syntax:

        DIR afn

     MThe DIR (directory) command causes the names of all files that 
XMsatisfy the ambiguous filename afn to be listed at the console 
Xdevice.  As a special case, the command

        DIR

Mlists the files on the currently logged disk (the command DIR is 
XMequivalenEt to thRe command DIR *.*).  The following are valid DIR
Xcommands:

        DIR X.Y
        DIR X?Z.C?M
        DIR ??.Y

     MSimilar to other CCP commands, the afn can be preceded by a
XMdrive name.  The following DIR commands cause the selected drive to
Xbe addressed before the directory search takes place:

        DIR B:
        DIR B:X.Y
        DIR B:*.A?M

     MIf no files on the selected disk satisfy the directory request,
Xthe message NO FILE appears at the console.











                               1-7





CP/M Operating System Manual               1.4  Built-in Commands


W1.4.3  REN Command

S&Syntax:

        REN ufn1=ufn2

     MThe REN (rename) command allows you to change the names of 
XMfiles on disk.  The file satisfying ufn2 is changed to ufn1.  The 
XMcurrently logged disk is assumed to contain the file to rename 
XM(ufn2).  You can also type a left-directed arrowE insteaRd of the
XMequal sign if the console supports this graphic character.  The
Xfollowing are examples of the REN command:


        REN X.Y=Q.R            The file Q.R is changed to X.Y.

        REN XYZ.COM=XYZ.XXX    MThe file XYZ.XXX is changed to
X                               XYZ.COM.


     MThe operator precedes either ufn1 or ufn2 (or both) by an
XMoptional drive address.  If ufn1 is preceded by a drive name, then
XMufn2 is assumed to exist on the same drive.  Similarly, if ufn2 is
XMpreceded by a drive name, then ufn1 is assumed to exist on the drive
XMas well.  The same drive must be specified in both cases if both
XMufn1 and ufn2 are preceded by drive names.  The following REN
Xcommands illustrate this format:


        REN A:X.ASM=Y.ASM      MThe file Y.ASM is changed to X.ASM
X                               on drive A.

        REN B:ZAP.BAS=ZOT.BAS  MThe file ZOT.BAS is changed to
X                               ZAP.BAS on drive B.

        REN B:A.ASM=B:A.BAK    MThe file A.BAK is renamed to A.ASM
X                               on drive B.


     MIf ufn1 is already present, the REN command responds with the
XMerror FILE EXISTS and not perform the change.  If ufn2 does not
XMexist on the specified disk, the message NO FILE is printed at the
Xconsole.


W1.4.4  SAVE Command

S&Syntax:

        SAVE n ufn

     MThe SAVE command places n pages (256-byte blocks) onto disk 
XMfrom the TPA and names this file ufn.  In the CP/M distribution 
XMsystem, the TPA starts at 100H (hexadecimal) which is the second 
XMpage of memory.  The SAVE command must specify 2 pEages ofR memory if


                               1-M8



X

CP/M Operating System Manual               1.4  Built-in Commands


Mthe user's program occupies the area from 100H through 2FFH.  The
XMmachine code file can be subsequently loaded and executed.  The
Xfollowing are examples of the SAVE command:


        SAVE 3X.COM            Copies 100H through 3FFH to X.COM.

        SAVE 40 Q              MCopies 100H through 28FFH to Q.
X                               MNote that 28 is the page count in
X                               M28FFH, and that 28H = 2*16+8=40
X                               decimal.

        SAVE 4 X.Y             Copies 100H through 4FFH to X.Y.


MThe SAVE command can also specify a disk drive in the ufn portion of
Xthe command, as shown in the following example:

        SAVE 10 B:ZOT.COM      MCopies 10 pages, 100H through 0AFFH,
X                               to the file ZOT.COM on drive B.



W1.4.5  TYPE Command

S&Syntax:

        TYPE ufn

     MThe TYPE command displays the content of the ASCII source file 
XMufn on the currently logged disk at the console device.  The 
Xfollowing are valid TYPE commands:

        TYPE X.Y
        TYPE X.PLM
        TYPE XXX

     MThe TYPE command expands tabs, CTRL-I characters, assuminEg tabR 
XMpRositions are set at every eighth column.  The ufn can also
Xreference a drive name.

        TYPE B:X.PRN    The file X.PRN from drive B is displayed.


W1.4.6  USER Command

S&Syntax:

        USER n

     MThe USER command allows maintenance of separate files in the 
XMsame directory.  In the syntax line, n is an integer value in the 
XMrange 0 to 15.  On cold start, the operator is automatically logged 
XMinto user area number 0, which is compatible witEh standRard CP/M 1
XMdirectories.  You can issue the USER command at any time to move to


                               1-M9



X

CP/M Operating System Manual               1.4  Built-in Commands


Manother logical area within the same directory.  Drives that are
XMlogged-in while addressing one user number are automatically active
XMwhen the operator moves to another.  A user number is simply a
XMprefix that accesses particular directory entries on the active
Xdisks.

     MThe active user number is maintained until changed by a
XMsubsequent USER command, or until a cold start when user 0 is again
Xassumed.


W1.5  Line Editing and Output Control

     MT&She CCP allows certain line-editing functions while typing
XMcommand lines.  The CTRL-key sequences are obtained by pressing the
XMcontrol and letter keys simultaneously.  Further, CCP command lines
XMare generally up to 255 characters in length; they are not acted
Xupon until the carriage return key is pressed.


=WTable 1-1.  Line-editing Control Characters

	9	F0     &SCharacter                      Meaning

      CTRL-C      MReboots CP/M system when pressed at start of
X                  line.

      CTRL-E      MPhysical end of line; carriage is returned,
X                  Mbut line is not sent until the carriage
X                  return key is pressed.

      CTRL-H      Backspaces one character position.

      CTRL-J      Terminates current input (line feed).

      CTRL-M      MTerminates current input (carriage return).
X
      CTRL-P      MCopies all subsequent console output to the
X                  Mcurrently assigned list device (see Section
X                  M1.6.1).  Output is sent to the list device
X                  Mand the console device until the next CTRL-P
X                  is pressed.

      CTRL-R      MRetypes current command line; types a clean
X                  Mline following character deletion with
X                  rubouts.

      CTRL-S      MStops the console output temporarily.
X                  MProgram execution and output continue when
X                  Myou press any character at the console, for
X                  Mexample another CTRL-S.  This feature stops
X                  Moutput on high speed consoles, such as CRTs,
X                  Min order to view a segment of output before
X                  continuing.



                               1-10



	9	K0

CP/M Operating System Manual 1.5  Line Editing and Output Control


=WTable 1-1.  (continued)

	9	F0     &SCharacter                      Meaning

      CTRL-U      MDeletes the entire line typed at the
X                  console.

      CTRL-X      Same as CTRL-U.

      CTRL-Z      MEnds input from the console (used in PIP and
X                  ED).

      RUB/DEL     MDeletes and echoes the last character typed
X                  at the console.
	9	K0

W1.6  Transient Commands

     MT&Sransient commands are loaded from the currently logged disk
XMand executed in the TPA.  The transient commands for execution under
XMthe CCP are below.  Additional functions are easily defined by the
Xuser (see Section 1.6.3).


=WTable 1-2.  CP/M Transient Commands

	9	F0     &SCommand                      Function

     STAT       MLists the number of bytes of storage remaining
X                Mon the currently logged disk, provides
X                Mstatistical information about particular
X                Mfiles, and displays or alters device
X                assignment.

     ASM        MLoads the CP/M assembler and assembles the
X                specified program from disk.

     LOAD       MLoads the file in Intel HEX machine code
X                Mformat and produces a file in machine
X                Mexecutable form which can be loaded into the
X                MTPA.  This loaded program becomes a new
X                command under the CCP.

     DDT        MLoads the CP/M debugger into TPA and starts
X                execution.

     PIP        MLoads the Peripheral Interchange Program for
X                Msubsequent disk file and peripheral transfer
X                operations.

     ED         MLoads and executes the CP/M text editor
X                program.

     SYSGEN     Creates a new CP/M system disk.



                               1-11



	9	K0

CP/M Operating System Manual              1.6  Transient Commands


=WTable 1-2.  (continued)

	9	F0     &SCommand                      Function

     SUBMIT     MSubmits a file of commands for batch
X                processing.

     DUMP       Dumps the contents of a file in hex.

     MOVCPM     MRegenerates the CP/M system for a particular
X                memory size.

	9	K0
     MTransient commands are specified in the same manner as built-in
XMcommands, and additional commands are easily defined by the user.
XMFor convenience, the transient command can be preceded by a drive
XMname which causes the transient to be loaded from the specified
Xdrive into the TPA for execution.  Thus, the command

        B:STAT

Mcauses CP/M to temporarily log in drive B for the source of the STAT
XMtransient, and then return to the original logged disk for
Xsubsequent processing.


W1.6.1  STAT Command

S&Syntax:

        STAT
        STAT "command line"

     MThe STAT command provides general statistical information about 
XMfile storage and device assignment.  Special forms of the command 
XMline allow the current device assignment to be examined and altered.  
XMThe various command lines Ethat caRn be specified are shown with an
Xexplanation of each form to the right.


        STAT            MIf you type an empty command line, the STAT
X                        Mtransient calculates the storage remaining
X                        Mon all active drives, and prints one of the
X                        following messages:

                        d: R/W, SPACE:  nnnK

                        d: R/O, SPACE:  nnnK

                        Mfor each active drive d:, where R/W
X                        Mindicates the drive can be read or written,
X                        Mand R/O indicates the drive is Read-Only (a
X                        Mdrive becomes R/O by explicitly setting it
X                        Mto Read-Only, as shown below, or by
X                        Minadvertently changing disks without


                               1-M12



X

CP/M Operating System Manual              1.6  Transient Commands


                        Mperforming a warm start).  The space
X                        Mremaining on the disk in drive d: is given
X                        in kilobytes by nnn.

        STAT d:         MIf a drive name is given, then the drive is
X                        Mselected before the storage is computed.
X                        MThus, the command STAT B: could be issued
X                        Mwhile logged into drive A, resulting in the
X                        message

                        BYTES REMAINING ON B:  nnnK

        STAT afn        MThe command line can also specify a set of
X                        Mfiles to be scanned by STAT.  The files
X                        Mthat satisfy afn are listed in alphabetical
X                        Morder, with storage requirements for each
X                        file under the heading:

                        RECS BYTES EXT D:FILENAME.TYP
                        rrrr bbbK ee d:filename.typ

                        Mwhere rrrr is the number of 128-byte
X                        Mrecords allocated to the file, bbb is the
X                        Mnumber of kilobytes allocated to the file
X                        M(bbb=rrrr*128/1024), ee is the number of
X                        M16K extensions (ee=bbb/16), d is the drive
X                        Mname containing the file (A...P), filename
X                        Mis the eight-character primary filename,
X                        Mand typ is the three-character filetype.
X                        MAfter listing the individual files, the
X                        storage usage is summarized.

        STAT d:afn      MThe drive name can be given ahead of the
X                        Mafn.  The specified drive is first
X                        Mselected, and the form STAT afn is
X                        executed.

        STAT d:=R/O     MThis form sets the drive given by d to
X                        MRead-Only, remaining in effect until the
X                        Mnext warm or cold start takes place.  When
X                        a disk is Read-Only, the message

                        BDOS ERR ON d:  Read-Only

                        Mappears if there is an attempt to write to
X                        Mthe Read-Only disk.  CP/M waits until a key
X                        Mis pressed before performing an automatic
X                        Mwarm start, at which time the disk becomes
X                        R/W.








                               1-13





CP/M Operating System Manual              1.6  Transient Commands



     MThe STAT command allows you to control the physical-to-logical
XMdevice assignment.  See the IOBYTE function described in Sections 5
XMand 6.  There are four logical peripheral devices that are, at any
XMparticular instant, each assigned one of several physical peripheral
Xdevices.  The following is a list of the four logical devices:


   o MCON: is the system console device, used by CCP for
X     communication with the operator.

   o RDR: is the paper tape reader device.

   o PUN: is the paper tape punch device.

   o LST: is the output list device.


     MThe actual devices attached to any particular computer system
XMare driven by subroutines in the BIOS portion of CP/M.  Thus, the
XMlogical RDR: device, for example, could actually be a high speed
XMreader, teletype reader, or cassette tape.  To allow some
XMflexibility in device naming and assignment, several physical
Xdevices are defined in Table 1-3.


=WTable 1-3.  Physical Devices
	9	F0
     &SDevice                       Meaning

      TTY:    Teletype device (slow speed console)

      CRT:    Cathode ray tube device (high speed console)

      BAT:    MBatch processing (console is current RDR:,
X              output goes to current LST: device)

      UC1:    User-defined console

      PTR:    Paper tape reader (high speed reader)

      UR1:    User-defined reader #1

      UR2:    User-defined reader #2

      PTP:    Paper tape punch (high speed punch)

      UP1:    User-defined punch #1

      UP2:    User-defined punch #2

      LPT:    Line printer

      UL1:    User-defined list device #1
	9	K0


                               1-14





CP/M Operating System Manual              1.6  Transient Commands



     MIt is emphasized that the physical device names might not
XMactually correspond to devices that the names imply.  That is, you
XMcan implement the PTP: device as a cassette write operation.  The
XMexact correspondence and driving subroutine is defined in the BIOS
XMportion of CP/M.  In the standard distribution version of CP/M,
XMthese devices correspond to their names on the Model 800 development
Xsystem.

     The command,

        STAT VAL:

Mproduces a summary of the available status commands, resulting in
Xthe output:

        Temp R/O Disk d:$R/O
        Set Indicator: filename.typ $R/O $R/W $SYS $DIR
        Disk Status: DSK: d:DSK
        Iobyte Assign:

Mwhich gives an instant summary of the possible STAT commands and
Xshows the permissible logical-to-physical device assignments:

        CON: = TTY: CRT: BAT: UC1:
        RDR: = TTY: PTR: UR1: UR2:
        PUN: = TTY: PTP: UP1: UP2:
        LST: = TTY: CRT: LPT: UL1:

MThe logical device to the left takes any of the four physical
XMassignments shown to the right.  The current logical-to-physical
Xmapping is displayed by typing the command:

        STAT DEV:

MThis command produces a list of each logical device to the left and
XMthe current corresponding physical device to the right.  For
Xexample, the list might appear as follows:

        CON: = CRT:
        RDR: = UR1:
        PUN: = PTP:
        LST: = TTY:

MThe current logical-to-physical device assignment is changed by
Xtyping a STAT command of the form:

        STAT ld1 = pd1, ld2 = pd2, ... , ldn = pdn

Mwhere ld1 through ldn are logical device names and pd1 through pdn
XMare compatible physical device names.  For example, ldi and pdi
XMappear on the same line in the VAL: command shown above.  The
XMfollowing example shows valid STAT commands that change the current
Xlogical-to-physical device assignments:



                               1-15





CP/M Operating System Manual              1.6  Transient Commands


        STAT CON:=CRT:
        STAT PUN:=TTY:, LST:=LPT:, RDR:=TTY:

     The command form,

        STAT d:filename.typ $S

Mwhere d: is an optional drive name and filename.typ is an
XMunambiguous or ambiguous filename, produces the following output
Xdisplay format:


        Size        Recs      Bytes          Ext Acc

           48        48         6K       1 R/O A:ED.COM
           55        55        12K       1 R/O (A:PIP.COM)
        65536       128        16K       2 R/W A:X.DAT


Mwhere the $S parameter causes the Size field to be displayed.
XMWithout the $S, the Size field is skipped, but the remaining fields
XMare displayed.  The Size field lists the virtual file size in
XMrecords, while the Recs field sums the number of virtual records in
XMeach extent.  For files constructed sequentially, the Size and Recs
XMfields are identical.  The Bytes field lists the actual number of
XMbytes allocated to the corresponding file.  The minimum allocation
XMunit is determined at configuration time; thus, the number of bytes
XMcorresponds to the record count plus the remaining unused space in
XMthe last allocated block for sequential files.  Random access files
XMare given data areas only when written, so the Bytes field contains
XMthe only accurate allocation figure.  In the case of random access,
XMthe Size field gives the logical end-of-file record position and the
XMRecs field counts the logical records of each extent.  Each of these
XMextents, however, can contain unallocated holes even though they are
Xadded into the record count.

     MThe Ext field counts the number of physical extents allocated
XMto the file.  The Ext count corresponds to the number of directory
XMentries given to the file.  Depending on allocation size, there can
XMbe up to 128K bytes (8 logical extents) directly addressed by a
XMsingle directory entry.  In a special case, there are actually 256K
Xbytes that can be directly addressed by a physical extent.

     MThe Acc field gives the R/O or R/W file indicator, which you
Xcan change using the commands shown.  The four command forms,

        STAT d:filename.typ $R/O
        STAT d:filename.typ $R/W
        STAT d:filename.typ $SYS
        STAT d:filename.typ $DIR

Mset or reset various permanent file indicators.  The R/O indicator
XMplaces the file, or set of files, in a Read-Only status until
XMchanged by a subsequent STAT command.  The R/O status is recorded in
XMthe directory with the file so that it remains R/O through


                               1-M16



X

CP/M Operating System Manual              1.6  Transient Commands


Mintervening cold start operations.  The R/W indicator places the
XMfile in a permanent Read-Write status.  The SYS indicator attaches
XMthe system indicator to the file, while the DIR command removes the
XMsystem indicator.  The filename.typ may be ambiguous or unambiguous,
XMbut files whose attributes are changed are listed at the console
Xwhen the change occurs.  The drive name denoted by d: is optional.

     MWhen a file is marked R/O, subsequent attempts to erase or
XMwrite into the file produce the following BDOS message at your
Xscreen:

        BDOS Err on d: File R/O

Mlists the drive characteristics of the disk named by d: that is in
XMthe range A:, B:,...,P:.  The drive characteristics are listed in
Xthe following format:

            d: Drive Characteristics
        65536: 128 Byte Record Capacity
         8192: Kilobyte Drive Capacity
          128: 32 Byte Directory Entries
            0: Checked Directory Entries
         1024: Records/Extent
          128: Records/Block
           58: Sectors/Track
            2: Reserved Tracks

Mwhere d: is the selected drive, followed by the total record
XMcapacity (65536 is an eight-megabyte drive), followed by the total
XMcapacity listed in kilobytes.  The directory size is listed next,
XMfollowed by the checked entries.  The number of checked entries is
XMusually identical to the directory size for removable media, because
XMthis mechanism is used to detect changed media during CP/M operation
XMwithout an intervening warm start.  For fixed media, the number is
XMusually zero, because the media are not changed without at least a
Xcold or warm start.

     MThe number of records per extent determines the addressing
XMcapacity of each directory entry (1024 times 128 bytes, or 128K in
XMthe previous example).  The number of records per block shows the
XMbasic allocation size (in the example, 128 records/block times 128
XMbytes per record, or 16K bytes per block).  The listing is then
XMfollowed by the number of physical sectors per track and the number
Xof reserved tracks.

     MFor logical drives that share the same physical disk, the
XMnumber of reserved tracks can be quite large because this mechanism
XMis used to skip lower-numbered disk areas allocated to other logical
Xdisks.  The command form

        STAT DSK:

Mproduces a drive characteristics table for all currently active
Xdrives.  The final STAT command form is



                               1-17





CP/M Operating System Manual              1.6  Transient Commands


        STAT USR:

Mwhich produces a list of the user numbers that have files on the
Xcurrently addressed disk.  The display format is

        Active User:   0
        Active Files:  0 1 3

Mwhere the first line lists the currently addressed user number, as
XMset by the last CCP USER command, followed by a list of user numbers
XMscanned from the current directory. In this case, the active user
XMnumber is 0 (default at cold start) with three user numbers that
XMhave active files on the current disk.  The operator can
XMsubsequently examine the directories of the other user numbers by
XMlogging in with USER 1 or USER 3 commands, followed by a DIR command
Xat the CCP level.


W1.6.2  ASM Command

S&Syntax:

        ASM ufn

     MThe ASM command loads and executes the CP/M 8080 assembler.
XMThe ufn specifies a source file containing assembly language
XMstatements, where the filetype is assumed to be ASM and is not
Xspecified.  The following ASM commands are valid:

        ASM X
        ASM GAMMA

MThe two-pass assembler is automatically executed.  Assembly errors
Xthat occur during the second pass are printed at the console.

     The assembler produces a file:

        X.PRN

Mwhere X is the primary name specified in the ASM command.  The PRN
XMfile contains a listing of the source program with embedded tab
XMcharacters if present in the source program, along with the machine
XMcode generated for each statement and diagnostic error messages, if
XMany.  The PRN file is listed at the console using the TYPE command,
XMor sent to a peripheral device using PIP (see Section 1.6.4).  Note
XMthat the PRN file contains the original source program, augmented by
XMmiscellaneous assembly information in the leftmost 16 columns; for
XMexample, program addresses and hexadecimal machine code.  The PRN
XMfile serves as a backup for the original source file.  If the source
XMfile is accidentally removed or destroyed, the PRN file can be
XMedited by removing the leftmost 16 characters of each line (see
XMSection 2).  This is done by issuing a single editor macro command.
XMThe resulting file is identical to the original source file and can
XMbe renamed from PRN to ASM for subsequent editing and assembly.  The
Xfile


                               1-18





CP/M Operating System Manual              1.6  Transient Commands



        X.HEX

Mis also produced, which contains 8080 machine language in Intel HEX
XMformat suitable for subsequent loading and execution (see Section
XM1.6.3).  For complete details of CP/M's assembly language program,
Xsee Section 3.

     MThe source file for assembly is taken from an alternate disk by
XMprefixing the assembly language filename by a disk drive name.  The
Xcommand

        ASM B:ALPHA

Mloads the assembler from the currently logged drive and processes
XMthe source program ALPHA.ASM on drive B.  The HEX and PRN files are
Xalso placed on drive B in this case.


W1.6.3  LOAD Command

S&Syntax:

        LOAD ufn

     MThe LOAD command reads the file ufn, which is assumed to
XMcontain HEX format machine code, and produces a memory image file
XMthat can subsequently be executed.  The filename ufn is assumed to
Xbe of the form:

        X.HEX

Mand only the filename X need be specified in the command.  The LOAD
Xcommand creates a file named

        X.COM

Mthat marks it as containing machine executable code.  The file is
XMactually loaded into memory and executed when the user types the
XMfilename X immediately after the prompting character > printed by
Xthe CCP.

     MGenerally, the CCP reads the filename X following the prompting
XMcharacter and looks for a built-in function name.  If no function
XMname is found, the CCP searches the system disk directory for a file
Xby the name

        X.COM

MIf found, the machine code is loaded into the TPA, and the program
XMexecutes.  Thus, the user need only LOAD a hex file once; it can be
XMsubsequently executed any number of times by typing the primary
XMname.  This way, you can invent new commands in the CCP.
XMInitialized disks contain the transient commands as COM files, which
XMare optionally deleted.  The operation takes place on an alternate
Xdrive if the filename is prefixed by a drive name.  Thus,

                               1-19





CP/M Operating System Manual              1.6  Transient Commands



        LOAD B:BETA

Mbrings the LOAD program into the TPA from the currently logged disk
Xand operates on drive B after execution begins.

MWNote:  &Sthe BETA.HEX file must contain valid Intel format hexadecimal
XMmachine code records (as produced by the ASM program, for example)
XMthat begin at 100H of the TPA.  The addresses in the hex records
XMmust be in ascending order; gaps in unfilled memory regions are
XMfilled with zeroes by the LOAD command as the hex records are read.
XMThus, LOAD must be used only for creating CP/M standard COM files
XMthat operate in the TPA.  Programs that occupy regions of memory
Xother than the TPA are loaded under DDT.


W1.6.4  PIP

S&Syntax:

        PIP
        PIP destination=source#1, source#2, ..., source #n

     MPIP is the CP/M Peripheral Interchange Program that implements 
XMthe basic media conversion operations necessary to load, print, 
XMpunch, copy, and combine disk files.  The PIP program is initiated 
XbyE typingR one of the following forms:

        PIP
        PIP command line

MIn both cases PIP is loaded into the TPA and executed.  In the first
XMform, PIP reads command lines directly from the console, prompted
XMwith the * character, until an empty command line is typed (for
XMexample, a single carriage return is issued by the operator).  Each
XMsuccessive command line causes some media conversion to take place
Xaccording to the rules shown below.

     MIn the second form, the PIP command is equivalent to the first,
XMexcept that the single command line given with the PIP command is
XMautomatically executed, and PIP terminates immediately with no
XMfurther prompting of the console for input command lines.  The form
Xof each command line is

        destination = source#1, source#2, ..., source#n

Mwhere destination is the file or peripheral device to receive the
XMdata, and source#1, ..., source#n is a series of one or more files
Xor devices that are copied from left to right to the destination.

     MWhen multiple files are given in the command line (for example,
XMn>1), the individual files are assumed to contain ASCII characters,
XMwith an assumed CP/M end-of-file character (CTRL-Z) at the end of
XMeach file (see the O parameter to override this assumption).  Lower-
XMcase ASCII alphabetics are internally translated to upper-case to be


                               1-M20



X

CP/M Operating System Manual              1.6  Transient Commands


Mconsistent with CP/M file and device name conventions.  Finally, the
XMtotal command line length cannot exceed 255 characters.  CTRL-E can
XMbe used to force a physical carriage return for lines that exceed
Xthe console width.

     MThe destination and source elements are unambiguous references
XMto CP/M source files with or without a preceding disk drive name.
XMThat is, any file can be referenced with a preceding drive name (A:
XMthrough P:) that defines the particular drive where the file can be
XMobtained or stored.  When the drive name is not included, the
XMcurrently logged disk is assumed.  The destination file can also
XMappear as one or more of the source files, in which case the source
XMfile is not altered until the entire concatenation is complete.  If
XMit already exists, the destination file is removed if the command
XMline is properly formed.  It is not removed if an error condition
XMarises.  The following command lines, with explanations to the
Xright, are valid as input to PIP:


        X=Y                    MCopies to file X from file Y, where
X                               MX and Y are unambiguous filenames;
X                               Y remains unchanged.

        X=Y,Z                  MConcatenates files Y and z and
X                               Mcopies to file X, with Y and Z
X                               unchanged.

        X.ASM=Y.ASM,Z.ASM      MCreates the file X.ASM from the
X                               Mconcatenation of the Y and Z.ASM
X                               files.

        NEW.ZOT=B:OLD.ZAP      MMoves a copy of OLD.ZAPP from drive
X                               MB to the currently logged disk;
X                               names the file NEW.ZOT.

        B:A.U=B:B.V,A:C.W,D.X  MConcatenates file B.V from drive B
X                               Mwith C.W from drive a and D.X from
X                               Mthe logged disk; creates the file
X                               A.U on drive b.


     MFor convenience, PIP allows abbreviated commands for
XMtransferring files between disk drives.  The abbreviated PIP forms
Xare

        PIP d:=afn
        PIP dU1D=dU2D:afn
        PIP ufn = dU2D:
        PIP dU1D:ufn = dU2D:

MThe first form copies all files from the currently logged disk that
XMsatisfy the afn to the same files on drive d, where d = A...P.  The
XMsecond form is equivalent to the first, where the source for the
XMcopy is drive dU2D, where dU2D = A...P.  The third form is equivalent to
XMthe command PIP dU1D:ufn=dU2D:ufn which copies the file given by ufn


                               1-M21



X

CP/M Operating System Manual              1.6  Transient Commands


Mfrom drive dU2D to the file ufn on drive dU1D:.  The fourth form is
XMequivalent to the third, where the source disk is explicitly given 
Xby dU2D:.

     MThe source and destination disks must be different in all of
XMthese cases.  If an afn is specified, PIP lists each ufn that
XMsatisfies the afn as it is being copied.  If a file exists by the
XMsame name as the destination file, it is removed after successful
Xcompletion of the copy and replaced by the copied file.

     MThe following PIP commands give examples of valid disk-to-disk
Xcopy operations:


        B:=*.COM        MCopies all files that have the secondary
X                        Mname COM to drive B from the current drive.
X
        A:=B:ZAP.*      MCopies all files that have the primary name
X                        ZAP to drive A from drive B.

        ZAP.ASM=B:      Same as ZAP.ASM=B:ZAP.ASM

        B:ZOT.COM=A:    Same as B:ZOT.COM=A:ZOT.COM

        B:=GAMMA.BAS    Same as B:GAMMA.BAS=GAMMA.BAS

        B:=A:GAMMA.BAS  Same as B:GAMMA.BAS=A:GAMMA.BAS


     MPIP allows reference to physical and logical devices that are
XMattached to the CP/M system.  The device names are the same as given
XMunder the STAT command, along with a number of specially named
XMdevices.  The following is a list of logical devices given in the
XSTAT command

        CON: (console)
        RDR: (reader)
        PUN: (punch)
        LST: (list)

while the physical devices are

        TTY: (console), reader, punch, or list)
        CRT: (console, or list), UC1: (console)
        PTR: (reader), UR1: (reader), UR2: (reader)
        PTP: (punch), UP1: (punch), UP2: (punch)
        LPT: (list), UL1: (list)

MThe BAT: physical device is not included, because this assignment is
XMused only to indicate that the RDR: and LST: devices are used for
Xconsole input/output.

     MThe RDR, LST, PUN, and CON devices are all defined within the
XMBIOS portion of CP/M, and are easily altered for any particular I/O
XMsystem.  The current physical device mapping is defined by IOBYTE;


                               1-M22



X

CP/M Operating System Manual              1.6  Transient Commands


Msee Section 6 for a discussion of this function.  The destination
XMdevice must be capable of receiving data, for example, data cannot
XMbe sent to the punch, and the source devices must be capable of
Xgenerating data, for example, the LST: device cannot be read.

     MThe following list describes additional device names that can
Xbe used in PIP commands.


   o MNUL: sends 40 nulls (ASCII 0s) to the device.  This can be
X     issued at the end of punched output.

   o MEOF: sends a CP/M end-of-file (ASCII CTRL-Z) to the destination
X     Mdevice (sent automatically at the end of all ASCII data
X     transfers through PIP).

   o MINP: is a special PIP input source that can be patched into the
X     MPIP program.  PIP gets the input data character-by-character,
X     Mby CALLing location 103H, with data returned in location 109H
X     (parity bit must be zero).

   o MOUT: is a special PIP output destination that can be patched
X     Minto the PIP program.  PIP CALLs location 106H with data in
X     Mregister C for each character to transmit.  Note that locations
X     M109H through 1FFH of the PIP memory image are not used and can
X     Mbe replaced by special purpose drivers using DDT (see Section
X     4).

   o MPRN: is the same as LST:, except that tabs are expanded at
X     Mevery eighth character position, lines are numbered, and page
X     Mejects are inserted every 60 lines with an initial eject (same
X     as using PIP options [t8np]).


     MFile and device names can be interspersed in the PIP commands.
XMIn each case, the specific device is read until end-of-file (CTRL-Z
XMfor ASCII files, and end-of-data for non-ASCII disk files).  Data
XMfrom each device or file are concatenated from left to right until
Xthe last data source has been read.

     MThe destination device or file is written using the data from
XMthe source files, and an end-of-file character, CTRL-Z, is appended
XMto the result for ASCII files.  If the destination is a disk file, a
XMtemporary file is created ($$$ secondary name) that is changed to
XMthe actual filename only on successful completion of the copy.
XFiles with the extension COM are always assumed to be non-ASCII.

     MThe copy operation can be aborted at any time by pressing any
XMkey on the keyboard.  PIP responds with the message ABORTED to
XMindicate that the operation has not been completed.  If any
XMoperation is aborted, or if an error occurs during processing, PIP
XMremoves any pending commands that were set up while using the SUBMIT
Xcommand.




                               1-23





CP/M Operating System Manual              1.6  Transient Commands


     MPIP performs a special function if the destination is a disk
XMfile with type HEX (an Intel hex-formatted machine code file), and
XMthe source is an external peripheral device, such as a paper tape
XMreader.  In this case, the PIP program checks to ensure that the
XMsource file contains a properly formed hex file, with legal
Xhexadecimal values and checksum records.

     MWhen an invalid input record is found, PIP reports an error
XMmessage at the console and waits for corrective action.  Usually,
XMyou can open the reader and rerun a section of the tape (pull the
XMtape back about 20 inches).  When the tape is ready for the reread,
XMa single carriage return is typed at the console, and PIP attempts
XManother read.  If the tape position cannot be properly read,
XMcontinue the read by typing a return following the error message,
XMand enter the record manually with the ED program after the disk
Xfile is constructed.

     MPIP allows the end-of-file to be entered from the console if
XMthe source file is an RDR: device.  In this case, the PIP program
XMreads the device and monitors the keyboard.  If CTRL-Z is typed at
Xthe keyboard, the read operation is terminated normally.

     The following are valid PIP commands:


        PIP LST: = X.PRN

                        MCopies X.PRN to the LST device and
X                        terminates the PIP program.

        PIP

                        MStarts PIP for a sequence of commands.  PIP
X                        prompts with *.

        *CON:=X.ASM,Y.ASM,Z.ASM

                        MConcatenates three ASM files and copies to
X                        the CON device.

        *X.HEX=CON:,Y.HEX,PTR:

                        MCreates a HEX file by reading the CON until
X                        Ma CTRL-Z is typed, followed by data from
X                        MY.HEX and PTR until a CTRL-Z is
X                        encountered.

        PIP PUN:=NUL:,X.ASM,EOF:,NUL:

                        MSends 40 nulls to the punch device; copies
X                        Mthe X.ASM file to the punch, followed by an
X                        Mend-of-file, CTRL-Z, and 40 more null
X                        characters.

        (carriage return)

                        A single carriage return stops PIP.

                               1-24




CP/M Operating System Manual              1.6  Transient Commands



     MYou can also specify one or more PIP parameters, enclosed in
XMleft and right square brackets, separated by zero or more blanks.
XMEach parameter affects the copy operation, and the enclosed list of
XMparameters must immediately follow the affected file or device.
XMGenerally, each parameter can be followed by an optional decimal
XMinteger value (the S and Q parameters are exceptions).  Table 1-4
Xdescribes valid PIP parameters.


=WTable 1-4.  PIP Parameters
	9	F0
     Parameter                      Meaning

       B         MBlocks mode transfer.  Data are buffered by
X                 MPIP until an ASCII x-off character, CTRL-S,
X                 Mis received from the source device.  This
X                 Mallows transfer of data to a disk file from a
X                 Mcontinuous reading device, such as a cassette
X                 Mreader.  Upon receipt of the x-off, PIP
X                 Mclears the disk buffers and returns for more
X                 Minput data.  The amount of data that can be
X                 Mbuffered depends on the memory size of the
X                 Mhost system.  PIP issues an error message if
X                 the buffers overflow.

       Dn        MDeletes characters that extend past column n
X                 Min the transfer of data to the destination
X                 Mfrom the character source.  This parameter is
X                 Mgenerally used to truncate long lines that
X                 Mare sent to a narrow printer or console
X                 device.

       E         MEchoes all transfer operations to the console
X                 as they are being performed.

       F         MFilters form-feeds from the file.  All
X                 Membedded form-feeds are removed.  The P
X                 Mparameter can be used simultaneously to
X                 insert new form-feeds.

       Gn        MGets file from user number n (n in the range
X                 0-15).

       H         MTransfers HEX data.  All data are checked for
X                 Mproper Intel hex file format.  Nonessential
X                 Mcharacters between hex records are removed
X                 Mduring the copy operation.  The console is
X                 Mprompted for corrective action in case errors
X                 occur.

       I         MIgnores :00 records in the transfer of Intel
X                 Mhex format file.  The I parameter
X                 automatically sets the H parameter.



                               1-25



	9	K0

CP/M Operating System Manual              1.6  Transient Commands


=WTable 1-4.  (continued)
	9	F0
     Parameter                      Meaning

       L         MTranslates upper-case alphabetics to lower-
X                 case.

       N         MAdds line numbers to each line transferred to
X                 Mthe destination, starting at one and
X                 Mincrementing by 1.  Leading zeroes are
X                 Msuppressed, and the number is followed by a
X                 Mcolon.  If N2 is specified, leading zeroes
X                 Mare included and a tab is inserted following
X                 Mthe number.  The tab is expanded if T is set.
X
       O         MTransfers non-ASCII object files.  The normal
X                 CP/M end-of-file is ignored.

       Pn        MIncludes page ejects at every n lines with an
X                 Minitial page eject.  If n = 1 or is excluded
X                 Maltogether, page ejects occur every 60 lines.
X                 MIf the F parameter is used, form-feed
X                 Msuppression takes place before the new page
X                 ejects are inserted.

       Qs^Z      MQuits copying from the source device or file
X                 Mwhen the string s, terminated by CTRL-Z, is
X                 encountered.

       R         Reads system files.

       Ss^Z      MStart copying from the source device when the
X                 Mstring s, terminated by CTRL-Z, is
X                 Mencountered.  The S and Q parameters can be
X                 Mused to abstract a particular section of a
X                 Mfile, such as a subroutine.  The start and
X                 Mquit strings are always included in the copy
X                 operation.

                 MIf you specify a command line after the PIP
X                 Mcommand keyword, the CCP translates strings
X                 Mfollowing the S and Q parameters to upper-
X                 Mcase.  If you do not specify a command line,
X                 MPIP does not perform the automatic upper-case
X                 translation.

       Tn        MExpands tabs, CTRL-I characters, to every nth
X                 Mcolumn during the transfer of characters to
X                 the destination from the source.

       U         MTranslates lower-case alphabetics to upper-
X                 case during the copy operation.





                               1-26



	9	K0

CP/M Operating System Manual              1.6  Transient Commands


=WTable 1-4.  (continued)
	9	F0
     Parameter                      Meaning

       V         MVerifies that data have been copied correctly
X                 Mby rereading after the write operation (the
X                 destination must be a disk file).

       W         MWrites over R/O files without console
X                 interrogation.

       Z         MZeros the parity bit on input for each ASCII
X                 character.
	9	K0

     MThe following examples show valid PIP commands that specify
Xparameters in the file transfer.


        PIP X.ASM=B:[v]

                        MCopies X.ASM from drive B to the current
X                        Mdrive and verifies that the data were
X                        properly copied.


        PIP LPT:=X.ASM[nt8u]

                        MCopies X.ASM to the LPT: device; numbers
X                        Meach line, expands tabs to every eighth
X                        Mcolumn, and translates lower-case
X                        alphabetics to upper-case.


        PIP PUN:=X.HEX[i],Y.ZOT[h]

                        MFirst copies X.HEX to the PUN: device and
X                        Mignores the trailing :00 record in X.HEX;
X                        Mcontinues the transfer of data by reading
X                        MY.ZOT, which contains HEX records,
X                        including any :00 records it contains.


        PIP X.LIB=Y.ASM[sSUBRI:^z qJMP L3^z]

                        MCopies from the file Y.ASM into the file
X                        MX.LIB.  The command starts the copy when
X                        Mthe string SUBR1: has been found, and quits
X                        Mcopying after the string JMP L3 is
X                        encountered.







                               1-27





CP/M Operating System Manual              1.6  Transient Commands


        PIP PRN:=X.ASM[p50]

                        MSends X.ASM to the LST: device with line
X                        Mnumbers, expands tabs to every eighth
X                        Mcolumn, and ejects pages at every 50th
X                        Mline.  The assumed parameter list for a PRN
X                        Mfile is nt8p60; p50 overrides the default
X                        value.


     MUnder normal operation, PIP does not overwrite a file that is
XMset to a permanent R/O status.  If an attempt is made to overwrite
Xan R/O file, the following prompt appears:

        DESTINATION FILE IS R/O, DELETE (Y/N)?

MIf you type Y, the file is overwritten.  Otherwise, the following
Xresponse appears:

        ** NOT DELETED **

MThe file transfer is skipped, and PIP continues with the next
XMoperation in sequence.  To avoid the prompt and response in the case
XMof R/O file overwrite, the command line can include the W parameter,
Xas shown in this example:

        PIP A:=B:*.COM[W]

MThe W parameter copies all nonsystem files to the A drive from the B
XMdrive and overwrites any R/O files in the process.  If the operation
XMinvolves several concatenated files, the W parameter need only be
Xincluded with the last file in the list, as in this example:

        PIP A.DAT=B.DAT,F:NEW.DAT,G:OLD.DAT[W]

     MFiles with the system attribute can be included in PIP
XMtransfers if the R parameter is included; otherwise, system files
Xare not recognized.  For example, the command line:

        PIP ED.COM=B:ED.COM[R]

Mreads the ED.COM file from the B drive, even if it has been marked
XMas an R/O and system file.  The system file attributes are copied,
Xif present.

     MDownward compatibility with previous versions of CP/M is only
XMmaintained if the file does not exceed one megabyte, no file
XMattributes are set, and the file is created by user 0.  If
XMcompatibility is required with nonstandard, for example, double-
XMdensity versions of 1.4, it might be necessary to select 1.4
XMcompatibility mode when constructing the internal disk parameter
XMblock.  See Section 6 and refer to Section 6.10, which describes
XBIOS differences.




                               1-28





CP/M Operating System Manual              1.6  Transient Commands


MWNote:  &Sto copy files into another user area, PIP.COM must be located
XMin that user area.  Use the following procedure to make a copy of
XPIP.COM in another user area.


        USER 0                            Log in user 0.

        DDT PIP.COM (note PIP size s)     Load PIP to memory.

        GO                                Return to CCP.

        USER 3                            Log in user 3.

        SAVEs PIP.COM


MIn this procedure, s is the integral number of memory pages, 256-
XMbyte segments, occupied by PIP.  The number s can be determined when
XMPIP.COM is loaded under DDT, by referring to the value under the
XMNEXT display.  If, for example, the next available address is 1D00,
XMthen PIP.COM requires 1C hexadecimal pages, or 1 times 16 + 12 = 28
XMpages, and the value of s is 28 in the subsequent save.  Once PIP is
XMcopied in this manner, it can be copied to another disk belonging to
Xthe same user number through normal PIP transfers.


W1.6.5  ED Command

S&Syntax:

        ED ufn

     MThe ED program is the CP/M system context editor that allows 
XMcreation and alteration of ASCII files in the CP/M environment.  
XMComplete details of operation are given in Section 2.  ED allows the 
XMoperator to create and operate upon source filesE that aRre organized
XMas a sequence of ASCII characters, separated by end-of-line
XMcharacters (a carriage return/line-feed sequence).  There is no
XMpractical restriction on line length (no single line can exceed the
XMsize of the working memory) that is defined by the number of
Xcharacters typed between carriage returns.

     MThe ED program has a number of commands for character string
XMsearching, replacement, and insertion that are useful for creating
XMand correcting programs or text files under CP/M.  Although the CP/M
XMhas a limited memory work space area (approximately 5000 characters
XMin a 20K CP/M system), the file size that can be edited is not
Xlimited, since data are easily paged through this work area.

     MIf it does not exist, ED creates the specified source file and
XMopens the file for access.  If the source file does exist, the
XMprogrammer appends data for editing (see the A command).  The
XMappended data can then be displayed, altered, and written from the
XMwork area back to the disk (see the W command).  Particular points
XMin the program can be automatically paged and located by context,


                               1-M29



X

CP/M Operating System Manual              1.6  Transient Commands


Mallowing easy access to particular portions of a large file (see the
XN command).

     If you type the following command line:

        ED X.ASM

the ED program creates an intermediate work file with the name

        X.$$$

Mto hold the edited data during the ED run.  Upon completion of ED,
XMthe X.ASM file (original file) is renamed to X.BAK, and the edited
XMwork file is renamed to X.ASM.  Thus, the X.BAK file contains the
XMoriginal unedited file, and the X.ASM file contains the newly edited
XMfile.  The operator can always return to the previous version of a
XMfile by removing the most recent version and renaming the previous
XMversion.  If the current X.ASM file has been improperly edited, the
Xfollowing sequence of commands reclaim the back-up file.


        DIR X.*               Checks to see that BAK file is
                              available.

        ERA X.ASM             Erases most recent version.

        REN X.ASM=X.BAK       Renames the BAK file to ASM.


MYou can abort the edit at any point (reboot, power failure, CTRL-C,
XMor CTRL-Q command) without destroying the original file.  In this
XMcase, the BAK file is not created and the original file is always
Xintact.

     MThe ED program allows the user to edit the source on one disk
XMand create the back-up file on another disk.  This form of the ED
Xcommand is

        ED ufn d:

Mwhere ufn is the name of the file to edit on the currently logged
XMdisk and d is the name of an alternate drive.  The ED program reads
XMand processes the source file and writes the new file to drive d
XMusing the name ufn.  After processing, the original file becomes the
XMback-up file.  If the operator is addressing disk A, the following
Xcommand is valid.

        ED X.ASM b:

MThis edits the file X.ASM on drive A, creating the new file X.$$$ on
XMdrive B.  After a successful edit, A:X.ASM is renamed to A:X.BAK,
XMand B:X.$$$ is renamed to B:X.ASM.  For convenience, the currently
XMlogged disk becomes drive B at the end of the edit.  Note that if a
XMfile named B:X.ASM exists before the editing begins, the following
Xmessage appears on the screen:


                               1-30





CP/M Operating System Manual              1.6  Transient Commands



        FILE EXISTS

MThis message is a precaution against accidentally destroying a
XMsource file.  You should first erase the existing file and then
Xrestart the edit operation.

     MSimilar to other transient commands, editing can take place on
XMa drive different from the currently logged disk by preceding the
XMsource filename by a drive name.  The following are examples of
Xvalid edit requests:


        ED A:X.ASM       MEdits the file X.ASM on drive A, with new
X                         file and back-up on drive A.

        ED B:X.ASM A:    MEdits the file X.ASM on drive B to the
X                         Mtemporary file X.$$$ on drive A.  After
X                         Mediting, this command changes X.ASM on
X                         Mdrive B to X.BAK and changes X.$$$ on
X                         drive A to X.ASM.


W1.6.6  SYSGEN Command

S&Syntax:

        SYSGEN

     MThe SYSGEN transient command allows generation of an
XMinitialized disk containing the CP/M operating system.  The SYSGEN
Xprogram prompts the console for commands by interacting as shown.


        SYSGEN <cr>

                        Initiates the SYSGEN program.


        SYSGEN VERSION x.x

                        SYSGEN sign-on message.


        SOURCE DRIVE NAME
        (OR RETURN TO SKIP)

                        MRespond  with  the  drive name (one of the
X                        Mletters A, B, C, or D) of the disk
X                        Mcontaining a CP/M system, usually A.  If a
X                        Mcopy of CP/M already exists in memory due
X                        Mto a MOVCPM command, press only a carriage
X                        Mreturn.  Typing a drive name d causes the
X                        response:



                               1-31





CP/M Operating System Manual              1.6  Transient Commands


        SOURCE ON d THEN TYPE RETURN

                        MPlace a disk containing the CP/M operating
X                        Msystem on drive d (d is one of A, B, C, or
X                        MD).  Answer by pressing a carriage return
X                        when ready.


        FUNCTION COMPLETE

                        MSystem is copied to memory.  SYSGEN then
X                        prompts with the following:


        DESTINATION DRIVE NAME
        (OR RETURN TO REBOOT)

                        MIf a  disk is  being initialized, place the
X                        Mnew disk into a drive and answer with the
X                        Mdrive name.  Otherwise, press a carriage
X                        Mreturn and the system reboots from drive A.
X                        MTyping drive name d causes SYSGEN to prompt
X                        with the following message:


        DESTINATION ON d
        THEN TYPE RETURN

                        MPlace new  disk into drive d; press return
X                        when ready.


        FUNCTION COMPLETE

                        New disk is initialized in drive d.


MThe DESTINATION prompt is repeated until a single carriage return is
XMpressed at the console, so that more than one disk can be
Xinitialized.

     MUpon completion of a successful system generation, the new disk
XMcontains the operating system, and only the built-in commands are
XMavailable.  An IBM-compatible disk appears to CP/M as a disk with an
XMempty directory; therefore, the operator must copy the appropriate
XMCOM files from an existing CP/M disk to the newly constructed disk
Xusing the PIP transient.

     MYou can copy all files from an existing disk by typing the
Xfollowing PIP command:

        PIP B: = A:*.*[v]





                               1-32





CP/M Operating System Manual              1.6  Transient Commands


MThis command copies all files from disk drive A to disk drive B and
XMverifies that each file has been copied correctly.  The name of each
Xfile is displayed at the console as the copy operation proceeds.

     MNote that a SYSGEN does not destroy the files that already
XMexist on a disk; it only constructs a new operating system.  If a
XMdisk is being used only on drives B through P and will never be the
XMsource of a bootstrap operation on drive A, the SYSGEN need not take
Xplace.


W1.6.7  SUBMIT Command

ESyntax:R

        RSUBMIT ufn parm#1 ... parm#n

     MThe SUBMIT command allows CP/M commands to be batched for
XMautomatic processing.  The ufn given in the SUBMIT command must be
XMthe filename of a file that exists on the currently logged disk,
XMwith an assumed file type of SUB.  The SUB file contains CP/M
XMprototype commands with possible parameter substitution.  The actual
XMparameters parm#1 ... parm#n are substituted into the prototype
XMcommands, and, if no errors occur, the file of substituted commands
Xare processed sequentially by CP/M.

     MThe prototype command file is created using the ED program,
Xwith interspersed $ parameters of the form:

        $1 $2 $3 ...$n

Mcorresponding to the number of actual parameters that will be
XMincluded when the file is submitted for execution.  When the SUBMIT
XMtransient is executed, the actual parameters parm#1 ... parm#n are
XMpaired with the formal parameters $1 ... $n in the prototype
XMcommands.  If the numbers of formal and actual parameters do not
XMcorrespond, the SUBMIT function is aborted with an error message at
XMthe console.  The SUBMIT function creates a file of substituted
Xcommands with the name

        $$$.SUB

Mon the logged disk.  When the system reboots, at the termination of
XMthe SUBMIT, this command file is read by the CCP as a source of
XMinput rather than the console.  If the SUBMIT function is performed
XMon any disk other than drive A, the commands are not processed until
XMthe disk is inserted into drive A and the system reboots.  You can
XMabort command processing at any time by pressing the rubout key when
XMthe command is read and echoed.  In this case, the $$$.SUB file is
XMremoved and the subsequent commands come from the console.  Command
XMprocessing is also aborted if the CCP detects an error in any of the
XMcommands.  Programs that execute under CP/M can abort processing of
XMcommand files when error conditions occur by erasing any existing
X$$$.SUB file.



                               1-33





CP/M Operating System Manual              1.6  Transient Commands


     MTo introduce dollar signs into a SUBMIT file, you can type a $$
XMwhich reduces to a single $ within the command file.  A caret, ^,
XMprecedes an alphabetic character s, which produces a single CTRL-X
Xcharacter within the file.

     MThe last command in a SUB file can initiate another SUB file,
Xallowing chained batch commands:

     MSuppose the file ASMBL.SUB exists on disk and contains the
Xprototype commands

        ASM $1
        DIR $1.*
        ERA *.BAK
        PIP $2:=$1.PRN
        ERA $1.PRN

then, you issue the following command:

        SUBMIT ASMBL X PRN

MThe SUBMIT program reads the ASMBL.SUB file, substituting X: for all
XMoccurrences of $1 and PRN for all occurrences of $2.  This results
Xin a $$$.SUB file containing the commands:

        ASM X
        DIR X.*
        ERA *.BAK
        PIP PRN:=X.PRN
        ERA X.PRN

which are executed in sequence by the CCP.

     MThe SUBMIT function can access a SUB file on an alternate drive
XMby preceding the filename by a drive name.  Submitted files are only
XMacted upon when they appear on drive A.  Thus, it is possible to
XMcreate a submitted file on drive B that is executed at a later time
Xwhen inserted in drive A.

     MAn additional utility program called XSUB extends the power of
XMthe SUBMIT facility to include line input to programs as well as the
XMCCP.  The XSUB command is included as the first line of the SUBMIT
XMfile.  When it is executed, XSUB self-relocates directly below the
XMCCP.  All subsequent SUBMIT command lines are processed by XSUB so
XMthat programs that read buffered console input, BDOS Function 10,
XMreceive their input directly from the SUBMIT file.  For example, the
Xfile SAVER.SUB can contain the following SUBMIT lines:

        XSUB
        DDT
        |$1.COM
        R
        GO
        SAVE 1 $2.COM



                               1-34





CP/M Operating System Manual              1.6  Transient Commands


a subsequent SUBMIT command, such as

        A>WSUBMIT SAVER PIP Y

Ms&Substitutes X for $1 and Y for $2 in the command stream.  The XSUB
XMprogram loads, followed by DDT, which is sent to the command lines
XMPIP.COM, R, and G0, thus returning to the CCP.  The final command
XSAVE 1 Y.COM is processed by the CCP.

     The XSUB program remains in memory and prints the message

        (xsub active)

Mon each warm start operation to indicate its presence.  Subsequent
XMSUBMIT command streams do not require the XSUB, unless an
XMintervening cold start occurs.  Note that XSUB must be loaded after
XMthe optional CP/M DESPOOL utility, if both are to run
Xsimultaneously.


W1.6.8  DUMP Command

ESyntax:R

        RDUMP ufn

     MThe DUMP program types the contents of the disk file (ufn) at
XMthe console in hexadecimal form.  The file contents are listed
XMsixteen bytes at a time, with the absolute byte address listed to
XMthe left of each line in hexadecimal.  Long typeouts can be aborted
XMby pressing the rubout key during printout.  The source listing of
XMthe DUMP program is given in Section 5 as an example of a program
Xwritten for the CP/M environment.


W1.6.9  MOVCPM Command

ESyntax:R

        RMOVCPM

     MThe MOVCPM program allows you to reconfigure the CP/M system
XMfor any particular memory size.  Two optional parameters can be used
XMto indicate the desired size of the new system and the disposition
XMof the new system at program termination.  If the first parameter is
XMomitted or an * is given, the MOVCPM program reconfigures the system
XMto its maximum size, based upon the kilobytes of contiguous RAM in
XMthe host system (starting at 0000H).  If the second parameter is
XMomitted, the system is executed, but not permanently recorded; if *
XMis given, the system is left in memory, ready for a SYSGEN
XMoperation.  The MOVCPM program relocates a memory image of CP/M and
XMplaces this image in memory in preparation for a system generation
Xoperation.  The following is a list of MOVCPM command forms:




                               1-35





CP/M Operating System Manual              1.6  Transient Commands


        MOVCPM         MRelocates and executes CP/M for management
X                       Mof the current memory configuration (memory
X                       Mis examined for contiguous RAM, starting at
X                       M100H).  On completion of the relocation, the
X                       Mnew system is executed but not permanently
X                       Mrecorded on the disk.  The system that is
X                       Mconstructed contains a BIOS for the Intel
X                       microcomputer development system 800.

        MOVCPM  n      MCreates a relocated CP/M system for
X                       Mmanagement of an n kilobyte system (n must
X                       Mbe in the range of 20 to 64), and executes
X                       the system as described.

        MOVCPM  * *    MConstructs a relocated memory image for the
X                       Mcurrent memory configuration, but leaves the
X                       Mmemory image in memory in preparation for a
X                       SYSGEN operation.

        MOVCPM  n *    MConstructs a relocated memory image for an n
X                       Mkilobyte memory system, and leaves the
X                       Mmemory image in preparation for a SYSGEN
X                       operation.


     For example, the command,

        MOVCPM  * *

Mconstructs a new version of the CP/M system and leaves it in memory,
Xready for a SYSGEN operation.  The message

        READY FOR 'SYSGEN' OR
        'SAVE 34 CPMxx.COM'

Mappears at the console upon completion, where xx is the current
XMmemory size in kilobytes.  You can then type the following sequence:
X

        SYSGEN                     MThis starts the system
X                                   generation.

        SOURCE DRIVE NAME          Respond with a carriage return
        (OR RETURN TO SKIP)        Mto skip the CP/M read operation,
X                                   Mbecause the system is already
X                                   Min memory as a result of the
X                                   previous MOVCPM operation.

        DESTINATION DRIVE NAME     Respond  with B  to  write new
        (OR RETURN TO REBOOT)      Msystem to the disk in drive B.
X                                   MSYSGEN prompts with the
X                                   following message:

        DESTINATION ON B,          Place the  new disk on drive B
        THEN TYPE RETURN           Mand press the RETURN key when
X                                   ready.

                               1-36





CP/M Operating System Manual              1.6  Transient Commands



     MIf you respond with A rather than B above, the system is
XMwritten to drive A rather than B.  SYSGEN continues to print this
Xprompt:

        DESTINATION DRIVE NAME (OR RETURN TO REBOOT)

Muntil you respond with a single carriage return, which stops the
XSYSGEN program with a system reboot.

     MYou can then go through the reboot process with the old or new
XMdisk.  Instead of performing the SYSGEN operation, you can type a
Xcommand of the form:

        SAVE 34 CPMxx.COM

Mat the completion of the MOVCPM function, where xx is the value
XMindicated in the SYSGEN message.  The CP/M memory image on the
XMcurrently logged disk is in a form that can be patched.  This is
XMnecessary when operating in a nonstandard environment where the BIOS
XMmust be altered for a particular peripheral device configuration, as
Xdescribed in Section 6.

     The following are valid MOVCPM commands:


        MOVCPM  48     MConstructs a 48K version of CP/M and starts
X                       execution.

        MOVCPM  48 *   MConstructs a 48K version of CP/M in
X                       Mpreparation for permanent recording; the
X                       response is

                       READY FOR 'SYSGEN' OR
                        'SAVE 34 CPM48.COM'

        MOVCPM * *     MConstructs a maximum memory version of CP/M
X                       and starts execution.

     MThe newly created system is serialized with the number attached
XMto the original disk and is subject to the conditions of the Digital
XResearch Software Licensing Agreement.


W1.7  BDOS Error Messages

     MT&Shere are three error situations that the Basic Disk Operating
XMSystem intercepts during file processing.  When one of these
Xconditions is detected, the BDOS prints the message:

        BDOS ERR ON d: error






                               1-37





CP/M Operating System Manual             1.7  BDOS Error Messages


Mwhere d is the drive name and error is one of the three error
Xmessages:

        BAD SECTOR
        SELECT
        READ ONLY

     MThe BAD SECTOR message indicates that the disk controller
XMelectronics has detected an error condition in reading or writing
XMthe disk.  This condition is generally caused by a malfunctioning
XMdisk controller or an extremely worn disk.  If you find that CP/M
XMreports this error more than once a month, the state of the
XMcontroller electronics and the condition of the media should be
Xchecked.

     MYou can also encounter this condition in reading files
XMgenerated by a controller produced by a different manufacturer.
XMEven though controllers claim to be IBM..-compatible, one often
XMfinds small differences in recording formats.  The Model 800
XMcontroller, for example, requires two bytes of one's following the
XMdata CRC byte, which is not required in the IBM format.  As a
XMresult, disks generated by the Intel microcomputer development
XMsystem can be read by almost all other IBM-compatible system, while
XMdisk files generated on other manufacturers' equipment produce the
XMBAD SECTOR message when read by the microcomputer development
XMsystem.  To recover from this condition, press a CTRL-C to reboot
XM(the safest course), or a return, which ignores the bad sector in
Xthe file operation.

MWNote:  &Spressing a return might destroy disk integrity if the
XMoperation is a directory write.  Be sure you have adequate back-ups
Xin this case.

     MThe SELECT error occurs when there is an attempt to address a
XMdrive beyond the range supported by the BIOS.  In this case, the
XMvalue of d in the error message gives the selected drive.  The
Xsystem reboots following any input from the console.

     MThe READ ONLY message occurs when there is an attempt to write
XMto a disk or file that has been designated as Read-Only in a STAT
XMcommand or has been set to Read-Only by the BDOS.  Reboot CP/M by
XMusing the warm start procedure, CTRL-C, or by performing a cold
XMstart whenever the disks are changed.  If a changed disk is to be
XMread but not written, BDOS allows the disk to be changed without the
XMwarm or cold start, but internally marks the drive as Read-Only.
XMThe status of the drive is subsequently changed to Read-Write if a
XMwarm or cold start occurs.  On issuing this message, CP/M waits for
XMinput from the console.  An automatic warm start takes place
Xfollowing any input.


W1.8  CP/M Operation on the Model 800





                               1-38





CP/M Operating System Manual  1.8  Operation of CP/M on the Model 800


     MThis section gives operating procedures for using CP/M on the
XMIntel Model 800 microcomputer development system microcomputer
XMdevelopment system.  Basic knowledge of the microcomputer
Xdevelopment system hardware and software systems is assumed.

     MCP/M is initiated in essentially the same manner as the Intel
XMISIS operating system.  The disk drives are labeled 0 through 3 on
XMthe microcomputer development system, corresponding to CP/M drives A
XMthrough D, respectively.  The CP/M system disk is inserted into
XMdrive 0, and the BOOT and RESET switches are pressed in sequence.
XMThe interrupt 2 light should go on at this point.  The space bar is
XMthen pressed on the system console, and the light should go out.  If
XMit does not, the user should check connections and baud rates.  The
XMBOOT switch is turned off, and the CP/M sign-on message should
XMappear at the selected console device, followed by the A> system
XMprompt.  You can then issue the various resident and transient
Xcommands.

     MThe CP/M system can be restarted (warm start) at any time by
XMpushing the INT 0 switch on the front panel.  The built-in Intel ROM
XMmonitor can be initiated by pushing the INT 7 switch, which
XMgenerates an RST 7, except when operating under DDT, in which case
Xthe DDT program gets control instead.

     MDiskettes can be removed from the drives at any time, and the
XMsystem can be shut down during operation without affecting data
XMintegrity.  Do not remove a disk and replace it with another without
XMrebooting the system (cold or warm start) unless the inserted disk
Xis Read-Only.

     MAs a result of hardware hang-ups or malfunctions, CP/M might
Xprint the following message:

        BDOS ERR ON d: BAD SECTOR

Mwhere d is the drive that has a permanent error.  This error can
XMoccur when drive doors are opened and closed randomly, followed by
XMdisk operations, or can be caused by a disk, drive, or controller
XMfailure.  You can optionally elect to ignore the error by pressing a
XMsingle return at the console.  The error might produce a bad data
XMrecord, requiring reinitialization of up to 128 bytes of data.  You
Xcan reboot the CP/M system and try the operation again.

     MTermination of a CP/M session requires no special action,
XMexcept that it is necessary to remove the disks before turning the
XMpower off to avoid random transients that often make their way to
Xthe drive electronics.

     MYou should use IBM-compatible disks rather than disks that have
XMpreviously been used with any ISIS version.  In particular, the ISIS
XMFORMAT operation produces nonstandard sector numbering throughout
XMthe disk.  This nonstandard numbering seriously degrades the
XMperformance of CP/M, and causes CP/M to operate noticeably slower
XMthan the distribution version.  If it becomes necessary to reformat
XMa disk, which should not be the case for standard disks, a program


                               1-M39



X

CP/M Operating System Manual  1.8  Operation of CP/M on the Model 800


Mcan be written under CP/M that causes the Model 800 controller to
Xreformat with sequential sector numbering (1-26) on each track.

     MGenerally, IBM-compatible 8-inch disks do not need to be
Xformatted.  However, 5 1/4-inch disks need to be formatted.


=End of Section 1

















































                               1-40








=WSection 2

=WThe CP/M Editor



W2.1  Introduction to Ed

     ME&Sd is the context editor for CP/M, and is used to create and
XMalter CP/M source files.  To start ED, type a command of the
Xfollowing form:

        ED filename
or
        ED filename.typ

MGenerally, ED reads segments of the source file given by filename or
XMfilename.typ into the central memory, where you edit the file and it
XMis subsequently written back to disk after alterations.  If the
XMsource file does not exist before editing, it is created by ED and
XMinitialized to empty.  The overall operation of Ed is shown in
XFigure 2-1.


W2.1.1  ED Operation

     ME&Sd operates upon the source file, shown in Figure 2-1 by x.y,
XMand passes all text through a memory buffer where the text can be
XMviewed or altered.  The number of lines that can be maintained in
XMthe memory buffer varies with the line length, but has a total
Xcapacity of about 5000 characters in a 20K CP/M system.

     MEdited text material is written into a temporary work file
XMunder your command.  Upon termination of the edit, the memory buffer
XMis written to the temporary file, followed by any remaining (unread)
XMtext in the source file.  The name of the original file is changed
XMfrom x.y to x.BAK so that the most recent edited source file can be
XMreclaimed if necessary.  See the CP/M commands ERASE and RENAME.
XMThe temporary file is then changed from x.$$$ to x.y, which becomes
Xthe resulting edited file.

     MThe memory buffer is logically between the source file and
Xworking file, as shown in Figure 2-2.














                               2-1





CP/M Operating System Manual              2.1  Introduction to ED





























=WFigure 2-1.  Overall ED Operation



       Source File         Memory Buffer       Temporary File

    1   First Line      1   First Line       1   First Line
    2    Appended       2    Buffered        2   Processed
    3     Lines         3      Text          3      Text



   SP                  MP                   TP



       Unprocessed  Next       Free     Next      Free File
         Source     Append    Memory    Write       Space
         Lines                Space



                        SP = Source Pointer
                        MP = Memory Pointer
                        TP = Temporary Pointer


=WFigure 2-2.  Memory Buffer Organization


                               2-2





CP/M Operating System Manual              2.1  Introduction to ED


W2.1.2  Text Transfer Functions

     MG&Siven that n is an integer value in the range 0 through 65535,
XMseveral single-letter ED commands transfer lines of text from the
XMsource file through the memory buffer to the temporary (and
XMeventually final) file.  Single letter commands are shown in upper-
Xcase, but can be typed in either upper- or lower-case.


=WTable 2-1.  ED Text Transfer Commands

   Command                          Result

	9	F0     nA        MAppends the next n unprocessed source lines
X               Mfrom the source file at SP to the end of the
X               Mmemory buffer at MP.  Increment SP and MP by n.
X               MIf upper-case translation is set (see the U
X               Mcommand) and the A command is typed in upper-
X               Mcase, all input lines will automatically be
X               translated to upper-case.

     nW        MWrites the first n lines of the memory buffer
X               Mto the temporary file free space.  Shift the
X               Mremaining lines n+1 through MP to the top of
X               the memory buffer.  Increment TP by n.

     E         MEnds the edit.  Copy all buffered text to
X               Mtemporary file and copy all unprocessed source
X               lines to temporary file.  Rename files.

     H         MMoves to head of new file by performing
X               Mautomatic E command.  The temporary file
X               Mbecomes the new source file, the memory buffer
X               Mis emptied, and a new temporary file is
X               Mcreated.  The effect is equivalent to issuing
X               Man E command, followed by a reinvocation of ED,
X               using x.y as the file to edit.

     O         MReturns to original file.  The memory buffer is
X               Memptied, the temporary file is deleted, and the
X               MSP is returned to position 1 of the source
X               Mfile.  The effects of the previous editing
X               commands are thus nullified.

     Q         MQuits edit with no file alterations, returns to
X               CP/M.
	9	K0

     MThere are a number of special cases to consider.  If the
XMinteger n is omitted in any ED command where an integer is allowed,
XMthen 1 is assumed.  Thus, the commands A and W append one line and
XMwrite one line, respectively.  In addition, if a pound sign # is
XMgiven in the place of n, then the integer 65535 is assumed (the
XMlargest value for n that is allowed).  Because most source files can
XMbe contained entirely in the memory buffer, the command #A is often


                               2-M3



X

CP/M Operating System Manual              2.1  Introduction to ED


Missued at the beginning of the edit to read the entire source file
XMto memory.  Similarly, the command #W writes the entire buffer to
Xthe temporary file.

     MTwo special forms of the A and W commands are provided as a
XMconvenience.  The command 0A fills the current memory buffer at
XMleast half full, while 0W writes lines until the buffer is at least
XMhalf empty.  An error is issued if the memory buffer size is
XMexceeded.  You can then enter any command, such as W, that does not
XMincrease memory requirements.  The remainder of any partial line
XMread during the overflow will be brought into memory on the next
Xsuccessful append.


W2.1.3  Memory Buffer Organization

     MT&She memory buffer can be considered a sequence of source lines
XMbrought in with the A command from a source file.  The memory buffer
XMhas an imaginary character pointer (CP) that moves throughout the
Xmemory buffer under command of the operator.

     MThe memory buffer appears logically as shown in Figure 2-3,
XMwhere the dashes represent characters of the source line of
XMindefinite length, terminated by carriage return (<cr>) and line-
XMfeed (<lf>) characters, and CP represents the imaginary character
XMpointer.  Note that the CP is always located ahead of the first
XMcharacter of the first line, behind the last character of the last
XMline, or between two characters.  The current line CL is the source
Xline that contains the CP.



                          Memory Buffer


      first line        -----------------------<cr><lf>


                        -----------------------<cr><lf>


      current line CL   ---------------------------<cr><lf>


                                    CP

      last line         -----------------------<cr><lf>


W        Figure 2-3.  Logical Organization of Memory Buffer







                               2-4





CP/M Operating System Manual              2.1  Introduction to ED


&SW2.1.4  Line Numbers and ED Start-up

     ME&SD produces absolute line number prefixes that are used to
XMreference a line or range of lines.  The absolute line number is
XMdisplayed at the beginning of each line when ED is in insert mode
XM(see the I command in Section 2.1.5). Each line number takes the
Xform

        nnnnn:

Mwhere nnnnn is an absolute line number in the range of 1 to 65535.
XMIf the memory buffer is empty or if the current line is at the end
Xof the memory buffer, nnnnn appears as 5 blanks.

     MYou can reference an absolute line number by preceding any
XMcommand by a number followed by a colon, in the same format as the
XMline number display.  In this case, the ED program moves the current
XMline reference to the absolute line number, if the line exists in
XMthe current memory buffer.  The line denoted by the absolute line
XMnumber must be in the memory buffer (see the A command).  Thus, the
Xcommand

        345:T

Mis interpreted as move to absolute 345, and type the line. 
XMAbsolute line numbers are produced only during the editing process
XMand are not recorded with the file.  In particular, the line numbers
Xwill change following a deleted or expanded section of text.

     MYou can also reference an absolute line number as a backward or
XMforward distance from the current line by preceding the absolute
Xnumber by a colon.  Thus, the command

        :400T

Mis interpreted as type from the current line number through the line
XMwhose absolute number is 400.  Combining the two line reference
Xforms, the command

        345::400T

Mis interpreted as move to absolute line 345, then type through
XMabsolute line 400.  Absolute line references of this sort can
Xprecede any of the standard ED commands.

     MLine numbering is controlled by the V (Verify Line Numbers)
XMcommand.  Line numbering can be turned off by typing the -V command.
X









                               2-5





CP/M Operating System Manual              2.1  Introduction to ED


MIf the file to edit does not exist, ED displays the following
Xmessage:

        NEW FILE

MTo move text into the memory buffer, you must enter an i command
XMbefore typing input lines and terminate each line with a carriage
Xreturn.  A single CTRL-Z character returns ED to command mode.


W2.1.5  Memory Buffer Operation

     MW&Shen ED begins, the memory buffer is empty.  You can either
XMappend lines from the source file with the A command, or enter the
XMlines directly from the console with the insert command.  The insert
Xcommand takes the following form:

        I

MED then accepts any number of input lines.  You must terminate each
XMline with a <cr> (the <lf> is supplied automatically).  A single
XMCTRL-Z, denoted by a caret (^)Z, returns ED to command mode.  The CP
XMis positioned after the last character entered.  The following
Xsequence:

        I<cr>
        NOW IS THE<cr>
        TIME FOR<cr>
        ALL GOOD MEN<cr>
        ^Z

leaves the memory buffer as

        NOW IS THE<cr><lf>
        TIME FOR<cr><lf>
        ALL GOOD MEN<cr><lf>

     MGenerally, ED accepts command letters in upper- or lower-case.
XMIf the command is upper-case, all input values associated with the
XMcommand are translated to upper-case.  If the I command is typed,
XMall input lines are automatically translated internally to upper-
XMcase.  The lower-case form of the i command is most often used to
Xallow both upper- and lower-case letters to be entered.

     MVarious commands can be issued that control the CP or display
XMsource text in the vicinity of the CP.  The commands shown below
XMwith a preceding n indicate that an optional unsigned value can be
XMspecified.  When preceded by +_, the command can be unsigned, or have
XMan optional preceding plus or minus sign.  As before, the pound sign
XM# is replaced by 65535.  If an integer n is optional, but not
XMsupplied, then n=1 is assumed.  Finally, if a plus sign is optional,
Xbut none is specified, then + is assumed.





                               2-6





CP/M Operating System Manual              2.1  Introduction to ED


=WTable 2-2.  Editing Commands

   Command                       Action

	9	F0     +_B        MMove CP to beginning of memory buffer if + and
X               to bottom if -.

     +_nC       MMove CP by +_n characters (moving ahead if +),
X               counting the <cr><lf> as two characters.

     +_nD       MDelete n characters ahead of CP if plus and
X               behind CP if minus.

     +_nK       MKill (remove) +_n lines of source text using CP
X               Mas the current reference.  If CP is not at the
X               Mbeginning of the current line when K is issued,
X               Mthe characters before CP remain if + is
X               Mspecified, while the characters after CP remain
X               if - is given in the command.

     +_nL       MIf n = 0, move CP to the beginning of the
X               Mcurrent line, if it is not already there.  If n 
X               M=/ 0, first move the CP to the beginning of the
X               Mcurrent line and then move it to the beginning
X               Mof the line that is n lines down (if +) or up
X               M(if -).  The CP will stop at the top or bottom
X               Mof the memory buffer if too large a value of n
X               is specified.

     +_nT       MIf n = 0, type the contents of the current line
X               Mup to CP.  If n = 1, type the contents of the
X               Mcurrent line from CP to the end of the line.
X               MIf n>1, type the current line along with n - 1
X               Mlines that follow, if + is specified.
X               MSimilarly, if n>1 and - is given, type the
X               Mprevious n lines up to the CP.  Any key can be
X               depressed to abort long type-outs.

     +_n        MEquivalent to +_nLT, which moves up or down and
X               types a single line.
	9	K0


W2.1.6  Command Strings

     MA&Sny number of commands can be typed contiguously (up to the
XMcapacity of the console buffer) and are executed only after you
XMpress the <cr>.  Table 2-3 summarizes the CP/M console line-editing
Xcommands used to control the input command line.








                               2-7





CP/M Operating System Manual              2.1  Introduction to ED


=WTable 2-3.  Line-editing Controls

     Command                      Result

	9	F0     CTRL-C     MReboots the CP/M system when typed at the
X                start of a line.

     CTRL-E     MPhysical end of line:  carriage is returned,
X                Mbut line is not sent until the carriage return
X                key is depressed.

     CTRL-H     Backspaces one character position.

     CTRL-J     Terminates current input (line-feed).

     CTRL-M     Terminates current input (carriage return).

     CTRL-R     MRetypes current command line:  types a clean
X                line character deletion with rubouts.

     CTRL-U     MDeletes the entire line typed at the console.
X
     CTRL-X     Same as CTRL-U.

     CTRL-Z     MEnds input from the console (used in PIP and
X                ED).

     rub/del    MDeletes and echos the last character typed at
X                the console.
	9	K0

     MSuppose the memory buffer contains the characters shown in the
XMprevious section, with the CP following the last character of the
XMbuffer.  In the following example, the command strings on the left
XMproduce the results shown to the right.  Use lower-case command
Xletters to avoid automatic translation of strings to upper-case.


  Command String                      Effect

	9	F0     B2T<cr>        MMove to beginning of the buffer and type
X                    two lines:

                    NOW IS THE
                    TIME FOR
                    The result in the memory buffer is

                    NOW IS THE<cr><lf>
                    TIME FOR<cr><lf>
                    ALL GOOD MEN<cr><lf>







                               2-8





CP/M Operating System Manual              2.1  Introduction to ED


  Command String                      Effect

     5C0T<cr>       MMove CP five characters and type the
X                    Mbeginning of the line NOW I.  The result
X                    in the memory buffer is

                    NOW I  S THE<cr><lf>


     2L-T<cr>       MMove two lines down and type the previous
X                    Mline TIME FOR.  The result in the memory
X                    buffer is

                    NOW IS THE<cr><lf>
                    TIME FOR<cr><lf>
                    ALL GOOD MEN<cr><lf>


     -L#K<cr>       MMove up one line, delete 65535 lines that
X                    Mfollow.  The result in the memory buffer
X                    is

                    NOW IS THE<cr><lf>


     I<cr>          Insert two  lines of text with  automatic
     TIME TO<cr>    translation to upper-case.  The result in
     INSERT<cr>     the memory buffer is
     ^Z

                    NOW IS THE<cr><lf>
                    TIME TO<cr><lf>
                    INSERT<cr><lf>


     -2L#T<cr>      MMove up two lines and type 65535 lines
X                    Mahead of CP NOW IS THE.  The result in the
X                    memory buffer is

                    NOW IS THE<cr><lf>
                    TIME TO<cr><lf>
                    INSERT<cr><lf>


     <cr>           MMove down one line and type one line
X                    MINSERT.  The result in the memory buffer
X                    is

                    NOW IS THE<cr><lf>
                    TIME TO<cr><lf>
                    INSERT<cr><lf>
	9	K0





                               2-9





CP/M Operating System Manual              2.1  Introduction to ED


W2.1.7  Text Search and Alteration

     ME&SD has a command that locates strings within the memory buffer.
XThe command takes the form

        nF s <cr>
or
        nF s ^Z

Mwhere s represents the string to match, followed by either a <cr> or
XMCTRL-Z, denoted by ^Z.  ED starts at the current position of CP and
XMattempts to match the string.  The match is attempted n times and,
XMif successful, the CP is moved directly after the string.  If the n
XMmatches are not successful, the CP is not moved from its initial
XMposition.  Search strings can include CTRL-L, which is replaced by
Xthe pair of symbols <cr><lf>.

     The following commands illustrate the use of the F command:


  Command String                      Effect

	9	F0     B#T<cr>        MMove to the beginning and type the entire
X                    Mbuffer.  The result in the memory buffer
X                    is

                    NOW IS THE <cr><lf>
                    TIME FOR<cr><lf>
                    ALL GOOD MEN<cr><lf>


     FS T<cr>       MFind the end of the string S T.  The
X                    result in the memory buffer is

                    NOW IS T  HE<cr><lf>


     FIs^Z0TT       MFind the next I and type to the CP; then
X                    Mtype the remainder of the current line ME
X                    FOR.  The result in the memory buffer is

                    NOW IS THE<cr><lf>
                    TI  ME FOR<cr><lf>

                    ALL GOOD MEN<cr><lf>
	9	K0

     MAn abbreviated form of the insert command is also allowed,
XMwhich is often used in conjunction with the F command to make simple
Xtextual changes.  The form is

        | s ^Z
or
        | s<cr>



                               2-10





CP/M Operating System Manual              2.1  Introduction to ED


Mwhere s is the string to insert.  If the insertion string is
XMterminated by a CTRL-Z, the string is inserted directly following
XMthe CP, and the CP is positioned directly after the string.  The
XMaction is the same if the command is followed by a <cr> except that
XMa <cr><lf> is automatically inserted into the text following the
XMstring.  The following command sequences are examples of the F and I
Xcommands:


  Command String                      Effect
	9	F0
     BITHIS IS ^Z<cr>

                    MInsert THIS IS at the beginning of the
X                    text.  The result in the memory buffer is

                    THIS IS  NOW THE<cr><lf>

                    TIME FOR<cr><lf>
                    ALL GOOD MEN<cr><lf>


     FTIME^Z-4DIPLACE^Z<cr>

                    MFind TIME and delete it; then insert
X                    MPLACE.  The result in the memory buffer is
X
                    THIS IS NOW THE<cr><lf>
                    PLACE    FOR<cr><lf>

                    ALL GOOD MEN<cr><lf>


     3FO^Z-3D5D1
     CHANGES^Z<cr>  MFind  third  occurrence of O (that is, the
X                    Msecond O in GOOD), delete previous 3
X                    Mcharacters and the subsequent 5
X                    Mcharacters; then insert CHANGES.  The
X                    result in the memory buffer is

                    THIS IS NOW THE<cr><lf>
                    PLACE FOR<cr><lf>
                    ALL CHANGES   <cr><lf>


     -8CISOURCE<cr>

                    MMove back 8 characters and insert the line
X                    MSOURCE<cr><lf>.  The result in the memory
X                    buffer is

                    THIS IS NOW THE<cr><lf>
                    PLACE FOR<cr><lf>
                    ALL SOURCE<cr><lf>
                       CHANGES<cr><lf>


                               2-11



	9	K0

CP/M Operating System Manual              2.1  Introduction to ED




     MED also provides a single command that combines the F and I
XMcommands to perform simple string substitutions.  The command takes
Xthe following form:

        nS  sU1D^ZsU2D <cr>
or
        nS sU1D^ZsU2D  ^Z

Mand has exactly the same effect as applying the following command
Xstring a total of n times:

        F sU1D^Z-kDIsU2 <cr>
or
        F sU1D^Z-kDIsU2D ^Z

Mwhere k is the length of the string.  ED searches the memory buffer
XMstarting at the current position of CP and successively substitutes
XMthe second string for the first string until the end of buffer, or
Xuntil the substitution has been performed n times.

     MAs a convenience, a command similar to F is provided by ED that
XMautomatically appends and writes lines as the search proceeds.  The
Xform is

        n N s <cr>
or
        n N s ^Z

Mwhich searches the entire source file for the nth occurrence of the
XMstrings (you should recall that F fails if the string cannot be
XMfound in the current buffer).  The operation of the N command is
XMprecisely the same as F except in the case that the string cannot be
XMfound within the current memory buffer.  In this case, the entire
XMmemory content is written (that is, an automatic #W is issued).
XMInput lines are then read until the buffer is at least half full, or
XMthe entire source file is exhausted.  The search continues in this
XMmanner until the string has been found n times, or until the source
Xfile has been completely transferred to the temporary file.

     MA final line editing function, called the juxtaposition
Xcommand, takes the form

        n J sU1D^ZsU2D^ZsU3D <cr>
or
        n J sU1D^ZsU2D^ZsU3D ^Z

Mwith the following action applied n times to the memory buffer:
XMsearch from the current CP for the next occurrence of the string s1.
XMIf found, insert the string s2, and move CP to follow s2.  Then
XMdelete all characters following CP up to, but not including, the 
XMstring sU3D, leaving CP directly after sU2D.  If sU3D cannot be found,
Xthen no deletion is made.  If the current line is



                               2-12





CP/M Operating System Manual              2.1  Introduction to ED


        NOW IS THE TIME<cr><lf>

the command

        JW ^ZWHAT^Z^1<cr>

results in

        NOW WHAT <cr lf>

MYou should recall that ^1 (CTRL-L) represents the pair <cr><lf> in
Xsearch and substitute strings.

     MThe number of characters ED allows in the F, S, N, and J
Xcommands is limited to 100 symbols.


W2.1.8  Source Libraries

     ME&SD also allows the inclusion of source libraries during the
Xediting process with the R command.  The form of this command is

        R filename ^Z
or
        R filename <cr>

Mwhere filename is the primary filename of a source file on the disk
XMwith an assumed filetype of LIB.  ED reads the specified file, and
XMplaces the characters into the memory buffer after CP, in a manner
Xsimilar to the I command.  Thus, if the command

        RMACRO<cr>

Mis issued by the operator, ED reads from the file MACRO.LIB until
XMthe end-of-file and automatically inserts the characters into the
Xmemory buffer.

     MED also includes a block move facility implemented through the
XX (Transfer) command.  The form

        nX

Mtransfers the next n lines from the current line to a temporary file
Xcalled

        X$$$$$$.LIB

Mwhich is active only during the editing process.  You can reposition
XMthe current line reference to any portion of the source file and
XMtransfer lines to the temporary file.  The transferred lines
XMaccumulate one after another in this file and can be retrieved by
Xsimply typing

        R



                               2-13





CP/M Operating System Manual              2.1  Introduction to ED


Mwhich is the trivial case of the library read command.  In this
XMcase, the entire transferred set of lines is read into the memory
XMbuffer.  Note that the X command does not remove the transferred
XMlines from the memory buffer, although a K command can be used
XMdirectly after the X, and the R command does not empty the
XMtransferred LIB file.  That is, given that a set of lines has been
XMtransferred with the X command, they can be reread any number of
Xtimes back into the source file.  The command

        0X

is provided to empty the transferred line file.

     MNote that upon normal completion of the ED program through Q or
XME, the temporary LIB file is removed.  If ED is aborted with a CTRL-
XMC, the LIB file will exist if lines have been transferred, but will
XMgenerally be empty (a subsequent ED invocation will erase the
Xtemporary file).


W2.1.9  Repetitive Command Execution

     MT&She macro command M allows you to group ED commands together
Xfor repeated evaluation.  The M command takes the following form:

        n M CS <cr>
or
        n M CS ^Z

Mwhere CS represents a string of ED commands, not including another M
XMcommand.  ED executes the command string n times if n>1.  If n=0 or
XM1, the command string is executed repetitively until an error
XMcondition is encountered (for example, the end of the memory buffer
Xis reached with an F command).

     MAs an example, the following macro changes all occurrences of
XMGAMMA to DELTA within the current buffer, and types each line that
Xis changed:

        MFGAMMA^Z-5DIDELTA^Z0TT<cr>

or equivalently

        MSGAMMA^ZDELTA^Z0TT<cr>


W2.2  ED Error Conditions

     MO&Sn error conditions, ED prints the message BREAK X AT C where X
Xis one of the error indicators shown in Table 2-4.







                               2-14





CP/M Operating System Manual             2.2  ED Error Conditions


=WTable 2-4.  Error Message Symbols

   Symbol                         Meaning

	9	H0     ?         Unrecognized command.

     >         MMemory buffer full (use one of the commands D, K,
X               MN, S, or W to remove characters); F, N, or S
X               strings too long.

     #         MCannot apply command the number of times
X               specified (for example, in F command).

     O         Cannot open LIB file in R command.
	9	K0

If there is a disk error, CP/M displays the following message:

        BDOS ERR on d: BAD SECTOR

MYou can choose to ignore the error by pressing RETURN at the console
XM(in this case, the memory buffer data should be examined to see if
XMthey were incorrectly read), or you can reset the system with a
XMCTRL-C and reclaim the back-up file if it exists.  The file can be
XMreclaimed by first typing the contents of the BAK file to ensure
XMthat it contains the proper information.  For example, type the
Xfollowing:

        TYPE x.BAK

where x is the file being edited.  Then remove the primary file

        ERA x.y

and rename the BAK file

        REN x.y=x.BAK

The file can then be reedited, starting with the previous version.

     MED also takes file attributes into account.  If you attempt to
Xedit a Read-Only file, the message

        ** FILE IS READ/ONLY **

Mappears at the console.  The file can be loaded and examined, but
XMcannot be altered.  You must end the edit session and use STAT to
XMchange the file attribute to R/W.  If the edited file has the system
Xattribute set, the following message:

        'SYSTEM' FILE NOT ACCESSIBLE

Mis displayed and the edit session is aborted.  Again, the STAT
Xprogram can be used to change the system attribute, if desired.



                               2-15





CP/M Operating System Manual 2.3  Control Characters and Commands


W2.3  Control Characters and Commands

     MT&Sable 2-5 summarizes the control characters and commands
Xavailable in ED.


=WTable 2-5.  ED Control Characters

	9	F0    Control                        Function
    Character

    CTRL-C          System reboot

    CTRL-E          MPhysical <cr><lf> (not actually entered in
X                    command)

    CTRL-H          Backspace

    CTRL-J          Logical tab (cols 1, 9, 16, ...)

    CTRL-L          MLogical <cr><lf> in search and substitute
X                    strings

    CTRL-R          Repeat line

    CTRL-U          Line delete

    CTRL-X          Line delete

    CTRL-Z          String terminator

    rub/del         Character delete

	9	K0
     Table 2-6 summarizes the commands used in ED.


=WTable 2-6.  ED Commands

    Command                        Function
	9	F0
      nA            Append lines

      +_B            Begin or bottom of buffer

      +_nC           Move character positions

      +_nD           Delete characters

      E             End edit and close files (normal end)

      nF            Find string





                               2-16



	9	K0

CP/M Operating System Manual 2.3  Control Characters and Commands


=WTable 2-6.  (continued)

    Command                        Function
	9	F0
      H             End edit, close and reopen files

      I             MInsert characters, use i if both upper and
X                    lower-case characters are to be entered.

      nJ            Place strings in juxtaposition

      +_nK           Kill lines

      +_nL           Move down/up lines

      nM            Macro definition

      nN            Find next occurrence with autoscan

      O             Return to original file

      +_nP           Move and print pages

      Q             Quit with no file changes

      R             Read library file

      nS            Substitute strings

      +_nT           Type lines

      +_U            MTranslate lower- to upper-case if U, no
X                    translation if -U

      +_V            MVerify line numbers, or show remaining
X                    free character space

      0V            MA special case of the V command, OV,
X                    Mprints the memory buffer statistics in the
X                    form

                    free/total

                    Mwhere free is the number of free bytes in
X                    Mthe memory buffer (in decimal) and total
X                    is the size of the memory buffer

      nW            Write lines

      nZ            Wait (sleep) for approximately n seconds

      +_n            Move and type (+_nLT).
	9	K0




                               2-17





CP/M Operating System Manual 2.3  Control Characters and Commands


     MBecause of common typographical errors, ED requires several
XMpotentially disastrous commands to be typed as single letters,
Xrather than in composite commands.  The following commands:

   o E(end)
   o H(head)
   o O(original)
   o Q(quit)

must be typed as single letter commands.

     MThe commands I, J, M, N, R, and S should be typed as i, j, m,
XMn, r, and s if both upper- and lower-case characters are used in the
XMoperation, otherwise all characters are converted to upper-case.
XMWhen a command is entered in upper-case, ED automatically converts
Xthe associated string to upper-case, and vice versa.


=End of Section 2






































                               2-18








=WSection 3

=WCP/M Assembler



&SW3.1  Introduction

     MT&She CP/M assembler reads assembly-language source files from
XMthe disk and produces 8080 machine language in Intel hex format.  To
XMstart the CP/M assembler, type a command in one of the following
Xforms:

        ASM filename
        ASM filename.parms

MIn both cases, the assembler assumes there is a file on the disk
Xwith the name:

        filename.ASM

Mwhich contains an 8080 assembly-language source file.  The first and
XMsecond forms shown above differ only in that the second form allows
XMparameters to be passed to the assembler to control source file
Xaccess and hex and print file destinations.

     MIn either case, the CP/M assembler loads and prints the
Xmessage:

        CP/M ASSEMBLER VER n.n

Mwhere n.n is the current version number.  In the case of the first
XMcommand, the assembler reads the source file with assumed filetype
XASM and creates two output files

        filename.HEX
        filename.PRN

     MThe HEX file contains the machine code corresponding to the
XMoriginal program in Intel hex format, and the PRN file contains an
XMannotated listing showing generated machine code, error flags, and
XMsource lines.  If errors occur during translation, they are listed
Xin the PRN file and at the console.

     MThe form ASM filename parms is used to redirect input and
XMoutput files from their defaults.  In this case, the parms portion
XMof the command is a three-letter group that specifies the origin of
XMthe source file, the destination of the hex file, and the
Xdestination of the print file.  The form is








                               3-1





CP/M Operating System Manual                    3.1  Introduction


        filename.p1p2p3

where p1, p2, and p3 are single letters.  P1 can be

        A,B, ...,P

Mwhich designates the disk name that contains the source file.  P2
Xcan be

        A,B, ...,P

Mwhich designates the disk name that will receive the hex file; or,
XP2 can be

        Z

which skips the generation of the hex file.

     P3 can be

        A,B, ...,P

Mwhich designates the disk name that will receive the print file.  P3
Xcan also be specified as

        X

which places the listing at the console; or

        Z

which skips generation of the print file.  Thus, the command

        ASM X.AAA

Mindicates that the source, X.HEX, and print, X.PRN, files are also
XMto be created on disk A.  This form of the command is implied if the
XMassembler is run from disk A.  Given that you are currently
Xaddressing disk A, the above command is the same as

        ASM X

The command

        ASM X.ABX

Mindicates that the source file is to be taken from disk A, the hex
XMfile is to be placed on disk B, and the listing file is to be sent
Xto the console.  The command

        ASM X.BZZ

Mtakes the source file from disk B and skips the generation of the
XMhex and print files.  This command is useful for fast execution of
Xthe assembler to check program syntax.


                               3-2





CP/M Operating System Manual                    3.1  Introduction



     MThe source program format is compatible with the Intel 8080
XMassembler.  Macros are not implemented in ASM; see the optional MAC
XMmacro assembler.  There are certain extensions in the CP/M assembler
XMthat make it somewhat easier to use.  These extensions are described
Xbelow.


W3.2  Program Format

     MA&Sn assembly-language program acceptable as input to the
Xassembler consists of a sequence of statements of the form

        line# label operation operand ;comment

Mwhere any or all of the fields may be present in a particular
XMinstance.  Each assembly-language statement is terminated with a
XMcarriage return and line-feed (the line-feed is inserted
XMautomatically by the ED program), or with the character !, which is
XMtreated as an end-of-line by the assembler.  Thus, multiple
XMassembly-language statements can be written on the same physical
Xline if separated by exclamation point symbols.

     MThe line# is an optional decimal integer value representing the
Xsource program line number, and ASM ignores this field if present.

     The label field takes either of the following forms:

        identifier
        identifier:

MThe label field is optional, except where noted in particular
XMstatement types.  The identifier is a sequence of alphanumeric
XMcharacters where the first character is alphabetic.  Identifiers can
XMbe freely used by the programmer to label elements such as program
XMsteps and assembler directives, but cannot exceed 16 characters in
XMlength.  All characters are significant in an identifier, except for
XMthe embedded dollar symbol $, which can be used to improve
XMreadability of the name.  Further, all lower-case alphabetics are
XMtreated as upper-case.  The following are all valid instances of
Xlabels:


        x       xy      long$name

        x:      yxl:    longer$named$data:

        X1Y2    X1x2    x234$5678$9012$3456:


     MThe operation field contains either an assembler directive or
XMpseudo operation, or an 8080 machine operation code.  The pseudo
XMoperations and machine operation codes are described in Section 3.3.
X



                               3-3





CP/M Operating System Manual                  3.2  Program Format


     MGenerally, the operand field of the statement contains an
XMexpression formed out of constants and labels, along with arithmetic
XMand logical operations on these elements.  Again, the complete
Xdetails of properly formed expressions are given in Section 3.3.

     MThe comment field contains arbitrary characters following the
XMsemicolon symbol until the next real or logical end-of-line.  These
XMcharacters are read, listed, and otherwise ignored by the assembler.
XMThe CP/M assembler also treats statements that begin with an * in
XMcolumn one as comment statements that are listed and ignored in the
Xassembly process.

     MThe assembly-language program is formulated as a sequence of
XMstatements of the above form, terminated by an optional END
XMstatement.  All statements following the END are ignored by the
Xassembler.


W3.3  Forming the Operand

     MT&So describe the operation codes and pseudo operations
XMcompletely, it is necessary first to present the form of the operand
XMfield, since it is used in nearly all statements.  Expressions in
XMthe operand field consist of simple operands, labels, constants, and
XMreserved words, combined in properly formed subexpressions by
XMarithmetic and logical operators.  The expression computation is
XMcarried out by the assembler as the assembly proceeds.  Each
XMexpression must produce a 16-bit value during the assembly.
XMFurther, the number of significant digits in the result must not
XMexceed the intended use.  If an expression is to be used in a byte
XMmove immediate instruction, the most significant 8 bits of the
XMexpression must be zero.  The restriction on the expression
Xsignificance is given with the individual instructions.


W3.3.1  Labels

     MA&Ss discussed above, a label is an identifier that occurs on a
XMparticular statement.  In general, the label is given a value
XMdetermined by the type of statement that it precedes.  If the label
XMoccurs on a statement that generates machine code or reserves memory
XMspace (for example, a MOV instruction or a DS pseudo operation), the
XMlabel is given the value of the program address that it labels.  If
XMthe label precedes an EQU or SET, the label is given the value that
XMresults from evaluating the operand field.  Except for the SET
Xstatement, an identifier can label only one statement.

     MWhen a label appears in the operand field, its value is
XMsubstituted by the assembler.  This value can then be combined with
XMother operands and operators to form the operand field for a
Xparticular instruction.






                               3-4





CP/M Operating System Manual             3.3  Forming the Operand


W3.3.2  Numeric Constants

     MA&S numeric constant is a 16-bit value in one of several bases.
XMThe base, called the radix of the constant, is denoted by a trailing
Xradix indicator.  The following are radix indicators:

   o B is a binary constant (base 2).
   o O is a octal constant (base 8).
   o Q is a octal constant (base 8).
   o D is a decimal constant (base 10).
   o H is a hexadecimal constant (base 16).

     MQ is an alternate radix indicator for octal numbers because the
XMletter O is easily confused with the digit 0.  Any numeric constant
XMthat does not terminate with a radix indicator is a decimal
Xconstant.

     MA constant is composed as a sequence of digits, followed by an
XMoptional radix indicator, where the digits are in the appropriate
XMrange for the radix.  Binary constants must be composed of 0 and 1
XMdigits, octal constants can contain digits in the range 0-7, while
XMdecimal constants contain decimal digits.  Hexadecimal constants
XMcontain decimal digits as well as hexadecimal digits A(10D), B(11D),
XMC(12D), D(13D), E(14D), and F(15D).  Note that the leading digit of
XMa hexadecimal constant must be a decimal digit to avoid confusing a
XMhexadecimal constant with an identifier.  A leading 0 will always
XMsuffice.  A constant composed in this manner must evaluate to a
XMbinary number that can be contained within a 16-bit counter,
Xotherwise it is truncated on the right by the assembler.

     MSimilar to identifiers, embedded $ signs are allowed within
XMconstants to improve their readability.  Finally, the radix
XMindicator is translated to upper-case if a lower-case letter is
XMencountered.  The following are all valid instances of numeric
Xconstants:


        1234      1234D     1100B     1111$0000$1111$0000B

        1234H     OFFEH     3377O     33$77$22Q

        3377o     Ofe3h     1234d     Offffh


W3.3.3  Reserved Words

     MT&Shere are several reserved character sequences that have
XMpredefined meanings in the operand field of a statement.  The names
XMof 8080 registers are given below.  When they are encountered, they
Xproduce the values shown to the right.







                               3-5





CP/M Operating System Manual             3.3  Forming the Operand


W                 Table 3-1.  Reserved Characters

                       Character     Value

                           A           7
                           B           0
                           C           1
                           D           2
                           E           3
                           H           4
                           L           5
                           M           6
                           SP          6
                           PSW         6


     MAgain, lower-case names have the same values as their upper-
XMcase equivalents.  Machine instructions can also be used in the
XMoperand field; they evaluate to their internal codes. In the case of
XMinstructions that require operands, where the specific operand
XMbecomes a part of the binary bit pattern of the instruction, for
XMexample, MOV A,B, the value of the instruction, in this case MOV, is
XMthe bit pattern of the instruction with zeros in the optional
Xfields, for example, MOV produces 40H.

     MWhen the symbol $ occurs in the operand field, not embedded
XMwithin identifiers and numeric constants, its value becomes the
XMaddress of the next instruction to generate, not including the
Xinstruction contained within the current logical line.


W3.3.4  String Constants

     MS&String constants represent sequences of ASCII characters and
XMare represented by enclosing the characters within apostrophe
XMsymbols.  All strings must be fully contained within the current
XMphysical line (thus allowing exclamation point symbols within
XMstrings) and must not exceed 64 characters in length.  The
XMapostrophe character itself can be included within a string by
XMrepresenting it as a double apostrophe (the two keystrokes ''),
XMwhich becomes a single apostrophe when read by the assembler.  In
XMmost cases, the string length is restricted to either one or two
XMcharacters (the DB pseudo operation is an exception), in which case
XMthe string becomes an 8- or 16-bit value, respectively.  Two-
XMcharacter strings become a 16-bit constant, with the second
XMcharacter as the low-order byte, and the first character as the
Xhigh-order byte.

     MThe value of a character is its corresponding ASCII code.
XMThere is no case translation within strings; both upper- and lower-
XMcase characters can be represented.  You should note that only
Xgraphic printing ASCII characters are allowed within strings.





                               3-6





CP/M Operating System Manual             3.3  Forming the Operand


           Valid strings:          How assembler reads strings:

     'A' 'AB' 'ab' 'c'               A  AB  ab  c
     '' 'a''' '''' ''''                 a'  '   '
     'Walla Walla Wash.'             Walla Walla Wash.
     'She said ''Hello'' to me.'     She said ''Hello'' to me
     'I said ''Hello'' to her.'      I said ''Hello'' to her


W3.3.5  Arithmetic and Logical Operators

     MT&She operands described in Section 3.3 can be combined in normal
XMalgebraic notation using any combination of properly formed
XMoperands, operators, and parenthesized expressions.  The operators
Xrecognized in the operand field are described in Table 3-2.


=WTable 3-2.  Arithmetic and Logical Operators
	9	F0
     Operators                         Meaning

      a + b        unsigned arithmetic sum of a and b

      a - b        Munsigned arithmetic difference between a
X                   and b

        + b        unary plus (produces b)

        - b        unary minus (identical to 0 - b)

      a * b        Munsigned magnitude multiplication of a and
X                   b

      a / b        unsigned magnitude division of a by b

      a MOD b      remainder after a / b.

      NOT b        Mlogical inverse of b (all 0s become 1s, 1s
X                   Mbecome 0s), where b is considered a 16-bit
X                   value

      a AND b      bit-by-bit logical and of a and b

      a OR b       bit-by-bit logical or of a and b

      a XOR b      bit-by-bit logical exclusive or of a and b

      a SHL b      Mthe value that results from shifting a to
X                   the left by an amount b, with zero fill

      a SHR b      Mthe value that results from shifting a to
X                   the right by an amount b, with zero fill
	9	K0




                               3-7





CP/M Operating System Manual             3.3  Forming the Operand


     MIn each case, a and b represent simple operands (labels,
XMnumeric constants, reserved words, and one- or two-character
XMstrings) or fully enclosed parenthesized subexpressions, like those
Xshown in the following examples:


        10+20  10h+37Q  LI/3  (L2+4) SHR 3

        ('a' and 5fh) + '0' ('B'+B) OR (PSW+M)

        (1+(2+c)) shr (A-(B+1))


     MNote that all computations are performed at assembly time as
XM16-bit unsigned operations.  Thus, -1 is computed as 0-1, which
XMresults in the value 0ffffh (that is, all 1s).  The resulting
XMexpression must fit the operation code in which it is used.  For
XMexample, if the expression is used in an ADI (add immediate)
XMinstruction, the high-order 8 bits of the expression must be zero.
XMAs a result, the operation ADI-1 produces an error message (-1
XMbecomes 0ffffh, which cannot be represented as an 8-bit value),
XMwhile ADI(-1) AND 0FFH is accepted by the assembler because the AND
Xoperation zeros the high-order bits of the expression.


W3.3.6  Precedence of Operators

     MA&Ss a convenience to the programmer, ASM assumes that operators
XMhave a relative precedence of application that allows the programmer
XMto write expressions without nested levels of parentheses.  The
XMresulting expression has assumed parentheses that are defined by the
XMrelative precedence.  The order of application of operators in
XMunparenthesized expressions is listed below.  Operators listed first
XMhave highest precedence (they are applied first in an
XMunparenthesized expression), while operators listed last have lowest
XMprecedence.  Operators listed on the same line have equal
XMprecedence, and are applied from left to right as they are
Xencountered in an expression.


        * / MOD SHL SHR

        - +

        NOT

        AND

        OR XOR


     MThus, the expressions shown to the left below are interpreted
XMby the assembler as the fully parenthesized expressions shown to the
Xright.



                               3-8





CP/M Operating System Manual             3.3  Forming the Operand


     a*b+c                       (a*b)+c

     a+b*c                       a+(b*c)

     a MOD b*c SHL d             ((a MOD b)*c) SHL d

     a OR b AND NOT c+d SHL e    a OR (b AND (NOT (c+(d SHL e))))


     MBalanced, parenthesized subexpressions can always be used to
XMoverride the assumed parentheses; thus, the last expression above
XMcould be rewritten to force application of operators in a different
Xorder, as shown:

        (a OR b) AND (NOT c)+ d SHL e

This results in these assumed parentheses:

        (a OR b) AND ((NOT c) + (d SHL e))

     MAn unparenthesized expression is well-formed only if the
XMexpression that results from inserting the assumed parentheses is
Xwell-formed.


W3.4  Assembler Directives

     MA&Sssembler directives are used to set labels to specific values
XMduring the assembly, perform conditional assembly, define storage
XMareas, and specify starting addresses in the program.  Each
XMassembler directive is denoted by a pseudo operation that appears in
XMthe operation field of the line.  The acceptable pseudo operations
Xare shown in Table 3-3.


W                Table 3-3.  Assembler Directives

        Directive                 Meaning

          ORG       set the program or data origin

          END       end program, optional start address

          EQU       numeric equate

          SET       numeric set

          IF        begin conditional assembly

          ENDIF     end of conditional assembly

          DB        define data bytes

          DW        define data words

          DS        define data storage area

                               3-9





CP/M Operating System Guide             3.4  Assembler Directives


W3.4.1  The ORG Directive

     T&She ORG statement takes the form:

        label  ORG  expression

Mwhere label is an optional program identifier and expression is a
XM16-bit expression, consisting of operands that are defined before
XMthe ORG statement.  The assembler begins machine code generation at
XMthe location specified in the expression.  There can be any number
XMof ORG statements within a particular program, and there are no
XMchecks to ensure that the programmer is not defining overlapping
XMmemory areas.  Note that most programs written for the CP/M system
Xbegin with an ORG statement of the form:

        ORG  100H

Mwhich causes machine code generation to begin at the base of the
XMCP/M transient program area.  If a label is specified in the ORG
XMstatement, the label is given the value of the expression.  This
XMlabel can then be used in the operand field of other statements to
Xrepresent this expression.


W3.4.2  The END Directive

     MT&She END statement is optional in an assembly-language program,
XMbut if it is present it must be the last statement.  All subsequent
XMstatements are ignored in the assembly.  The END statement takes the
Xfollowing two forms:

        label END

        label END expression

Mwhere the label is again optional.  If the first form is used, the
XMassembly process stops, and the default starting address of the
XMprogram is taken as 0000.  Otherwise, the expression is evaluated,
XMand becomes the program starting address.  This starting address is
XMincluded in the last record of the Intel-formatted machine code hex
XMfile that results from the assembly.  Thus, most CP/M assembly-
Xlanguage programs end with the statement:

        END  100H

Mresulting in the default starting address of 100H (beginning of the
Xtransient program area).










                               3-10





CP/M Operating System Guide             3.4  Assembler Directives


W3.4.3  The EQU Directive

     MT&She EQU (equate) statement is used to set up synonyms for
Xparticular numeric values.  The EQU statement takes the form:

        label    EQU    expression

Mwhere the label must be present and must not label any other
XMstatement.  The assembler evaluates the expression and assigns this
XMvalue to the identifier given in the label field.  The identifier is
XMusually a name that describes the value in a more human-oriented
XMmanner.  Further, this name is used throughout the program to place
XMparameters on certain functions.  Suppose data received from a
XMteletype appears on a particular input port, and data is sent to the
XMteletype through the next output port in sequence.  For example, you
XMcan use this series of equate statements to define these ports for a
Xparticular hardware environment:


        TTYBASE      EQU 10H         ;BASE PORT NUMBER FOR TTY

        TTYIN        EQU TTYBASE     ;TTY DATA IN

        TTYOUT       EQU TTYBASE+1   ;TTY DATA OUT


     MAt a later point in the program, the statements that access the
Xteletype can appear as follows:


        IN     TTYIN     ;READ TTY DATA TO REG-A

        ...

        OUT    TTYOUT    ;WRITE DATA TO TTY FROM REG-A


Mmaking the program more readable than if the absolute I/O ports are
XMused.  Further, if the hardware environment is redefined to start
XMthe teletype communications ports at 7FH instead of 10H, the first
Xstatement need only be changed to

        TTYBASE    EQU    7FH    ;BASE PORT NUMBER FOR TTY

Mand the program can be reassembled without changing any other
Xstatements.


W3.4.4  The SET Directive

     T&She SET statement is similar to the EQU, taking the form:

        label    SET    expression

Mexcept that the label can occur on other SET statements within the
XMprogram.  The expression is evaluated and becomes the current value

                               3-M11



X

CP/M Operating System Guide             3.4  Assembler Directives


Massociated with the label.  Thus, the EQU statement defines a label
XMwith a single value, while the SET statement defines a value that is
XMvalid from the current SET statement to the point where the label
XMoccurs on the next SET statement.  The use of the SET is similar to
XMthe EQU statement, but is used most often in controlling conditional
Xassembly.


W3.4.5  The IF and ENDIF Directives

     MT&She IF and ENDIF statements define a range of assembly-language
XMstatements that are to be included or excluded during the assembly
Xprocess.  These statements take on the form:


        IF  expression

        statement#1

        statement#2

          ...

        statement#n

        ENDIF


     MWhen encountering the IF statement, the assembler evaluates the
XMexpression following the IF.  All operands in the expression must be
XMdefined ahead of the IF statement.  If the expression evaluates to a
XMnonzero value, then statement#1 through statement#n are assembled.
XMIf the expression evaluates to zero, the statements are listed but
XMnot assembled.  Conditional assembly is often used to write a single
XMgeneric program that includes a number of possible run-time
XMenvironments, with only a few specific portions of the program
XMselected for any particular assembly.  The following program
XMsegments, for example, might be part of a program that communicates
XMwith either a teletype or a CRT console (but not both) by selecting
Xa particular value for TTY before the assembly begins.

















                               3-12





CP/M Operating System Guide             3.4  Assembler Directives


        TRUE     EQU            OFFFFH     ;DEFINE VALUE OF TRUE
        FALSE    EQU            NOT TRUE   ;DEFINE VALUE OF FALSE
        ;
        TTY      EQU            TRUE       ;TRUE IF TTY, FALSE IF CRT
        ;
        TTYBASE  EQU            10H        ;BASE OF TTY I/O PORTS
        CRTBASE  EQU            20H        ;BASE OF CRT I/O PORTS
                 IF             TTY        ;ASSEMBLE RELATIVE TO
                                           ;TTYBASE
        CONIN    EQU            TTYBASE    ;CONSOLE INPUT
        CONOUT   EQU            TTYBASE+1  ;CONSOLE OUTPUT
                 ENDIF

        ;        IF             NOT TTY    ;ASSEMBLE RELATIVE TO
                                           ;CRTBASE
        CONIN    EQU            CRTBASE    ;CONSOLE INPUT
        CONOUT   EQU            CRTBASE+1  ;CONSOLE OUTPUT

                 ENDIF
                 ...
                 IN             CONIN      ;READ CONSOLE DATA
                 ...
                 OUT            CONTOUT    ;WRITE CONSOLE DATA


MIn this case, the program assembles for an environment where a
XMteletype is connected, based at port 10H.  The statement defining
XTTY can be changed to

        TTY      EQU         FALSE

Mand, in this case, the program assembles for a CRT based at port
X20H.


W3.4.6  The DB Directive

     MT&She DB directive allows the programmer to define initialized
XMstorage areas in single-precision byte format.  The DB statement
Xtakes the form:

        label DB e#1, e#2, ..., e#n

Mwhere e#1 through e#n are either expressions that evaluate to 8-bit
XMvalues (the high-order bit must be zero) or are ASCII strings of
XMlength no greater than 64 characters.  There is no practical
XMrestriction on the number of expressions included on a single source
XMline.  The expressions are evaluated and placed sequentially into
XMthe machine code file following the last program address generated
XMby the assembler.  String characters are similarly placed into
XMmemory starting with the first character and ending with the last
XMcharacter.  Strings of length greater than two characters cannot be
Xused as operands in more complicated expressions.




                               3-13





CP/M Operating System Guide             3.4  Assembler Directives


MWNote:  &SASCII characters are always placed in memory with the parity
XMbit reset (0).  Also, there is no translation from lower- to upper-
XMcase within strings.  The optional label can be used to reference
XMthe data area throughout the remainder of the program.  The
Xfollowing are examples of valid DB statements:


        data:        DB        0,1,2,3,4,5
                     DB        data and 0ffh,5,377Q,1+2+3+4

        sign-on:     DB        'please type your name',cr,lf,0
                     DB        'AB' SHR 8, 'C', 'DE' AND 7FH



W3.4.7  The DW Directive

     MT&She DW statement is similar to the DB statement except double-
XMprecision two-byte words of storage are initialized.  The DW
Xstatement takes the form:

        label        DW        e#1, e#2, ..., e#n

Mwhere e#1 through e#n are expressions that evaluate to 16-bit
XMresults.  Note that ASCII strings of one or two characters are
XMallowed, but strings longer than two characters are disallowed.  In
XMall cases, the data storage is consistent with the 8080 processor;
XMthe least significant byte of the expression is stored first in
XMmemory, followed by the most significant byte.  The following are
Xexamples of DW statements:


        doub:        DW        0ffefh,doub+4,signon-$,255+255
                     DW        'a', 5, 'ab', 'CD', 6 shl 8 or llb.



W3.4.8  The DS Directive

     MT&She DS statement is used to reserve an area of uninitialized
Xmemory, and takes the form:

        label        DS        expression

Mwhere the label is optional.  The assembler begins subsequent code
XMgeneration after the area reserved by the DS.  Thus, the DS
XMstatement given above has exactly the same effect as the following
Xstatement:

       label:       EQU  $  ;LABEL VALUE IS CURRENT CODE LOCATION
                    ORG  $+expression  ;MOVE PAST RESERVED AREA






                               3-14





CP/M Operating System Manual                 3.5  Operation Codes


W3.5  Operation Codes

     MA&Sssembly-language operation codes form the principal part of
XMassembly-language programs and form the operation field of the
XMinstruction.  In general, ASM accepts all the standard mnemonics for 
XMthe Intel 8080 microcomputer, which are given in detail in the EIntelR 
XM8080 Assembly Language Programming Manual.R  Labels are optional on
XMeach input line.  The individual operators are listed briefly in the
XMfollowing sections for completeness, although the Intel manuals
XMshould be referenced for exact operator details.  In Tables 3-4
Xthrough 3-8, bit values have the following meaning:


   o Me3 represents a 3-bit value in the range 0-7 that can be one of
X     the predefined registers A, B, C, D, E, H, L, M, SP, or PSW.

   o e8 represents an 8-bit value in the range 0-255.

   o e16 represents a 16-bit value in the range 0-65535.


     MThese expressions can be formed from an arbitrary combination
XMof operands and operators.  In some cases, the operands are
XMrestricted to particular values within the allowable range, such as
XMthe PUSH instruction.  These cases are noted as they are
Xencountered.

     MIn the sections that follow, each operation code is listed in
XMits most general form, along with a specific example, a short
Xexplanation, and special restrictions.


W3.5.1  Jumps, Calls, and Returns

     MT&She Jump, Call, and Return instructions allow several different
XMforms that test the condition flags set in the 8080 microcomputer
XCPU.  The forms are shown in Table 3-4.


=WTable 3-4.  Jumps, Calls, and Returns
	9	I0
  Form   Bit    Example                  Meaning
        Value

  JMP    e16    JMP L1      Jump unconditionally to label

  JNZ    e16    JNZ L2      Jump on nonzero condition to label

  JZ     e16    JZ 100H     Jump on zero condition to label

  JNC    e16    JNC L1+4    Jump no carry to label

  JC     e16    JC L3       Jump on carry to label

  JPO    e16    JPO $+8     Jump on parity odd to label


                               3-15



	9	K0

CP/M Operating System Manual                 3.5  Operation Codes


=WTable 3-4.  (continued)
	9	I0
  Form   Bit    Example                  Meaning
        Value

  JPE    e16    JPE L4      Jump on even parity to label

  JP     e16    JP GAMMA    Jump on positive result to label

  JM     e16    JM al       Jump on minus to label


  CALL   e16    CALL S1     Call subroutine unconditionally

  CNZ    e16    CNZ S2      Call subroutine on nonzero
                            condition

  CZ     e16    CZ 100H     Call subroutine on zero condition

  CNC    e16    CNC S1+4    Call subroutine if no carry set

  CC     e16    CC S3       Call subroutine if carry set

  CPO    e16    CPO $+8     Call subroutine if parity odd

  CPE    e16    CPE $4      Call subroutine if parity even

  CP     e16    CP GAMMA    Call subroutine if positive result

  CM     e16    CM b1$c2    Call subroutine if minus flag


  RST    e3     RST 0       Programmed restart, equivalent to
                            CALL 8*e3, except one byte call

  RET                       Return from subroutine

  RNZ                       Return if nonzero flag set

  RZ                        Return if zero flag set

  RNC                       Return if no carry

  RC                        Return if carry flag set

  RPO                       Return if parity is odd

  RPE                       Return if parity is even

  RP                        Return if positive result

  RM                        Return if minus flag is set
	9	K0




                               3-16





CP/M Operating System Manual                 3.5  Operation Codes


W3.5.2  Immediate Operand Instructions

     MS&Several instructions are available that load single- or double-
XMprecision registers or single-precision memory cells with constant
XMvalues, along with instructions that perform immediate arithmetic or
XMlogical operations on the accumulator (register A).  Table 3-5
Xdescribes the immediate operand instructions.


=WTable 3-5.  Immediate Operand Instructions

	9	F0     Form with       Example                Meaning
     Bit Values

     MVI e3,e8    MVI B,255        MMove immediate data to
X                                   Mregister A, B, C, D, E, H,
X                                   L, or M (memory)

     ADI e8       ADI 1            MAdd immediate operand to A
X                                   without carry

     ACI e8       ACI 0FFH         MAdd immediate operand to A
X                                   with carry

     SUI e8       SUI L + 3        MSubtract from A without
X                                   borrow (carry)

     SBI e8       SBI L AND 11B    MSubtract from A with borrow
X                                   (carry)

     ANI e8       ANI $ AND 7FH    MLogical and A with
X                                   immediate data

     XRI e8       XRI 1111$0000B   MExclusive or A with
X                                   immediate data

     ORI e8       ORI L AND 1+1    MLogical or A with immediate
X                                   data

     CPI e8       CPI 'a'          MCompare A with immediate
X                                   Mdata, same as SUI except
X                                   register A not changed.

     LXI e3,e16   LXI B,100H       MLoad extended immediate to
X                                   Mregister pair.  e3 must be
X                                   Mequivalent to B, D, H, or
X                                   SP.
	9	K0

W3.5.3  Increment and Decrement Instructions

     MT&She 8080 provides instructions for incrementing or decrementing
XMsingle- and double-precision registers.  The instructions are
Xdescribed in Table 3-6.



                               3-17





CP/M Operating System Manual                 3.5  Operation Codes


=WTable 3-6.  Increment and Decrement Instructions
	9	F0
     Form with         Example              Meaning
     Bit Value

       INR e3          INR E       MSingle-precision increment
X                                   Mregister.  e3 produces one
X                                   Mof A, B, C, D, E, H, L, M.
X
       DCR e3          DCR A       MSingle-precision decrement
X                                   Mregister.  e3 produces one
X                                   Mof A, B, C, D, E, H, L, M.
X
       INX e3          INX SP      MDouble-precision increment
X                                   Mregister pair.  e3 must be
X                                   Mequivalent to B, D, H, or
X                                   SP.

       DCX e3          DCX B       MDouble-precision decrement
X                                   Mregister pair.  e3 must be
X                                   Mequivalent to B, D, H, or
X                                   SP.
	9	K0


W3.5.4  Data Movement Instructions

     MI&Snstructions that move data from memory to the CPU and from CPU
Xto memory are given in the following table.


=WTable 3-7.  Data Movement Instructions
	9	F0
     Form with      Example                 Meaning
     Bit Value

     MOV e3,e3      MOV A,B        MMove data to leftmost
X                                   Melement from rightmost
X                                   Melement.  e3 produces on
X                                   Mof A, B, C, D, E, H, L, or
X                                   MM.  MOV M,M is disallowed.
X
     LDAX e3        LDAX B         MLoad register A from
X                                   Mcomputed address.  e3 must
X                                   produce either B or D.

     STAX e3        STAX D         MStore register A to
X                                   Mcomputed address.  e3 must
X                                   produce either B or D.

     LHLD e16       LHLD L1        MLoad HL direct from
X                                   Mlocation e16.  Double-
X                                   Mprecision load to H and L.
X



                               3-18



	9	K0

CP/M Operating System Manual                 3.5  Operation Codes


=WTable 3-7.  (continued)
	9	F0
     Form with      Example                 Meaning
     Bit Value

     SHLD e16       SHLD L5+x      MStore  HL  direct  to
X                                   Mlocation e16.  Double-
X                                   Mprecision store from H and
X                                   L to memory.

     LDA e16        LDA Gamma      MLoad register A from
X                                   address e16.

     STA e16        STA X3-5       MStore register A into
X                                   memory at e16.

     POP e3         POP PSW        MLoad register pair from
X                                   Mstack, set SP.  e3 must
X                                   Mproduce one of B, D, H, or
X                                   PSW.

     PUSH e3        PUSH B         MStore register pair into
X                                   Mstack, set SP.  e3 must
X                                   Mproduce on of B, D, H, or
X                                   PSW.

     IN e8          IN 0           MLoad register A with data
X                                   from port e8.

     OUT e8         OUT 255        MSend data from register A
X                                   to port e8.

     XTHL                          MExchange data from top of
X                                   stack with HL.

     PCHL                          MFill program counter with
X                                   data from HL.

     SPHL                          MFill stack pointer with
X                                   data from HL.

     XCHG                          MExchange DE pair with HL
X                                   pair.
	9	K0


W3.5.5  Arithmetic Logic Unit Operations

     MI&Snstructions that act upon the single-precision accumulator to
XMperform arithmetic and logic operations are given in the following
Xtable.






                               3-19





CP/M Operating System Manual                 3.5  Operation Codes


=WTable 3-8.  Arithmetic Logic Unit Operations
	9	F0
     Form with       Example                Meaning
     Bit Value

      ADD e3         ADD B         MAdd register given by e3 to
X                                   Maccumulator without carry.
X                                   Me3 must produce one of A,
X                                   B, C, D, E, H, or L.

      ADC e3         ADC L         MAdd register to A with
X                                   carry, e3 as above.

      SUB e3         SUB H         MSubtract reg e3 from A
X                                   Mwithout carry, e3 is
X                                   defined as above.

      SBB e3         SBB 2         MSubtract register e3 from A
X                                   Mwith carry, e3 defined as
X                                   above.

      ANA e3         ANA 1+1       MLogical and reg with A, e3
X                                   as above.

      XRA e3         XRA A         MExclusive or with A, e3 as
X                                   above.

      ORA e3         ORA B         MLogical or with A, e3
X                                   defined as above.

      CMP e3         CMP H         MCompare register with A, e3
X                                   as above.

      DAA                          MDecimal adjust register A
X                                   Mbased upon last arithmetic
X                                   logic unit operation.

      CMA                          MComplement the bits in
X                                   register A.

      STC                          Set the carry flag to 1.

      CMC                          MComplement the carry flag.
X
      RLC                          MRotate bits left, (re)set
X                                   Mcarry as a side effect.
X                                   MHigh-order A bit becomes
X                                   carry.

      RRC                          MRotate bits right, (re)set
X                                   Mcarry as side effect.
X                                   MLow-order A bit becomes
X                                   carry.




                               3-20



	9	K0

CP/M Operating System Manual                 3.5  Operation Codes


=WTable 3-8.  (continued)
	9	F0
     Form with       Example                Meaning
     Bit Value

      RAL                          MRotate carry/A register to
X                                   Mleft.  Carry is involved
X                                   in the rotate.

      RAR                          MRotate carry/A register to
X                                   Mright.  Carry is involved
X                                   in the rotate.

      DAD e3         DAD B         MDouble-precision add
X                                   Mregister pair e3 to HL.
X                                   Me3 must produce B, D, H,
X                                   or SP.
	9	K0

W3.5.6  Control Instructions

     MT&She four remaining instructions, categorized as control
Xinstructions, are the following:

   o HLT halts the 8080 processor.
   o DI disables the interrupt system.
   o EI enables the interrupt system.
   o NOP means no operation.


W3.6  Error Messages

     MW&Shen errors occur within the assembly-language program, they
XMare listed as single-character flags in the leftmost position of the
XMsource listing.  The line in error is also echoed at the console so
XMthat the source listing need not be examined to determine if errors
Xare present.  The error codes are listed in the following table.


=WTable 3-9.  Error Codes

	9	F0   Error Code                       Meaning

   D            MData error:  element in data statement cannot
X                be placed in the specified data area.

   E            MExpression error:  expression is ill-formed
X                and cannot be computed at assembly time.

   L            MLabel error:  label cannot appear in this
X                context; might be duplicate label.

   N            MNot implemented:  features that will appear in
X                Mfuture ASM versions.  For example, macros are
X                recognized, but flagged in this version.


                               3-21



	9	K0

CP/M Operating System Manual                  3.6  Error Messages


=WTable 3-9.  (continued)

	9	F0   Error Code                       Meaning

   O            MOverflow:  expression is too complicated (too
X                Mmany pending operators) to be computed and
X                should be simplified.

   P            MPhase error:  label does not have the same
X                Mvalue on two subsequent passes through the
X                program.

   R            MRegister error:  the value specified as a
X                Mregister is not compatible with the operation
X                code.

   S            MSyntax error:  statement is not properly
X                formed.

   V            MValue error:  operand encountered in
X                expression is improperly formed.
	9	K0

     MTable 3-10 lists the error messages that are due to terminal
Xerror conditions.


=WTable 3-10.  Error Messages

	9	F0     Message       Meaning

     NO SOURCE FILE PRESENT

                   MThe file specified in the ASM command does
X                   not exist on disk.


     NO DIRECTORY SPACE

                   MThe disk directory is full; erase files
X                   that are not needed and retry.


     SOURCE FILE NAME ERROR

                   MImproperly formed ASM filename, for
X                   example, it is specified with ? fields.


     SOURCE FILE READ ERROR

                   MSource file cannot be read properly by the
X                   Massembler; execute a TYPE to determine the
X                   point of error.



                               3-22



	9	K0

CP/M Operating System Manual                  3.6  Error Messages


=WTable 3-10.  (continued)

	9	F0     Message       Meaning

     OUTPUT FILE WRITE ERROR

                   MOutput files cannot be written properly;
X                   Mmost likely cause is a full disk, erase and
X                   retry.


     CANNOT CLOSE FILE

                   MOutput file cannot be closed; check to see
X                   if disk is write protected.
	9	K0


W3.7  A Sample Session

     MT&She following sample session shows interaction with the
XMassembler and debugger in the development of a simple assembly-
XMlanguage program.  The arrow represents a carriage return keystroke.
X

	9	d0A>WASM SORT      &SAssemble SORT.ASM

CP/M ASSEMBLER - VER 1.0

0015C    Next free address
003H USE FACTOR    Percent of table used 00 to ff (hexadecimal)
END OF ASSEMBLY

A>WDIR SORT.*

&SSORT  ASM    Source file
SORT  BAK    Back-up from last edit
SORT  PRN    Print file (contains tab characters)
SORT  HEX    Machine code file

A>WTYPE SORT.PRN
&S                    Source line

            ;       SORT PROGRAM IN CP/M ASSEMBLY LANGUAGE
            ;       START AT THE BEGINNING OF THE TRANSIENT
                    PROGRAM AREA

Machine code location
0100                ORG               100H

Generated machine code
0100 214601 SORT:   LXI H,SW  ;ADDRESS SWITCH TOGGLE
0103 3601           MVI M,1   ;SET TO 1 FOR FIRST ITERATION
0105 214701         LXI H,I   ;ADDRESS INDEX
0108 3600           MVI M,0   ;I=0


                               3-23





CP/M Operating System Manual                3.7  A Sample Session


            ;
            ;       COMPARE I WITH ARRAY SIZE
010A 7E     COMPL:  MOV A,M   ;A REGISTER = I
010B FE09           CPI N-1   ;CY SET IF I<(N-1)
010D D21901         JNC CONT  ;CONTINUE IF I<=(N-2)
            ;
            ;       END OF ONE PASS THROUGH DATA
0110 214601         LXI H,SW  ;CHECK FOR ZERO SWITCHES
0113 7EB7C200001    MOV A, M! ORA A! JNZ SORT ;END OF SORT IF SW=0
            ;
0118 FF             RST 7     ;GO TO THE DEBUGGER INSTEAD OF REB
            ;
            ;       CONTINUE THIS PASS
Truncated   ;       ADDRESSING I, SO LOAD AV(I) INTO REGISTERS
0119
 5F16002148CONT:    MOV E, A! MVI D, 0! LXI H, AV! DAD D! DAD D
0121 4E792346       MOV C, M! MOV A, C! INX H! MOV B, M
            ;       LOW ORDER BYTE IN A AND C, HIGH ORDER BYTE IN B
            ;
            ;       MOV H AND L TO ADDRESS AV(I+1)
0125 23             INX H
            ;
            ;       COMPARE VALUE WITH REGS CONTAINING AV (I)
0126 965778239E     SUB M! MOV D, A! MOV A, B! INX H! SBB M  ;SUBTRACT
            ;
            ;       BORROW SET IF AV(I+1)>AV(I)
012B DA3F01         JC  INCI  ;SKIP IF IN PROPER ORDER
            ;
            ;       CHECK FOR EQUAL VALUES
012E B2CA3F01       ORA D! JZ INCI ;SKIP IF AV(I) = AV(I+1)
0132 56702B5E       MOV D, M! MOV M, B! DCX H! MOV E, M
0136 712B722B73     MOV M, C! DCX H! MOV M, D! DCX H! MOV M, E
            ;
            ;       INCREMENT SWITCH COUNT
013B 21460134       LXI H,SW! INR M
            ;
            ;       INCREMENT I
013F 21470134C3INCI:LXI H,I! INR M! JMP COMP
            ;
            ;       DATA DEFINITION SECTION
0146 00     SW:     DB 0      ;RESERVE SPACE FOR SWITCH COUNT
0147        I:      DS 1      ;SPACE FOR INDEX
0148 050064001EAV:  DW 5, 100, 30, 50, 20, 7, 1000, 300, 100, -32767
000A =      N       EQU($-AV)/2    ;COMPUTE N INSTEAD OF PRE
015C                END
A>WTYPE SORT.HEX     &SEquate value

:10010000214601360121470136007EFE09D2190140
:100110002146017EB7C20001FF5F16002148011988    Machine code in
:10012000194E79234623965778239EDA3F01B2CAA7    HEX format

:100130003F0156702B5E712B722B732146013421C7
:07014000470134C30A01006E                      Machine code in
:10014800050064001E00320014000700E8032C01BB    HEX format
:0401580064000180BE
:0000000000

                               3-24





CP/M Operating System Manual                3.7  A Sample Session


A>WDDT SORT.HEX        &SStart debug run

16K DDT VER 1.0
NEXT PC
015C 0000     Default address (no address on END statement)
-XP

P=0000 100    Change PC to 100

-UFFFF    Untrace for 65535 steps
                                           Abort with rubout
C0Z0M0E0I0 A=00 B=0000 D=0000 H=0000 S=0100 P=0100 LXI H,0146*0100
-T10    Trace 10U16D steps

C0Z0M0E0I0 A=01 B=0000 D=0000 H=0146 S=0100 P=0100 LXI H, 0146
C0Z0M0E0I0 A=01 B=0000 D=0000 H=0146 S=0100 P=0103 MVI M, 01
C0Z0M0E0I0 A=01 B=0000 D=0000 H=0146 S=0100 P=0105 LXI H, 0147
C0Z0M0E0I0 A=01 B=0000 D=0000 H=0147 S=0100 P=0108 MVI M, 00
C0Z0M0E0I0 A=01 B=0000 D=0000 H=0147 S=0100 P=010A MOV A, M
C0Z0M0E0I0 A=00 B=0000 D=0000 H=0147 S=0100 P=010B CPI 09
C1Z0M1E0I0 A=00 B=0000 D=0000 H=0147 S=0100 P=010D JNC 0119
C1Z0M1E0I0 A=00 B=0000 D=0000 H=0147 S=0100 P=0110 LXI H, 0146
C1Z0M1E0I0 A=00 B=0000 D=0000 H=0146 S=0100 P=0113 MOV A, M
C1Z0M1E0I0 A=01 B=0000 D=0000 H=0146 S=0100 P=0114 ORA A
C0Z0M0E0I0 A=01 B=0000 D=0000 H=0146 S=0100 P=0115 JNZ 0100
C0Z0M0E0I0 A=01 B=0000 D=0000 H=0146 S=0100 P=0100 LXI H, 0146
C0Z0M0E0I0 A=01 B=0000 D=0000 H=0146 S=0100 P=0103 MVI M, 01
C0Z0M0E0I0 A=01 B=0000 D=0000 H=0146 S=0100 P=0105 LXI H, 0147
C0Z0M0E0I0 A=01 B=0000 D=0000 H=0147 S=0100 P=0108 MVI M, 00
C0Z0M0E0I0 A=01 B=0000 D=0000 H=0147 S=0100 P=010A MOV A, M*010B
-A10D                                       Stopped at 10BH

010D JC 119   Change to a jump on carry
0110

-XP

P=010B 100   Reset program counter back to beginning of program

-T10    Trace execution for 10H steps

                                              Altered instruction
C0Z0M0E0I0 A=00 B=0000 D=0000 H=0147 S=0100 P=0100 LXI H,0146
C0Z0M0E0I0 A=00 B=0000 D=0000 H=0146 S=0100 P=0103 MVI M,01
C0Z0M0E0I0 A=00 B=0000 D=0000 H=0146 S=0100 P=0105 LXI H,0147
C0Z0M0E0I0 A=00 B=0000 D=0000 H=0147 S=0100 P=0108 MVI M,00
C0Z0M0E0I0 A=00 B=0000 D=0000 H=0147 S=0100 P=010A MOV A,M
C0Z0M0E0I0 A=00 B=0000 D=0000 H=0147 S=0100 P=010B CPI 09
C1Z0M1E0I0 A=00 B=0000 D=0000 H=0147 S=0100 P=010D JC 0119
C1Z0M1E0I0 A=00 B=0000 D=0000 H=0147 S=0100 P=0119 MOV E,A
C1Z0M1E0I0 A=00 B=0000 D=0000 H=0147 S=0100 P=011A MVI D,00
C1Z0M1E0I0 A=00 B=0000 D=0000 H=0147 S=0100 P=011C LXI H,0148
C1Z0M1E0I0 A=00 B=0000 D=0000 H=0148 S=0100 P=011F DAD D
C0Z0M1E0I0 A=00 B=0000 D=0000 H=0148 S=0100 P=0120 DAD D
C0Z0M1E0I0 A=00 B=0000 D=0000 H=0148 S=0100 P=0121 MOV C,M


                               3-25





CP/M Operating System Manual                3.7  A Sample Session


C0Z0M1E0I0 A=00 B=0005 D=0000 H=0148 S=0100 P=0122 MOV A,C
C0Z0M1E0I0 A=05 B=0005 D=0000 H=0148 S=0100 P=0123 INX H
C0Z0M1E0I0 A=05 B=0005 D=0000 H=0149 S=0100 P=0124 MOV B,M*0125
-L100                               Automatic breakpoint

 0100   LXI H,0146
 0103   MVI M,01
 0105   LXI H,0147
 0108   MVI M,00
 010A   MOV A,M        List some code
 010B   CPI 09         from 100H
 010D   JC  0119
 0110   LXI H,0146
 0113   MOV A,M
 0114   ORA A
 0115   JNZ 0100
 -L

 0118   RST 07
 0119   MOV E,A        List more
 011A   MVI D,00
 011C   LXI H,0148
-Abort list with rubout
-G,11B    Start program from current PC (0125H)
          and run in real time to 11BH



*0127   Stopped with an external interrupt 7 from front panel
-T4                        (program was looping indefinitely)
      Look at looping program in trace mode

C0Z0M0E0I0 A=38 B=0064 D=0006 H=0156 S=0100 P=0127 MOV D,A
C0Z0M0E0I0 A=38 B=0064 D=3806 H=0156 S=0100 P=0128 MOV A,B
C0Z0M0E0I0 A=00 B=0064 D=3806 H=0156 S=0100 P=0129 INX H
C0Z0M0E0I0 A=00 B=0064 D=3806 H=0157 S=0100 P=012A SBB M*012B
-D148
                        Data are sorted, but program does not stop.
0148 05 00 07 00 14 00 1E 00........
0150 32 00 64 00 64 00 2C 01 E8 03 01 80 00 00 00 00 2.D.D.,........

0160 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00................

-G0    Return to CP/M

A>WDDT SORT.HEX    &SReload the memory image

16K DDT VER 1.0
NEXT PC
015C 0000
-XP

P=0000 100    Set PC to beginning of program

-L10D   List bad OPCODE


                               3-26





CP/M Operating System Manual                3.7  A Sample Session



 010D   JNC 0119
 0110   LXI H,0146
-Abort list with rubout
-A10D    Assemble new OPCODE

010D JC 119

0110

-L100   List starting section of program

 0100   LXI H,0146
 0103   MVI M,01
 0105   LXI H,0147
 0108   MVI M,00
-Abort list with rubout
-A103    Change switch initialization to 00

0103 MVI M,0

0105

-^C  Return to CP/M with CTRL-C (G0 works as well)

SAVE 1 SORT.COM     Save 1 page (256 bytes, from 100H to 1ffH) on
                    disk in case there is need to reload later
A>WDDT SORT.COM      &SRestart DDT with saved memory image

16K DDT VER 1.0
NEXT PC
0200 0100    COM file always starts with address 100H
-G     Run the program from PC=100H

*0118    Programmed stop (RST 7) encountered
-D148

                              Data properly sorted
0148 05 00 07 00 14 00 1E 00........
0150 32 00 64 00 64 00 2C 01 E8 03 01 80 00 00 00 00 2.D.D.........

0160 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00................
0170 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00................

-G0   Return to CP/M

A>WED SORT.ASM     &SMake changes to original program

*N,0^Z0TT     Find next ,0
     MVI        M,0        ;I = 0

*-   Up one line in text
     LXI            H,I    ;ADDRESS INDEX




                               3-27





CP/M Operating System Manual                3.7  A Sample Session


*-   Up another line
     MVI            M,1    ;SET TO 1 FOR FIRST ITERATION

*KT  Kill line and type next line
     LXI            H,I    ;ADDRESS INDEX

*I   Insert new line
     MVI            M,0    ;ZERO SW

*T
     LXI            H,I    ;ADDRESS INDEX

*NJNC^Z0T
    JNC*T
    CONT            ;CONTINUE IF I<=(N-2)

*-2DIC^Z0LT
    JC              CONT   ;CONTINUE IF I<=(N-2)

*E                    Source from disk A
                      HEX to disk A
A>WASM SORT.AAZ        &SSkip PRN file

CP/M ASSEMBLER - VER 1.0

015C    Next address to assemble
003H USE FACTOR
END OF ASSEMBLY

A>WDDT SORT.HEX        &STest program changes

16K DDT VER 1.0
NEXT PC
015C 0000
-G100

*0118
-D148
                          Data sorted
0148 05 00 07 00 14 00 1E 00........
0150 32 00 64 00 64 00 2C 01 E8 03 01 80 00 00 00 00 2.D.D..........
0160 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00................

-Abort with rubout

-G0    Return to CP/M--program checks OK.
	9	K0

=End of Section 3








                               3-28








W                            Section 4

W                   CP/M Dynamic Debugging Tool



&SW4.1  Introduction

     MThe DDT program allows dynamic interactive testing and
XMdebugging of programs generated in the CP/M environment.  Invoke the
Xdebugger with a command of one of the following forms:

        DDT
        DDT filename.HEX
        DDT filename.COM

Mwhere filename is the name of the program to be loaded and tested.
XMIn both cases, the DDT program is brought into main memory in place
XMof the Console Command Processor (CCP) and resides directly below
XMthe Basic Disk Operating System (BDOS) portion of CP/M.  Refer to
XMSection 5 for standard memory organization.  The BDOS starting
XMaddress, located in the address field of the JMP instruction at
XMlocation 5H, is altered to reflect the reduced Transient Program
XArea (TPA) size.

     MThe second and third forms of the DDT command perform the same
XMactions as the first, except there is a subsequent automatic load of
XMthe specified HEX or COM file.  The action is identical to the
Xfollowing sequence of commands:

        DDT
        Ifilename.HEX or Ifilename.COM
        R

Mwhere the I and R commands set up and read the specified program to
XMtest.  See the explanation of the I and R commands below for exact
Xdetails.

     Upon initiation, DDT prints a sign-on message in the form:

        DDT VER m.m

where m.m is the revision number.

     MFollowing the sign-on message, DDT prompts you with the hyphen
XMcharacter, -, and waits for input commands from the console.  You
XMcan type any of several single-character commands, followed by a
XMcarriage return to execute the command.  Each line of input can be
Xline-edited using the following standard CP/M controls:








                               4-1





CP/M Operating System Manual                    4.1  Introduction


=WTable 4-1.  Line-editing Controls
	9	F0
     Control                       Result

     rubout      removes the last character typed

     CTRL-U      removes the entire line, ready for retyping

     CTRL-C      reboots system
	9	K0

     MAny command can be up to 32 characters in length.  An automatic
XMcarriage return is inserted as character 33, where the first
XMcharacter determines the command type.  Table 4-2 describes DDT
Xcommands.


W                    Table 4-2.  DDT Commands

    Command                    Result
   Character

	9	C0       A        Menters assembly-language mnemonics with
X                operands.

       D        displays memory in hexadecimal and ASCII.

       F        fills memory with constant data.

       G        Mbegins execution with optional breakpoints.
X
       I        Msets up a standard input File Control
X                Block.

       L        lists memory using assembler mnemonics.

       M        Mmoves a memory segment from source to
X                destination.

       R        reads a program for subsequent testing.

       S        substitutes memory values.

       T        traces program execution.

       U        untraced program monitoring.

       X        Mexamines and optionally alters the CPU
X                state.
	9	K0

MThe command character, in some cases, is followed by zero, one, two,
XMor three hexadecimal values, which are separated by commas or single
XMblank characters.  All DDT numeric output is in hexadecimal form.
XMThe commands are not execution until the carriage return is typed at
Xthe end of the command.


                               4-2




CP/M Operating System Manual                    4.1  Introduction


     MAt any point in the debug run, you can stop execution of DDT by
XMusing either a CTRL-C or G0 (jump to location 0000H) and save the
Xcurrent memory image by using a SAVE command of the form:

        SAVE n filename. COM

Mwhere n is the number of pages (256 byte blocks) to be saved on
XMdisk.  The number of blocks is determined by taking the high-order
XMbyte of the address in the TPA and converting this number to
XMdecimal.  For example, if the highest address in the TPA is 134H,
XMthe number of pages is 12H or 18 in decimal.  You could type a CTRL-
XC during the debug run, returning to the CCP level, followed by

        SAVE 18 X.COM

MThe memory image is saved as X.COM on the disk and can be directly
XMexecuted by typing the name X.  If further testing is required, the
Xmemory image can be recalled by typing

        DDT X.COM

Mwhich reloads the previously saved program from location 100H
XMthrough page 18, 23FFH.  The CPU state is not a part of the COM
XMfile; thus, the program must be restarted from the beginning to test
Xit properly.


W4.2  DDT Commands

     MThe individual commands are detailed below.  In each case, the
XMoperator must wait for the hyphen prompt character before entering
XMthe command.  If control is passed to a program under test, and the
XMprogram has not reached a breakpoint, control can be returned to DDT
XMby executing a RST 7 from the front panel.  In the explanation of
XMeach command, the command letter is shown in some cases with numbers
XMseparated by commas, the the numbers are represented by lower-case
XMletters.  These numbers are always assumed to be in a hexadecimal
XMradix and from one to four digits in length.  Longer numbers are
Xautomatically truncated on the right.

     MMany of the commands operate upon a CPU state that corresponds
XMto the program under test.  The CPU state holds the registers of the
XMprogram being debugged and initially contains zeros for all
XMregisters and flags except for the program counter, P, and stack
XMpointer, S, which default to 100H.  The program counter is
XMsubsequently set to the starting address given in the last record of
XMa HEX file if a file of this form is loaded, see the I and R
Xcommands.


W4.2.1  The A (Assembly) Command

     MDDT allows in-line assembly language to be inserted into the
Xcurrent memory image using the A command, which takes the form:



                               4-3





CP/M Operating System Manual                    4.2  DDT Commands


        As

Mwhere s is the hexadecimal starting address for the in-line
XMassembly.  DDT prompts the console with the address of the next
XMinstruction to fill and reads the console, looking for assembly-
XMlanguage mnemonics followed by register references and operands in 
XMabsolute hexadecimal form.  See the EIntel 8080 Assembly LanguageR 
XMReference CardR for a list of mnemonics.  Each successive load
XMaddress is printed before reading the console.  The A command
Xterminates when the first empty line is input from the console.

     MUpon completion of assembly language input, you can review the
Xmemory segment using the DDT disassembler (see the L command).

     MNote that the assembler/disassembler portion of DDT can be
XMoverlaid by the transient program being tested, in which case the
XMDDT program responds with an error condition when the A and L
Xcommands are used.


W4.2.2  The D (Display) Command

     MThe D command allows you to view the contents of memory in
Xhexadecimal and ASCII formats.  The D command takes the forms:

        D
        Ds
        Ds,f

     MIn the first form, memory is displayed from the current display
XMaddress, initially 100H, and continues for 16 display lines.  Each
Xdisplay line takes the followng form:

aaaa bb bb bb bb bb bb bb bb bb bb bb bb bb bb bb bb cccccccccccccccc

Mwhere aaaa is the display address in hexadecimal and bb represents
XMdata present in memory starting at aaaa.  The ASCII characters
XMstarting at aaaa are to the right (represented by the sequence of
XMcharacter c) where nongraphic characters are printed as a period.
XMYou should note that both upper- and lower-case alphabetics are
XMdisplayed, and will appear as upper-case symbols on a console device
XMthat supports only upper-case.  Each display line gives the values
XMof 16 bytes of data, with the first line truncated so that the next
Xline begins at an address that is a multiple of 16.

     MThe second form of the D command is similar to the first,
Xexcept that the display address is first set to address s.

     MThe third form causes the display to continue from address s
XMthrough address f.  In all cases, the display address is set to the
XMfirst address not displayed in this command, so that a continuing
XMdisplay can be accomplished by issuing successive D commands with no
Xexplicit addresses.




                               4-4





CP/M Operating System Manual                    4.2  DDT Commands


     MExcessively long displays can be aborted by pressing the return
Xkey.


W4.2.3  The F (Fill) Command

     The F command takes the form:

        Fs,f,c,

Mwhere s is the starting address, f is the final address, and c is a
XMhexadecimal byte constant.  DDT stores the constant c at address s,
XMincrements the value of s and test against f.  If s exceeds f, the
XMoperation terminates, otherwise the operation is repeated.  Thus,
XMthe fill command can be used to set a memory block to a specific
Xconstant value.


W4.2.4  The G (Go) Command

     MA program is executed using the G command, with up to two
Xoptional breakpoint addresses.  The G command takes the forms:


        G
        Gs
        Gs,b
        Gs,b,c
        G,b
        G,b,c


     MThe first form executes the program at the current value of the
XMprogram counter in the current machine state, with no breakpoints
XMset.  The only way to regain control in DDT is through a RST 7
XMexecution.  The current program counter can be viewed by typing an X
Xor XP command.

     MThe second form is similar to the first, except that the
XMprogram counter in the current machine state is set to address s
Xbefore execution begins.

     MThe third form is the same as the second, except that program
XMexecution stops when address b is encountered (b must be in the area
XMof the program under test).  The instruction at location b is not
Xexecuted when the breakpoint is encountered.

     MThe fourth form is identical to the third, except that two
XMbreakpoints are specified, one at b and the other at c.
XMEncountering either breakpoint causes execution to stop, and both
XMbreakpoints are cleared.  The last two forms take the program
XMcounter from the current machine state and set one and two
Xbreakpoints, respectively.




                               4-5





CP/M Operating System Manual                    4.2  DDT Commands


     MExecution continues from the starting address in real-time to
XMthe next breakpoint.  There is no intervention between the starting
XMaddress and the break address by DDT.  If the program under test
XMdoes not reach a breakpoint, control cannot return to DDT without
XMexecuting a RST 7 instruction.  Upon encountering a breakpoint, DDT
Xstops execution and types

        *d

Mwhere d is the stop address.  The machine state can be examined at
XMthis point using the X (Examine) command.  You must specify
XMbreakpoints that differ from the program counter address at the
XMbeginning of the G command.  Thus, if the current program counter is
X1234H, then the following commands:

        G,1234
        G400,400

Mboth produce an immediate breakpoint without executing any
Xinstructions.


W4.2.5  The I (Input) Command

     MThe I command allows you to insert a filename into the default
XMFile Control Block (FCB) at 5CH.  The FCB created by CP/M for
XMtransient programs is placed at this location (see Section 5).  The
XMdefault FCB can be used by the program under test as if it had been
XMpassed by the CP/M Console Processor.  Note that this filename is
XMalso used by DDT for reading additional HEX and COM files.  The I
Xcommand takes the forms:

        Ifilename
        Ifilename.typ

     MIf the second form is used and the filetype is either HEX or
XMCOM, subsequent R commands can be used to read the pure binary or
Xhex format machine code.  Section 4.2.8 gives further details.


W4.2.6  The L (List) Command

     MThe L command is used to list assembly-language mnemonics in a
Xparticular program region.  The L command takes the forms:

        L
        Ls
        Ls,f

     MThe first form lists twelve lines of disassembled machine code
XMfrom the current list address.  The second form sets the list
XMaddress to s and then lists twelve lines of code.  The last form
XMlists disassembled code from s through address f.  In all three
XMcases, the list address is set to the next unlisted location in
XMpreparation for a subsequent L command.  Upon encountering an


                               4-M6



X

CP/M Operating System Manual                    4.2  DDT Commands


Mexecution breakpoint, the list address is set to the current value
XMof the program counter (G and T commands).  Again, long typeouts can
Xbe aborted by pressing RETURN during the list process.


W4.2.7  The M (Move) Command

     MThe M command allows block movement of program or data areas
XMfrom one location to another in memory.  The M command takes the
Xform:

        Ms,f,d

Mwhere s is the start address of the move, f is the final address,
XMand d is the destination address.  Data is first removed from s to
XMd, and both addresses are incremented.  If s exceeds f, the move
Xoperation stops; otherwise, the move operation is repeated.


W4.2.8  The R (Read) Command

     MThe R command is used in conjunction with the I command to read
XMCOM and HEX files from the disk into the transient program area in
Xpreparation for the debug run.  The R command takes the forms:

        R
        RB

Mwhere b is an optional bias address that is added to each program or
XMdata address as it is loaded.  The load operation must not overwrite
XMany of the system parameters from 000H through 0FFH (that is, the
XMfirst page of memory).  If b is omitted, then b=0000 is assumed.
XMThe R command requires a previous I command, specifying the name of
XMa HEX or COM file.  The load address for each record is obtained
XMfrom each individual HEX record, while an assumed load address of
XM100H is used for COM files.  Note that any number of R commands can
XMbe issued following the I command to reread the program under test,
XMassuming the tested program does not destroy the default area at
XM5CH.  Any file specified with the filetype COM is assumed to contain
XMmachine code in pure binary form (created with the LOAD or SAVE
XMcommand), and all others are assumed to contain machine code in
XIntel hex format (produced, for example, with the ASM command).

     Recall that the command,

        DDT filename.filetype

which initiates the DDT program, equals to the following commands:

        DDT
        -Ifilename.filetype
        -R





                               4-7





CP/M Operating System Manual                    4.2  DDT Commands



     MWhenever the R command is issued, DDT responds with either the
XMerror indicator ? (file cannot be opened, or a checksum error
XMoccurred in a HEX file) or with a load message.  The load message
Xtakes the form:

        NEXT PC
        nnnn pppp

Mwhere nnnn is the next address following the loaded program and pppp
XMis the assumed program counter (100H for COM files, or taken from
Xthe last record if a HEX file is specified).


W4.2.9  The S (Set) Command

     MThe S command allows memory locations to be examined and
Xoptionally altered.  The S command takes the form:

        Ss

Mwhere s is the hexadecimal starting address for examination and
XMalteration of memory.  DDT responds with a numeric prompt, giving
XMthe memory location, along with the data currently held in memory.
XMIf you type a carriage return, the data is not altered.  If a byte
XMvalue is typed, the value is stored at the prompted address.  In
XMeither case, DDT continues to prompt with successive addresses and
XMvalues until you type either a period or an invalid input value is
Xdetected.


W4.2.10  The T (Trace) Command

     MThe T command allows selective tracing of program execution for
X1 to 65535 program steps.  The T command takes the forms:

        T
        Tn

     MIn the first form, the CPU state is displayed and the next
XMprogram step is executed.  The program terminates immediately, with
Xthe termination address displayed as

        *hhhh

Mwhere hhhh is the next address to execute.  The display address
XM(used in the D command) is set to the value of H and L, and the list
XMaddress (used in the L command) is set to hhhh.  The CPU state at
Xprogram termination can then be examined using the X command.

     MThe second form of the T command is similar to the first,
XMexcept that execution is traced for n steps (n is a hexadecimal
XMvalue) before a program breakpoint occurs.  A breakpoint can be
XMforced in the trace mode by typing a rubout character.  The CPU
XMstate is displayed before each program step is taken in trace mode.
XMThe format of the display is the same as described in the X command.
X

                               4-8




CP/M Operating System Manual                    4.2  DDT Commands


     MYou should note that program tracing is discontinued at the
XMCP/M interface and resumes after return from CP/M to the program
XMunder test.  Thus, CP/M functions that access I/O devices, such as
XMthe disk drive, run in real-time, avoiding I/O timing problems.
XMPrograms running in trace mode execute approximately 500 times
XMslower than real-time because DDT gets control after each user
XMinstruction is executed.  Interrupt processing routines can be
XMtraced, but commands that use the breakpoint facility (G, T, and U)
XMaccomplish the break using an RST 7 instruction, which means that
XMthe tested program cannot use this interrupt location.  Further, the
XMtrace mode always runs the tested program with interrupts enabled,
XMwhich may cause problems if asynchronous interrupts are received
Xduring tracing.

     MTo get control back to DDT during trace, press RETURN rather
XMthan executing an RST 7.  This ensures that the trace for current
Xinstruction is completed before interruption.


W4.2.11  The U (Untrace) Command

     MThe U command is identical to the T command, except that
XMintermediate program steps are not displayed.  The untrace mode
XMallows from 1 to 65535, (0FFFFH) steps to be executed in monitored
XMmode and is used principally to retain control of an executing
XMprogram while it reaches steady state conditions.  All conditions of
Xthe T command apply to the U command.


W4.2.12  The X (Examine) Command

     MThe X command allows selective display and alteration of the
XMcurrent CPU state for the program under test.  The X command takes
Xthe forms:

        X
        Xr

Mwhere r is one of the 8080 CPU registers listed in the following
Xtable.


W                    Table 4-3.  CPU Registers

            Register        Meaning           Value

               C        Carry flag            (0/1)
               Z        Zero flag             (0/1)
               M        Minus flag            (0/1)
               E        Even parity flag      (0/1)
               I        Interdigit carry      (0/1)
               A        Accumulator           (0-FF)
               B        BC register pair      (0-FFFF)
               D        DE register pair      (0-FFFF)



                               4-9





CP/M Operating System Manual                    4.2  DDT Commands


W                     Table 4-3.  (continued)

            Register        Meaning           Value

               H        HL register pair      (0-FFFF)
               S        Stack pointer         (0-FFFF)
               P        Program counter       (0-FFFF)


MIn the first case, the CPU register state is displayed in the
Xformat:

        CfZfMfEflf A=bb B=dddd D=dddd H=dddd S=dddd P=dddd inst

Mwhere f is a 0 or 1 flag value, bb is a byte value, and dddd is a
XMdouble-byte quantity corresponding to the register pair.  The inst
XMfield contains the disassembled instruction, that occurs at the
Xlocation addressed by the CPU state's program counter.

     MThe second form allows display and optional alteration of
XMregister values, where r is one of the registers given above (C, Z,
XMM, E, I, A, B, D, H, S, or P).  In each case, the flag or register
XMvalue is first displayed at the console.  The DDT program then
XMaccepts input from the console.  If a carriage return is typed, the
XMflag or register value is not altered.  If a value in the proper
XMrange is typed, the flag or register value is altered.  You should
XMnote that BC, DE, and HL are displayed as register pairs.  Thus, you
XMmust type the entire register pair when B, C, or the BC pair is
Xaltered.


W4.3  Implementation Notes

     MThe organization of DDT allows certain nonessential portions to
XMbe overlaid to gain a larger transient program area for debugging
XMlarge programs.  The DDT program consists of two parts:  the DDT
XMnucleus and the assembler/disassembler module.  The DDT nucleus is
XMloaded over the CCP and, although loaded with the DDT nucleus, the
XMassembler/disassembler is overlayable unless used to assemble or
Xdisassemble.

     MIn particular, the BDOS address at location 6H (address field
XMof the JMP instruction at location 5H) is modified by DDT to address
XMthe base location of the DDT nucleus, which, in turn, contains a JMP
XMinstruction to the BDOS.  Thus, programs that use this address field
XMto size memory see the logical end of memory at the base of the DDT
Xnucleus rather than the base of the BDOS.

     MThe assembler/disassembler module resides directly below the
XMDDT nucleus in the transient program area.  If the A, L, T, or X
XMcommands are used during the debugging process, the DDT program
XMagain alters the address field at 6H to include this module, further
XMreducing the logical end of memory.  If a program loads beyond the
XMbeginning of the assembler/disassembler module, the A and L commands
XMare lost (their use produces a ? in response) and the trace and


                               4-M10



X

CP/M Operating System Manual            4.3  Implementation Notes


Mdisplay (T and X) commands list the inst field of the display in
Xhexadecimal, rather than as a decoded instruction.


W4.4  A Sample Program

     MThe following example shows an edit, assemble, and debug for a
XMsimple program that reads a set of data values and determines the
XMlargest value in the set.  The largest value is taken from the
Xvector and stored into LARGE at the termination of the program.
	9	U0

A>WED SCAN.ASM                &SCreate source program;
                             " " represents carriage return.
*I
                ORG          1-00H          ;START OF TRANSIENT
                                            ;AREA
                MVI          B, LEN         ;LENGTH OF VECTOR TO SCAN
                MVI          C, 0           ;LARGER_RST VALUE SO FAR
LOOP            LXI          H, VECT        ;BASE OF VECTOR
LOOP:           MOV          A, M           ;GET VALUE
                SUB          C              ;LARGER VALUE IN C?
                JNC          NFOUND         ;JUMP IF LARGER VALUE NOT
                                            ;FOUND
;               NEW LARGEST VALUE, STORE IT TO C
                MOV          C, A
NFOUND          INX          H              ;TO NEXT ELEMENT
                DCR          B              ;MORE TO SCAN?
                JNZ          LOOP           ;FOR ANOTHER
;
;               END OF SCAN, STORE C
                MOV          A, C           ;GET LARGEST VALUE
                STA          LARGE
                JMP          0              ;REBOOT
;
;               TEST DATA
VECT:           DB           2,0,4,3,5,6,1,5
LEN             EQU          $-VECT         ;LENGTH
LARGE:          DS           1              ;LARGEST VALUE ON EXIT
                END

















                               4-11





CP/M Operating System Manual                4.4  A Sample Program


^-Z
*B0P
                ORG          100H           ;START OF TRANSIENT AREA
                MVI          B,LEN          ;LENGTH OF VECTOR TO SCAN
                MVI          C,0            ;LARGEST VALUE SO FAR
                LXI          H,VECT         ;BASE OF VECTOR
LOOP:           MOV          A,M            ;GET VALUE
                SUB          C              ;LARGER VALUE IN C?
                JNC          NFOUND         ;JUMP IF LARGER VALUE NOT
                                            ;FOUND
;               NEW LARGEST VALUE, STORE IT TO C
                MOV          C,A
NFOUND:         INX          H              ;TO NEXT ELEMENT
                DCR          B              ;MORE TO SCAN?
                JNZ          LOOP           ;FOR ANOTHER
;               END OF SCAN, STORE C
                MOV          A,C            ;GET LARGEST VALUE
                STA          LARGE
                JMP          0              ;REBOOT
;
;               TEST DATA

VECT:           DB           2,0,4,3,5,6,1,5
LEN             EQU          $-VECT         ;LENGTH
LARGE:          DS           1              ;LARGEST VALUE ON EXIT
                END
*E <--End of edit

A>WASM SCAN     &SStart Assembler

CP/M ASSEMBLER - VER 1.0

0122
002H USE FACTOR
END OF ASSEMBLY     Assembly complete; lock at program listing

A>WTYPE SCAN.PRN
&S Code address   Source program
 0100                        ORG 100H       ;START OF TRANSIENT AREA
 0100    0608                MVI B,LEN      ;LENGTH OF VECTOR TO SCAN
 0102    0E00 Machine code   MVI C,0        ;LARGEST VALUE SO FAR
 0104    211901              LXI H,VECT.    ;BASE OF VECTOR
 0107    7E          LOOP:   MOV A,M        ;GET VALUE
 0108    91                  SUB C          ;LARGER VALUE IN C?
 0109    D20D01              JNC NFOUND     ;JUMP IF LARGER VALUE NOT
                                            ;FOUND
                     ;       NEW LARGEST VALUE, STORE IT TO C
 010C    4F                  MOV C,A









                               4-12





CP/M Operating System Manual                4.4  A Sample Program


 010D    23          NFOUND: INX H          ;TO NEXT ELEMENT
 010E    05                  DCR  B         ;MORE TO SCAN?
 010F    C20701              JNZ LOOP       ;FOR ANOTHER
                     ;
                     ;       END OF SCAN, STORE C
 0112    79                  MOV A,C        ;GET LARGEST VALUE
 0113    322101              STA LARGE

 0116    C30000              JMP 0          ;REBOOT
   Code--data listing;
   truncated         ;       TEST DATA
 0119    0200040305  VECT:   DB 2,0,4,3,5,6,1,5
 0008    = Value of  LEN     EQU $-VECT     ;LENGTH
 0121      equate    LARGE:  DS 1           ;LARGEST VALUE ON EXIT
 0122                        END


A>WDDT SCAN.HEX      &SStart debugger using hex format machine code

DDT VER 1.0
NEXT PC                                              Next instruction
0121 0000                                            to execute at
-X     Last load address + 1                         PC=0

C0Z0M0E0I0 A=00 B=0000 D=0000 H=0000 S=0100 P=0000 OUT 7F
-XP                 Examine registers before debug run

P=0000 100    Change PC to 100

-X    Look at registers again

C0Z0M0E0I0 A=00 B=0000 D=0000 H=0000 S=0100 P=0100 MVI B,08
-L100
                              PC changed      Next instruction
                                              to execute at PC=100
 0100   MVI        B,08
 0102   MVI        C,00
 0104   LXI        H,0119
 0107   MOV        A,M
 0108   SUB        C          Disassembled machine
 0109   JNC        010D       code at 100H
 010C   MOV        C,A        (see source listing
 010D   INX        H          for comparison)
 010E   DCR        B
 010F   JNZ        0107
 0112   MOV        A,C
-L










                               4-13





CP/M Operating System Manual                4.4  A Sample Program


 0113   STA        0121
 0116   JMP        0000
 0119   STAX       B
 011A   NOP                   A little more machine
 011B   INR        B          code.  Note that pro-
 011C   INX        B          gram ends at location
 011D   DCR        B          116 with a JMP to
 011E   MVI        B,01       0000.  Remainder of
 0120   DCR        B          listing is assembly of
 0121   LXI        D,2200     data.
 0124   LXI        H,0200
-A116  Enter in-line assembly mode to change the JMP to 0000 into a RST 7,
       which will cause the program under test to return to DDT if 116H is
       ever executed.
0116 RST 7

0117   (Single carriage return stops assemble mode)

-L113   List code at 113H to check that RST 7 was properly inserted

 0113   STA        0121
 0116   RST        07    in place of JMP
 0117   NOP
 0118   NOP
 0119   STAX       B
 011A   NOP
 011B   INR        B
 011C   INX        B
-

-X    Look at registers

C0Z0M0E0I0 A=00 B=0000 D=0000 H=0000 S=0100 P=0100 MVI B,08
-T
   Execute Program for one stop. Initial CPU state, before   is executed

C0Z0M0E0I0 A=00 B=0000 D=0000 H=0000 S=0100 P=0100 MVI B,08*0102
                                       Automatic breakpoint

     Trace one step again (note O8H in B)
C0Z0M0E0I0 A=00 B=0800 D=0000 H=0000 S=0100 P=0102 MVI C,00*0104
-T
     Trace again (Register C is cleared)
C0Z0M0E0I0 A=00 B=0800 D=0000 H=0000 S=0100 P=0104 LXI H,0119*0107
-T3  Trace three steps
C0Z0M0E0I0 A=00 B=0800 D=0000 H=0119 S=0100 P=0107 MOV A,M
C0Z0M0E0I0 A=02 B=0800 D=0000 H=0119 S=0100 P=0108 SUB C
C0Z0M0E0I1 A=02 B=0800 D=0000 H=0119 S=0100 P=0109 JNC 010D*010D
-D119
       Display memory starting at 119H. Automatic breakpoint at 10DH

0119 02 00 04 03 05 06 01.Program data         Lower-case x
0120 05 11 00 22 21 00 02 7E EB 77 13 23 EB 0B 78 B1 ..."!.. . W .#..X.
0130 C2 27 01 C3 03 29 00 00 00 00 00 00 00 00 00 00 ...' ...).........
0140 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ..................


                               4-14





CP/M Operating System Manual                4.4  A Sample Program


0150 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ..................
0160 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 Data are displayed
0170 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 in ASCI with a "."
0180 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 in the position of
0190 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 nongraphic........
01A0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 characters........
01B0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ..................
01C0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ..................
-X
           Current CPU state
C0Z0M0E0I1 A=02 B=0800 D=0000 H=0119 S=0100 P=010D INX H
-T5
     Trace 5 steps from current CPU state
C0Z0M0E0I1 A=02 B=0800 D=0000 H=0119 S=0100 P=010D INX H
C0Z0M0E0I1 A=02 B=0800 D=0000 H=011A S=0100 P=010E DCR B
C0Z0M0E0I1 A=02 B=0700 D=0000 H=011A S=0100 P=010F JNZ 0107
C0Z0M0E0I1 A=02 B=0700 D=0000 H=011A S=0100 P=0107 MOV A,M
C0Z0M0E0I1 A=00 B=0700 D=0000 H=011A S=0100 P=0108 SUB C*0109

U5
                                   Automatic breakpoint
     Trace without listing intermediate states
C0Z1M0E1I1 A=00 B=0700 D=0000 H=011A S=0100 P=0109 JNC 010D*0108
-X
                       CPU state at end of U5
C0Z0M0E1I1 A=04 B=0600 D=0000 H=011B S=0100 P=0108 SUB C
-G   Run program from current PC until completion (in real-time)

*0116   breakpoint at 116H, caused by executing RST 7 in machine code.

-X
     CPU state at end of program
C0Z1M0E1I1 A=00 B=0000 D=0000 H=0121 S=0100 P=0116 RST 07
-XP
     Examine and change program counter

P=0116 100

-X

C0Z1M0E1I1 A=00 B=0000 D=0000 H=0121 S=0100 P=0100 MVI B,08
-T10

                            First data element
                                   Current largest value
                                          Subtract for comparison C
    Trace 10 (hexadecimal) steps
C0Z1M0E1I1 A=00 B=0800 D=0000 H=0121 S=0100 P=0100 MVI B,08
C0Z1M0E1I1 A=00 B=0000 D=0000 H=0121 S=0100 P=0102 MVI C,00
C0Z1M0E1I1 A=00 B=0800 D=0000 H=0121 S=0100 P=0104 LXI H,0119
C0Z1M0E1I1 A=00 B=0800 D=0000 H=0119 S=0100 P=0107 MOV A,M
C0Z1M0E1I1 A=02 B=0800 D=0000 H=0119 S=0100 P=0108 SUB C
C0Z0M0E0I1 A=02 B=0800 D=0000 H=0119 S=0100 P=0109 JNC 010D
C0Z0M0E0I1 A=02 B=0800 D=0000 H=0119 S=0100 P=010D INX H
C0Z0M0E0I1 A=02 B=0800 D=0000 H=011A S=0100 P=010E DCR B


                               4-15





CP/M Operating System Manual                4.4  A Sample Program


C0Z0M0E0I1 A=02 B=0700 D=0000 H=011A S=0100 P=010F JNZ 0107
C0Z0M0E0I1 A=02 B=0700 D=0000 H=011A S=0100 P=0107 MOV A,M
C0Z0M0E0I1 A=00 B=0700 D=0000 H=011A S=0100 P=0108 SUB C
C0Z1M0E1I1 A=00 B=0700 D=0000 H=011A S=0100 P=0109 JNC 010D
C0Z1M0E1I1 A=00 B=0700 D=0000 H=011A S=0100 P=010D INX H
C0Z1M0E1I1 A=00 B=0700 D=0000 H=011B S=0100 P=010E DCR B
C0Z0M0E1I1 A=00 B=0600 D=0000 H=011B S=0100 P=010F JNZ 0107
C0Z0M0E1I1 A=00 B=0600 D=0000 H=011B S=0100 P=0107 MOV A,M*0108
-A109
             Insert a "hot patch" into    Program should have moved the
             the machine code             value from A into C since A>C.
0109 JC 10D  to change the                Since this code was not executed,
             JNC to JC                    it appears that the JNC should
010C                                      have been a JC instruction

       Stop DDT so that a version of
-G0    the patched program can be saved

A>WSAVE 1 SCAN.COM  &SProgram resides on first
                   page, so save 1 page.
A>WDDT SCAN.COM
&S                   Restart DDT with the save memory
DDT VER 1.0        image to continue testing
NEXT PC
0200 0100

-L100    List some code

 0100    MVI B,08
 0102    MVI C,00
 0104    LXI H,0119
 0107    MOV A,M
 0108    SUB C
 0109    JC  010D    Previous patch is present in X.COM
 010C    MOV C,A
 010D    INX H
 010E    DCR B
 010F    JNZ 0107
 0112    MOV A,C
 -XP

P=0100

-T10
     Trace to see how patched version operates    Data is moved from A to C
C0Z0M0E0I0 A=00 B=0000 D=0000 H=0000 S=0100 P=0100 MVI B,08
C0Z0M0E0I0 A=00 B=0800 D=0000 H=0000 S=0100 P=0102 MVI C,00
C0Z0M0E0I0 A=00 B=0800 D=0000 H=0000 S=0100 P=0104 LXI H,0119
C0Z0M0E0I0 A=00 B=0800 D=0000 H=0119 S=0100 P=0107 MOV A,M
C0Z0M0E0I0 A=02 B=0800 D=0000 H=0119 S=0100 P=0108 SUB C
C0Z0M0E0I1 A=02 B=0800 D=0000 H=0119 S=0100 P=0109 JC  010D
C0Z0M0E0I1 A=02 B=0800 D=0000 H=0119 S=0100 P=010C MOV C,A
C0Z0M0E0I1 A=02 B=0802 D=0000 H=0119 S=0100 P=010D INX H
C0Z0M0E0I1 A=02 B=0802 D=0000 H=011A S=0100 P=010E DCR B
C0Z0M0E0I1 A=02 B=0702 D=0000 H=011A S=0100 P=010F JNZ 0107


                               4-16





CP/M Operating System Manual                4.4  A Sample Program


C0Z0M0E0I1 A=02 B=0702 D=0000 H=011A S=0100 P=0107 MOV A,M
C0Z0M0E0I1 A=00 B=0702 D=0000 H=011A S=0100 P=0108 SUB C
C1Z0M1E0I0 A=FE B=0702 D=0000 H=011A S=0100 P=0109 JC  010D
C1Z0M1E0I0 A=FE B=0702 D=0000 H=011A S=0100 P=010D INX H
C1Z0M1E0I0 A=FE B=0702 D=0000 H=011B S=0100 P=010E DCR B
C1Z0M0E1I1 A=FE B=0602 D=0000 H=011B S=0100 P=010F JNZ 0107*0107
-X                                  Breakpoint after 16 steps

C1Z0M0E1I1 A=FE B=0602 D=0000 H=011B S=0100 P=0107 MOV A,M
-G,108   Run from current PC and breakpoint at 108H

*0108
-X
                Next data item
C1Z0M0E1I1 A=04 B=0602 D=0000 H=011B S=0100 P=0108 SUB C
-T
    Single step for a few cycles
C1Z0M0E1I1 A=04 B=0602 D=0000 H=011B S=0100 P=0108 SUB C*0109
-T

C0Z0M0E0I1 A=02 B=0602 D=0000 H=011B S=0100 P=0109 JC 010D*010C
-X

C0Z0M0E0I1 A=02 B=0602 D=0000 H=011B S=0100 P=010C MOV C,A
-G   Run to completion

*0116
-X

C0Z1M0E1I1 A=03 B=0003 D=0000 H=0121 S=0100 P=0116 RST 07
-S121   Look at the value of "LARGE"

 0121   03   Wrong value!

 0122   00

 0123   22

 0124   21

 0125   00

 0126   02

 0127   7E  _.    End of the S command

-L100

 0100   MVI        B,08
 0102   MVI        C,00
 0104   LXI        H,0119
 0107   MOV        A,M
 0108   SUB        C
 0109   JC         010D
 010C   MOV        C,A


                               4-17





CP/M Operating System Manual                4.4  A Sample Program


 010D   INX        H
 010E   DCR        B
 010F   JNZ        0107
 0112   MOV        A,C
-L                            Review the code

 0113   STA        0121
 0116   RST        07
 0117   NOP
 0118   NOP
 0119   STAX       B
 011A   NOP
 011B   INR        B
 011C   INX        B
 011D   DCR        B
 011E   MVI        B,01
 0120   DCR        B
-XP

P=0116 100   Reset the PC

-T
    Single step, and watch data values
C0Z1M0E1I1 A=03 B=0003 D=0000 H=0121 S=0100 P=0100 MVI B,08*0102
-T

C0Z1M0E1I1 A=03 B=0803 D=0000 H=0121 S=0100 P=0102 MVI C,00*0104
-T
         Count set     Largest set
C0Z1M0E1I1 A=03 B=0800 D=0000 H=0121 S=0100 P=0104 LXI H,0119*0107
-T
                                    Base address of data set
C0Z1M0E1I1 A=03 B=0800 D=0000 H=0119 S=0100 P=0107 MOV A,M*0108
-T
                 First data item brought to A
C0Z1M0E1I1 A=02 B=0800 D=0000 H=0119 S=0100 P=0108 SUB C*0109
-T

C0Z0M0E0I1 A=02 B=0800 D=0000 H=0119 S=0100 P=0109 JC 010D*010C
-T

C0Z0M0E0I1 A=02 B=0800 D=0000 H=0119 S=0100 P=010C MOV C,A*010D
-T
                       First data item moved to C correctly
C0Z0M0E0I1 A=02 B=0802 D=0000 H=0119 S=0100 P=010D INX H*010E
-T

C0Z0M0E0I1 A=02 B=0802 D=0000 H=011A S=0100 P=010E DCR B*010F
-T

C0Z0M0E0I1 A=02 B=0702 D=0000 H=011A S=0100 P=010F JNZ 0107*0107
-T

C0Z0M0E0I1 A=02 B=0702 D=0000 H=011A S=0100 P=0107 MOV A,M*0108
-T


                               4-18





CP/M Operating System Manual                4.4  A Sample Program


                 Second data item brought to A
C0Z0M0E0I1 A=00 B=0702 D=0000 H=011A S=0100 P=0108 SUB C*0109
-T
                 Subtract destroys data value that was loaded!
C1Z0M1E0I0 A=FE B=0702 D=0000 H=011A S=0100 P=0109 JC 010D*010D
-T

C1Z0M1E0I0 A=FE B=0702 D=0000 H=011A S=0100 P=010D INX H*010E
-L100

 0100   MVI        B,08
 0102   MVI        C,00
 0104   LXI        H,0119
 0107   MOV        A,M
 0108   SUB        C       This should have been a CMP so that register A
 0109   JC         010D    would not be destroyed.
 010C   MOV        C,A
 010D   INX        H
 010E   DCR        B
 010F   JNZ        0107
 0112   MOV        A,C
 -A108

0108 CMP C    Hot patch at 108H changes SUB to CMP

0109

-G0   Stop DDT for SAVE

A>WSAVE 1 SCAN.COM    &SSave memory image

A>WDDT SCAN.COM    &SRestart DDT

DDT VER 1.0
NEXT PC
0200 0100
-XP

P=0100

-L116

 0116   RST        07
 0117   NOP
 0118   NOP               Look at code to see if it was properly loaded
 0119   STAX       B      (long typeout aborted with rubout)
 011A   NOP
 -

-G,116    Run from 100H to completion

*0116
-XC     Look at carry (accidental typo)
C1
-X   Look at CPU state


                               4-19





CP/M Operating System Manual                4.4  A Sample Program


C1Z1M0E1I1 A=06 B=0006 D=0000 H=0121 S=0100 P=0116 RST 07
-S121   Look at "large"--it appears to be correct.

0121 06

0122 00

0123 22

-G0    Stop DDT

A>WED SCAN.ASM    &SRe-edit the source program, and make both changes

*NSUB
*0LT
     CTRL-Z        SUB     C           ;LARGER VALUE IN C?
*SSUB^|ZCMP^|Z0LT
                   CMP     D           ;LARGER VALUE IN C?
*
                   JNC     NFOUND      ;JUMP IF LARGER VALUE NOT FOUND
*SNC^|ZC^|Z0LT
                   JC      NFOUND      ;JUMP IF LARGER VALUE NOT FOUND
*E
                      Reassemble, selecting source from disk A
A>WASM SCAN.AAZ   &S<--- Hex to disk A
                      Print to Z (selects no print file)
CP/M ASSEMBLER    VER 1.0

0122
002H USE FACTOR
END OF ASSEMBLY

A>WDDT SCAN.HEX    &SRerun debugger to check changes

DDT VER 1.0
NEXT PC
0121 0000
-L116

 0116   JMP        0000     Check to ensure end is still at 116H

 0119   STAX       B

 011A   NOP
 011B   INR        B

 -(rubout)

-G100,116    Go from beginning with breakpoint at end

*0116    Breakpoint reached
-D121    Look at "LARGE"
                      Correct value computed
0121 06 00 22 21 00 02 7E EB 77 13 23 EB 0B 78 B1 .. '!... W .#..X.
0130 C2 27 01 C3 03 29 00 00 00 00 00 00 00 00 00 00 .'...)........


                               4-20





CP/M Operating System Manual                4.4  A Sample Program


0140 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ..............

-(rubout) Aborts long typeout

G0    Stop DDT, debug session complete.
	9	K0

=End of Section 4

















































                               4-21








=WSection 5

=&SWCP/M 2 System Interface


&S5.1  Introduction

     This chapter describes CP/M (release 2) system organization including the
structure of memory and system entry points.  This section provides
the information you need to write programs that operate under CP/M and
that use the peripheral and disk I/O facilities of the system.

     CP/M is logically divided into four parts, called the Basic Input/Output
System (BIOS), the Basic Disk Operating System (BDOS), the Console Command
Processor (CCP), and the Transient Program Area (TPA).  The BIOS is a
hardware-dependent module that defines the exact low level interface with a
particular computer system that is necessary for peripheral device I/O.
Although a standard BIOS is supplied by Digital Research, explicit
instructions are provided for field reconfiguration of the BIOS to match
nearly any hardware environment, see Section 6.

     The BIOS and BDOS are
logically combined into a single module with a common entry point and
referred to as the FDOS.  The CCP is a distinct program that uses the FDOS to
provide a human-oriented interface with the information that is cataloged on
the back-up storage device.  The TPA is an area of memory,
not used by the FDOS and CCP, where various nonresident operating
system commands and user programs are executed.  The lower portion of memory
is reserved for system information and is detailed in later sections.  Memory
organization of the CP/M system is shown in Figure 5-1.



                  High
                  Memory     FDOS (BDOS+BIOS)
                  FBASE:

                                   CCP
                  CBASE:

                                   TPA
                  TBASE:

                             System Parameters
                  BOOT:


=WFigure 5-1.  CP/M Memory Organization



     M&SThe exact memory addresses corresponding to BOOT, TBASE, CBASE,
XMand FBASE vary from version to version and are described fully in
XMSection 6.  All standard CP/M versions assume BOOT=0000H, which is
XMthe base of random access memory.  The machine code found at


                               5-M1



X

CP/M Operating System Manual                    5.1  Introduction


Mlocation BOOT performs a system warm start, which loads and
XMinitializes the programs and variables necessary to return control
XMto the CCP.  Thus, transient programs need only jump to location
XMBOOT to return control to CP/M at the command level.  Further, the
XMstandard versions assume TBASE=BOOT+0100H, which is normally
XMlocation 0100H.  The principal entry point to the FDOS is at
XMlocation BOOT+0005H (normally 0005H) where a jump to FBASE is found.
XMThe address field at BOOT+0006H (normally 0006H) contains the value
XMof FBASE and can be used to determine the size of available memory,
Xassuming that the CCP is being overlaid by a transient program.

     MTransient programs are loaded into the TPA and executed as
XMfollows.  The operator communicates with the CCP by typing command
XMlines following each prompt.  Each command line takes one of the
Xfollowing forms:

        command
        command file1
        command file1 file2

Mwhere command is either a built-in function, such as DIR or TYPE, or
XMthe name of a transient command or program.  If the command is a
XMbuilt-in function of CP/M, it is executed immediately.  Otherwise,
XMthe CCP searches the currently addressed disk for a file by the name
X
        command.COM

     MIf the file is found, it is assumed to be a memory image of a
XMprogram that executes in the TPA and thus implicity originates at
XMTBASE in memory.  The CCP loads the COM file from the disk into
Xmemory starting at TBASE and can extend up to CBASE.

     MIf the command is followed by one or two file specifications,
XMthe CCP prepares one or two File Control Block (FCB) names in the
XMsystem parameter area.  These optional FCBs are in the form
XMnecessary to access files through the FDOS and are described in
XSection 5.2.

     MThe transient program receives control from the CCP and begins
XMexecution, using the I/O facilities of the FDOS.  The transient
XMprogram is called from the CCP.  Thus, it can simply return to the
XMCCP upon completion of its processing, or can jump to BOOT to pass
XMcontrol back to CP/M.  In the first case, the transient program must
XMnot use memory above CBASE, while in the latter case, memory up
Xthrough FBASE-1 can be used.

     MThe transient program can use the CP/M I/O facilities to
XMcommunicate with the operator's console and peripheral devices,
XMincluding the disk subsystem.  The I/O system is accessed by passing
XMa function number and an information address to CP/M through the
XMFDOS entry point at BOOT+0005H.  In the case of a disk read, for
XMexample, the transient program sends the number corresponding to a
XMdisk read, along with the address of an FCB to the CP/M FDOS.  The
XMFDOS, in turn, performs the operation and returns with either a disk
XMread completion indication or an error number indicating that the


                               5-M2



X

CP/M Operating System Manual                    5.1  Introduction


disk read was unsuccessful.


W5.2  Operating System Call Conventions

     MT&Shis section provides detailed information for performing
XMdirect operating system calls from user programs.  Many of the
XMfunctions listed below, however, are accessed more simply through
XMthe I/O macro library provided with the MAC macro assembler and
XMlisted in the Digital Research manual entitled, EProgrammer'sR
XUtilities Guide for the CP/M Family of Operating Systems.

     MRCP/M facilities that are available for access by transient
XMprograms fall into two general categories:  simple device I/O and
Xdisk file I/O.  The simple device operations are

   o read a console character
   o write a console character
   o read a sequential character
   o write a sequential character
   o get or set I/O status
   o print console buffer
   o interrogate console ready

     The following FDOS operations perform disk I/O:

   o disk system reset
   o drive selection
   o file creation
   o file close
   o directory search
   o file delete
   o file rename
   o random or sequential read
   o random or sequential write
   o interrogate available disks
   o interrogate selected disk
   o set DMA address
   o set/reset file indicators.

     MAs mentioned above, access to the FDOS functions is
XMaccomplished by passing a function number and information address
XMthrough the primary point at location BOOT+0005H.  In general, the
XMfunction number is passed in register C with the information address
XMin the double byte pair DE.  Single byte values are returned in
XMregister A, with double byte values returned in HL, a zero value is
XMreturned when the function number is out of range.  For reasons of
XMcompatibility, register A = L and register B = H upon return in all
XMcases.  Note that the register passing conventions of CP/M agree
XMwith those of the Intel PL/M systems programming language.  CP/M
Xfunctions and their numbers are listed below.






                               5-3





CP/M Operating System Manual                5.2  Call Conventions


      O  System Reset             19  Delete File
      1  Console Input            20  Read Sequential
      2  Console Output           21  Write Sequential
      3  Reader Input             22  Make File
      4  Punch Output             23  Rename File
      5  List Output              24  Return Login Vector
      6  Direct Console I/O       25  Return Current Disk
      7  Get I/O Byte             26  Set DMA Address
      8  Set I/O Byte             27  Get Addr(Alloc)
      9  Print String             28  Write Protect Disk
     10  Read Console Buffer      29  Get R/0 Vector
     11  Get Console Status       30  Set File Attributes
     12  Return Version Number    31  Get Addr(Disk Parms)
     13  Reset Disk System        32  Set/Get User Code
     14  Select Disk              33  Read Random
     15  Open File                34  Write Random
     16  Close File               35  Compute File Size
     17  Search for First         36  Set Random Record
     18  Search for Next          37  Reset Drive
                                  40  Write Random with Zero Fill


     MFunctions 28 and 32 should be avoided in application programs
Xto maintain upward compatibility with CP/M.

     MUpon entry to a transient program, the CCP leaves the stack
XMpointer set to an eight-level stack area with the CCP return address
XMpushed onto the stack, leaving seven levels before overflow occurs.
XMAlthough this stack is usually not used by a transient program (most
XMtransients return to the CCP through a jump to location 0000H) it is
XMlarge enough to make CP/M system calls because the FDOS switches to
XMa local stack at system entry.  For example, the assembly-language
XMprogram segment below reads characters continuously until an
XMasterisk is encountered, at which time control returns to the CCP,
Xassuming a standard CP/M system with BOOT = 0000H.


        BDOS      EQU        0005H      ;STANDARD CP/M ENTRY
        CONIN     EQU        1          ;CONSOLE INPUT FUNCTION
        ;
                  ORG        0100H      ;BASE OF TPA
        NEXTC:    MVI        C,CONIN    ;READ NEXT CHARACTER
                  CALL       BDOS       ;RETURN CHARACTER IN <A>
                  CPI        '*'        ;END OF PROCESSING?
                  JNZ        NEXTC      ;LOOP IF NOT
                  RET                   ;RETURN TO CCP
                  END


     MCP/M implements a named file structure on each disk, providing
XMa logical organization that allows any particular file to contain
XMany number of records from completely empty to the full capacity of
XMthe drive.  Each drive is logically distinct with a disk directory
XMand file data area.  The disk filenames are in three parts: the
XMdrive select code, the filename (consisting of one to eight nonblank


                               5-M4



X

CP/M Operating System Manual                5.2  Call Conventions


Mcharacters), and the filetype (consisting of zero to three nonblank
XMcharacters).  The filetype names the generic category of a
XMparticular file, while the filename distinguishes individual files
XMin each category.  The filetypes listed in Table 5-1 name a few
XMgeneric categories that have been established, although they are
Xsomewhat arbitrary.


W                   Table 5-1.  CP/M Filetypes

 &S               Filetype           Meaning

                   ASM        Assembler Source
                   PRN        Printer Listing
                   HEX        Hex Machine Code
                   BAS        Basic Source File
                   INT        Intermediate Code
                   COM        Command File
                   PLI        PL/I Source File
                   REL        Relocatable Module
                   TEX        TEX Formatter Source
                   BAK        ED Source Backup
                   SYM        SID Symbol File
                   $$$        Temporary File


     MSource files are treated as a sequence of ASCII characters,
XMwhere each line of the source file is followed by a carriage return,
XMand line-feed sequence (0DH followed by 0AH).  Thus, one 128-byte
XMCP/M record can contain several lines of source text.  The end of an
XMASCII file is denoted by a CTRL-Z character (1AH) or a real end-of-
XMfile returned by the CP/M read operation.  CTRL-Z characters
XMembedded within machine code files (for example, COM files) are
XMignored and the end-of-file condition returned by CP/M is used to
Xterminate read operations.

     MFiles in CP/M can be thought of as a sequence of up to 65536
XMrecords of 128 bytes each, numbered from 0 through 65535, thus
XMallowing a maximum of 8 megabytes per file.  Note, however, that
XMalthough the records may be considered logically contiguous, they
XMmay not be physically contiguous in the disk data area.  Internally,
XMall files are divided into 16K byte segments called logical extents,
XMso that counters are easily maintained as 8-bit values.  The
XMdivision into extents is discussed in the paragraphs that follow:
XMhowever, they are not particularly significant for the programmer,
XMbecause each extent is automatically accessed in both sequential and
Xrandom access modes.

     MIn the file operations starting with Function 15, DE usually
XMaddresses a FCB.  Transient programs often use the default FCB area
XMreserved by CP/M at location BOOT+005CH (normally 005CH) for simple
XMfile operations.  The basic unit of file information is a 128-byte
XMrecord used for all file operations.  Thus, a default location for
XMdisk I/O is provided by CP/M at location BOOT+0080H (normally 0080H)
Xwhich is the initial default DMA address.  See Function 26.


                               5-5





CP/M Operating System Manual                5.2  Call Conventions



     MAll directory operations take place in a reserved area that
XMdoes not affect write buffers as was the case in release 1, with the
XMexception of Search First and Search Next, where compatibility is
Xrequired.

     MThe FCB data area consists of a sequence of 33 bytes for
XMsequential access and a series of 36 bytes in the case when the file
XMis accessed randomly.  The default FCB, normally located at 005CH,
XMcan be used for random access files, because the three bytes
XMstarting at BOOT+007DH are available for this purpose.  Figure 5-2
Xshows the FCB format with the following fields.



    dr f1 f2 / / f8 t1 t2 t3 ex s1 s2 rc d0 / / dn cr r0 r1 r2
    00 01 02 ... 08 09 10 11 12 13 14 15 16 ... 31 32 33 34 35


W             Figure 5-2.  File Control Block Format



MThe following table lists and describes each of the fields in the
XFile Control Block figure.


W              Table 5-2.  File Control Block Fields

       Field                        Definition

     dr                   drive code (0-16)
                          0 = use default drive for file
                          1 = auto disk select drive A,
                          2 = auto disk select drive B,
                          .
                          .
                          .
                          16= auto disk select drive P.

     f1...f8              contain the filename in ASCII
                          upper-case, with high bit = 0

     t1, t2, t3           contain the filetype in ASCII
                          upper-case, with high bit = 0
                          t1', t2', and t3' denote the
                          bit of these positions,
                          t1' = 1 =>Read-Only file,
                          t2' = 1 =>SYS file, no DIR list

     ex                   contains the current extent
                          number, normally set to 00 by
                          the user, but in range 0-31
                          during file I/O



                               5-6





CP/M Operating System Manual                5.2  Call Conventions


W                     Table 5-2.  (continued)

&S       Field                        Definition

     s1                   reserved for internal system use

     s2                   reserved for internal system use,
                          set to zero on call to OPEN, MAKE,
                          SEARCH

     rc                   record count for extent ex;
                          takes on values from 0-127

     d0...dn              filled in by CP/M; reserved for
                          system use

     cr                   current record to read or write in
                          a sequential file operation;
                          normally set to zero by user

     r0, r1, r2           optional random record number in
                          the range 0-65535, with overflow
                          to r2, r0, r1 constitute a 16-bit
                          value with low byte r0, and high
                          byte r1


     MEach file being accessed through CP/M must have a corresponding
XMFCB, which provides the name and allocation information for all
XMsubsequent file operations.  When accessing files, it is the
XMprogrammer's responsibility to fill the lower 16 bytes of the FCB
XMand initialize the cr field.  Normally, bytes 1 through 11 are set
XMto the ASCII character values for the filename and filetype, while
Xall other fields are zero.

     MFCBs are stored in a directory area of the disk, and are
XMbrought into central memory before the programmer proceeds with file
XMoperations (see the OPEN and MAKE functions).  The memory copy of
XMthe FCB is updated as file operations take place and later recorded
XMpermanently on disk at the termination of the file operation, (see
Xthe CLOSE command).

     MThe CCP constructs the first 16 bytes of two optional FCBs for
XMa transient by scanning the remainder of the line following the
XMtransient name, denoted by file1 and file2 in the prototype command
XMline described above, with unspecified fields set to ASCII blanks.
XMThe first FCB is constructed at location BOOT+005CH and can be used
XMas is for subsequent file operations.  The second FCB occupies the
XMd0...dn portion of the first FCB and must be moved to another area
XMof memory before use.  If, for example, the following command line
Xis typed:

        PROGNAME B:X.ZOT Y.ZAP




                               5-7





CP/M Operating System Manual                5.2  Call Conventions


Mthe file PROGNAME.COM is loaded into the TPA, and the default FCB at
XMBOOT+005CH is initialized to drive code 2, filename X, and filetype
XMZOT.  The second drive code takes the default value 0, which is
XMplaced at BOOT-006CH, with the filename Y placed into location
XMBOOT+006DH and filetype ZAP located 8 bytes later at BOOT+0075H.
XMAll remaining fields through cr are set to zero.  Note again that it
XMis the programmer's responsibility to move this second filename and
XMfiletype to another area, usually a separate file control block,
XMbefore opening the file that begins at BOOT+005CH, because the open
Xoperation overwrites the second name and type.

     MIf no filenames are specified in the original command, the
XMfields beginning at BOOT+005DH and BOOT+006DH contain blanks.  In
XMall cases, the CCP translates lower-case alphabetics to upper-case
Xto be consistent with the CP/M file naming conventions.

     MAs an added convenience, the default buffer area at location
XMBOOT+0080H is initialized to the command line tail typed by the
XMoperator following the program name.  The first position contains
XMthe number of characters, with the characters themselves following
XMthe character count.  Given the above command line, the area
Xbeginning at BOOT+0080H is initialized as follows:


     BOOT+0080H:

     +00 +01 +02 +03 +04 +05 +06 +07 +08 +09 +A  +B  +C  +D  +E
     E   ''  'B' ':' 'X' '.' 'Z' 'O' 'T' ''  'Y' '.' 'Z' 'A' 'P'


Mwhere the characters are translated to upper-case ASCII with
XMuninitialized memory following the last valid character.  Again, it
XMis the responsibility of the programmer to extract the information
XMfrom this buffer before any file operations are performed, unless
Xthe default DMA address is explicitly changed.

     MIndividual functions are described in detail in the pages that
Xfollow.



















                               5-8





CP/M Operating System Manual                5.2  Call Conventions






                    FUNCTION 0:  SYSTEM RESET

                    Entry Parameters:
                           Register C:  00H



     MThe System Reset function returns control to the CP/M operating
XMsystem at the CCP level.  The CCP reinitializes the disk subsystem
XMby selecting and logging-in disk drive A.  This function has exactly
Xthe same effect as a jump to location BOOT.






                   FUNCTION 1:  CONSOLE INPUT

                Entry Parameters:
                      Register C:  01H

                Returned Value:
                      Register A:  ASCII Character



     MThe Console Input function reads the next console character to
XMregister A.  Graphic characters, along with carriage return, line-
XMfeed, and back space (CTRL-H) are echoed to the console.  Tab
XMcharacters, CTRL-I, move the cursor to the next tab stop.  A check
XMis made for start/stop scroll, CTRL-S, and start/stop printer echo,
XMCTRL-P.  The FDOS does not return to the calling program until a
XMcharacter has been typed, thus suspending execution if a character
Xis not ready.


















                               5-9





CP/M Operating System Manual                5.2  Call Conventions






                   FUNCTION 2:  CONSOLE OUTPUT

                Entry Parameters
                      Register C:  02H
                      Register E:  ASCII Character



     MThe ASCII character from register E is sent to the console
XMdevice.  As in Function 1, tabs are expanded and checks are made for
Xstart/stop scroll and printer echo.






                    FUNCTION 3:  READER INPUT

                Entry Parameters:
                      Register C:  03H

                Returned Value:
                      Register A:  ASCII Character



     MThe Reader Input function reads the next character from the
XMlogical reader into register A.  See the IOBYTE definition in
XMChapter 6.  Control does not return until the character has been
Xread.






















                               5-10





CP/M Operating System Manual                5.2  Call Conventions






                    FUNCTION 4:  PUNCH OUTPUT

                 Entry Parameters:
                       Register C:  04H
                       register E:  ASCII Character



     MThe Punch Output function sends the character from register E
Xto the logical punch device.






                    FUNCTION 5:  LIST OUTPUT

                Entry Parameters:
                      Register C:  05H
                      Register E:  ASCII Character



     MThe List Output function sends the ASCII character in register
XE to the logical listing device.



























                               5-11





CP/M Operating System Manual                5.2  Call Conventions






                 FUNCTION 6:  DIRECT CONSOLE I/O

                Entry Parameters:
                      Register C:  06H
                      Register E:  0FFH (input) or
                                   char (output)

                Returned Value:
                      Register A:  char or status



     MDirect Console I/O is supported under CP/M for those
XMspecialized applications where basic console input and output are
XMrequired.  Use of this function should, in general, be avoided since
XMit bypasses all of the CP/M normal control character functions (for
XMexample, CTRL-S and CTRL-P).  Programs that perform direct I/O
XMthrough the BIOS under previous releases of CP/M, however, should be
XMchanged to use direct I/O under BDOS so that they can be fully
Xsupported under future releases of MP/M  and CP/M.

     MUpon entry to Function 6, register E either contains
XMhexadecimal FF, denoting a console input request, or an ASCII
XMcharacter.  If the input value is FF, Function 6 returns A = 00 if
XMno character is ready, otherwise A contains the next console input
Xcharacter.

     MIf the input value in E is not FF, Function 6 assumes that E
Xcontains a valid ASCII character that is sent to the console.

     MFunction 6 must not be used in conjunction with other console
XI/O functions.






                    FUNCTION 7:  GET I/O BYTE

                Entry Parameters:
                      Register C:  07H

                Returned Value:
                      Register A:  I/O Byte Value



     MThe Get I/O Byte function returns the current value of IOBYTE
Xin register A.  See Chapter 6 for IOBYTE definition.



                               5-12





CP/M Operating System Manual                5.2  Call Conventions






                    FUNCTION 8:  SET I/O BYTE

                Entry Parameters:
                      Register C:  08H
                      Register E:  I/O Byte Value



     MThe SET I/O Byte function changes the IOBYTE value to that
Xgiven in register E.






                    FUNCTION 9:  PRINT STRING

               Entry Parameters:
                     Register C:  09H
                   Registers DE:  String Address



     MThe Print String function sends the character string stored in
XMmemory at the location given by DE to the console device, until a $
XMis encountered in the string.  Tabs are expanded as in Function 2,
Xand checks are made for start/stop scroll and printer echo.

























                               5-13





CP/M Operating System Manual                5.2  Call Conventions






                FUNCTION 10:  READ CONSOLE BUFFER

                Entry Parameters:
                      Register C:  0AH
                    Registers DE:  Buffer Address

                Returned Value:
                     Console Characters in Buffer



     MThe Read Buffer functions reads a line of edited console input
XMinto a buffer addressed by registers DE.  Console input is
XMterminated when either input buffer overflows or a carriage return
Xor line-feed is typed.  The Read Buffer takes the form:

        DE:+0 +1 +2 +3 +4 +5 +6 +7 +8 . . .+n

        mx nc c1 c2 c3 c4 c5 c6 c7  ... ??

Mwhere mx is the maximum number of characters that the buffer will
XMhold, 1 to 255, and nc is the number of characters read (set by FDOS
XMupon return) followed by the characters read from the console.  If
XMnc < mx, then uninitialized positions follow the last character,
XMdenoted by ?? in the above figure.  A number of control functions,
Xsummarized in Table 5-3, are recognized during line editing.


W               Table 5-3.  Edit Control Characters

       Character             Edit Control Function

        rub/del     removes and echoes the last character

        CTRL-C      reboots when at the beginning of line

        CTRL-E      causes physical end of line

        CTRL-H      backspaces one character position

        CTRL-J      (line feed) terminates input line

        CTRL-M      (return) terminates input line

        CTRL-R      retypes the current line after new line

        CTRL-U      removes current line

        CTRL-X      same as CTRL-U




                               5-14





CP/M Operating System Manual                5.2  Call Conventions


MThe user should also note that certain functions that return the
XMcarriage to the leftmost position (for example, CTRL-X) do so only
XMto the column position where the prompt ended.  In earlier releases,
XMthe carriage returned to the extreme left margin.  This convention
Xmakes operator data input and line correction more legible.




















































                               5-15





CP/M Operating System Manual                5.2  Call Conventions






                FUNCTION 11:  GET CONSOLE STATUS

                Entry Parameters:
                      Register C:  0BH

                Returned Value:
                      Register A:  Console Status



     MThe Console Status function checks to see if a character has
XMbeen typed at the console.  If a character is ready, the value 0FFH
Xis returned in register A.  Otherwise a 00H value is returned.






               FUNCTION 12:  RETURN VERSION NUMBER

               Entry Parameters:
                     Register C:  0CH

               Returned Value:
                   Registers HL:  Version Number



     MFunction 12 provides information that allows version
XMindependent programming.  A two-byte value is returned, with H = 00
XMdesignating the CP/M release (H = 01 for MP/M) and L = 00 for all
XMreleases previous to 2.0.  CP/M 2.0 returns a hexadecimal 20 in
XMregister L, with subsequent version 2 releases in the hexadecimal
XMrange 21,22, through 2F.  Using Function 12, for example, the user
XMcan write application programs that provide both sequential and
Xrandom access functions.
















                               5-16





CP/M Operating System Manual                5.2  Call Conventions






                 FUNCTION 13:  RESET DISK SYSTEM

                    Entry Parameters:
                          Register C:  0DH



     MThe Reset Disk function is used to programmatically restore the
XMfile system to a reset state where all disks are set to Read-Write.
XMSee functions 28 and 29, only disk drive A is selected, and the
XMdefault DMA address is reset to BOOT+0080H.  This function can be
XMused, for example, by an application program that requires a disk
Xchange without a system reboot.






                    FUNCTION 14:  SELECT DISK

                 Entry Parameters:
                       Register C:  0EH
                       Register E:  Selected Disk



     MThe Select Disk function designates the disk drive named in
XMregister E as the default disk for subsequent file operations, with
XME = O for drive A, 1 for drive B, and so on through 15,
XMcorresponding to drive P in a full 16 drive system.  The drive is
XMplaced in an on-line status, which activates its directory until the
XMnext cold start, warm start, or disk system reset operation.  If the
XMdisk medium is changed while it is on-line, the drive automatically
XMgoes to a Read-Only status in a standard CP/M environment, see
XMFunction 28.  FCBs that specify drive code zero (dr = 00H)
XMautomatically reference the currently selected default drive.  Drive
XMcode values between 1 and 16 ignore the selected default drive and
Xdirectly reference drives A through P.














                               5-17





CP/M Operating System Manual                5.2  Call Conventions






                     FUNCTION 15:  OPEN FILE

                Entry Parameters:
                      Register C:  0FH
                    Registers DE:  FCB Address

                Returned Value:
                     Register  A:  Directory Code



     MThe Open File operation is used to activate a file that
XMcurrently exists in the disk directory for the currently active user
XMnumber.  The FDOS scans the referenced disk directory for a match in
XMpositions 1 through 14 of the FCB referenced by DE (byte s1 is
XMautomatically zeroed) where an ASCII question mark (3FH) matches any
XMdirectory character in any of these positions.  Normally, no
XMquestion marks are included, and bytes ex and s2 of the FCB are
Xzero.

     MIf a directory element is matched, the relevant directory
XMinformation is copied into bytes d0 through dn of FCB, thus allowing
XMaccess to the files through subsequent read and write operations.
XMThe user should note that an existing file must not be accessed
XMuntil a successful open operation is completed.  Upon return, the
XMopen function returns a directory code with the value 0 through 3 if
XMthe open was successful or 0FFH (255 decimal) if the file cannot be
XMfound.  If question marks occur in the FCB, the first matching FCB
XMis activated.  Note that the current record, (cr) must be zeroed by
XMthe program if the file is to be accessed sequentially from the
Xfirst record.






















                               5-18





CP/M Operating System Manual                5.2  Call Conventions






                    FUNCTION 16:  CLOSE FILE

             Entry Parameters:
                   Register C:  10H
                 Registers DE:  FCB Address

             Returned Value:
                  Register  A:  Directory Code



     MThe Close File function performs the inverse of the Open File
XMfunction.  Given that the FCB addressed by DE has been previously
XMactivated through an open or make function,  the close function
XMpermanently records the new FCB in the reference disk directory see
XMfunctions 15 and 22.  The FCB matching process for the close is
XMidentical to the open function.  The directory code returned for a
XMsuccessful close operation is 0, 1, 2, or 3, while a 0FFH (255
XMdecimal) is returned if the filename cannot be found in the
XMdirectory.  A file need not be closed if only read operations have
XMtaken place.  If write operations have occurred, the close operation
Xis necessary to record the new directory information permanently.































                               5-19





CP/M Operating System Manual                5.2  Call Conventions






                    FUNCTION 17:  SEARCH FOR FIRST

               Entry Parameters:
                     Register C:  11H
                   Registers DE:  FCB Address

               Returned Value:
                    Register  A:  Directory Code



     MSearch First scans the directory for a match with the file
XMgiven by the FCB addressed by DE.  The value 255 (hexadecimal FF) is
XMreturned if the file is not found; otherwise, 0, 1, 2, or 3 is
XMreturned indicating the file is present.  When the file is found,
XMthe current DMA address is filled with the record containing the
XMdirectory entry, and the relative starting position is A *32 (that
XMis, rotate the A register left 5 bits, or ADD A five times).
XMAlthough not normally required for application programs, the
XMdirectory information can be extracted from the buffer at this
Xposition.

     MAn ASCII question mark (63 decimal, 3F hexadecimal) in any
XMposition from f1 through ex matches the corresponding field of any
XMdirectory entry on the default or auto-selected disk drive.  If the
XMdr field contains an ASCII question mark, the auto disk select
XMfunction is disabled and the default disk is searched, with the
XMsearch function returning any matched entry, allocated or free,
XMbelonging to any user number.  This latter function is not normally
XMused by application programs, but it allows complete flexibility to
XMscan all current directory values.  If the dr field is not a
Xquestion mark, the s2 byte is automatically zeroed.





















                               5-20





CP/M Operating System Manual                5.2  Call Conventions






                  FUNCTION 18:  SEARCH FOR NEXT

                 Entry Parameters:
                       Register C:  12H

                   Returned Value:
                      Register  A:  Directory Code



     MThe Search Next function is similar to the Search First
XMfunction, except that the directory scan continues from the last
XMmatched entry.  Similar to Function 17, Function 18 returns the
Xdecimal value 255 in A when no more directory items match.






                    FUNCTION 19:  DELETE FILE

                Entry Parameters:
                      Register C:  13H
                    Registers DE:  FCB Address

                Returned Value:
                     Register  A:  Directory Code



     MThe Delete File function removes files that match the FCB
XMaddressed by DE.  The filename and type may contain ambiguous
XMreferences (that is, question marks in various positions), but the
XMdrive select code cannot be ambiguous, as in the Search and Search
XNext functions.

     MFunction 19 returns a decimal 255 if the referenced file or
XMfiles cannot be found; otherwise, a value in the range 0 to 3
Xreturned.













                               5-21





CP/M Operating System Manual                5.2  Call Conventions






                  FUNCTION 20:  READ SEQUENTIAL

               Entry Parameters:
                     Register C:  14H
                   Registers DE:  FCB Address

               Returned Value:
                    Register  A:  Directory Code



     MGiven that the FCB addressed by DE has been activated through
XMan Open or Make function, the Read Sequential function reads the
XMnext 128-byte record from the file into memory at the current DMA
XMaddress.  The record is read from position cr of the extent, and the
XMcr field is automatically incremented to the next record position.
XMIf the cr field overflows, the next logical extent is automatically
XMopened and the cr field is reset to zero in preparation for the next
XMread operation.  The value 00H is returned in the A register if the
XMread operation was successful, while a nonzero value is returned if
XMno data exist at the next record position (for example, end-of-file
Xoccurs).






                 FUNCTION 21:  WRITE SEQUENTAIL

               Entry Parameters:
                     Register C:  15H
                   Registers DE:  FCB Address

               Returned Value:
                    Register  A:  Directory Code



     MGiven that the FCB addressed by DE has been activated through
XMan Open or Make function, the Write Sequential function writes the
XM128-byte data record at the current DMA address to the file named by
XMthe FCB.  The record is placed at position cr of the file, and the
XMcr field is automatically incremented to the next record position.
XMIf the cr field overflows, the next logical extent is automatically
XMopened and the cr field is reset to zero in preparation for the next
XMwrite operation.  Write operations can take place into an existing
XMfile, in which case, newly written records overlay those that
XMalready exist in the file.  Register A = 00H upon return from a
XMsuccessful write operation, while a nonzero value indicates an
Xunsuccessful write caused by a full disk.


                               5-22





CP/M Operating System Manual                5.2  Call Conventions






                     FUNCTION 22:  MAKE FILE

                 Entry Parameters:
                       Register C:  16H
                     Registers DE:  FCB Address

                 Returned Value:
                      Register  A:  Directory Code



     MThe Make File operation is similar to the Open File operation
XMexcept that the FCB must name a file that does not exist in the
XMcurrently referenced disk directory (that is, the one named
XMexplicitly by a nonzero dr code or the default disk if dr is zero).
XMThe FDOS creates the file and initializes both the directory and
XMmain memory value to an empty file.  The programmer must ensure that
XMno duplicate filenames occur, and a preceding delete operation is
XMsufficient if there is any possibility of duplication.  Upon return,
XMregister A = 0, 1, 2, or 3 if the operation was successful and 0FFH
XM(255 decimal) if no more directory space is available.  The Make
XMfunction has the side effect of activating the FCB and thus a
Xsubsequent open is not necessary.






                    FUNCTION 23:  RENAME FILE

                Entry Parameters:
                      Register C:  17H
                    Registers DE:  FCB Address

                Returned Value:
                     Register  A:  Directory Code



     MThe Rename function uses the FCB addressed by DE to change all
XMoccurrences of the file named in the first 16 bytes to the file
XMnamed in the second 16 bytes.  The drive code dr at postion 0 is
XMused to select the drive, while the drive code for the new filename
XMat position 16 of the FCB is assumed to be zero.  Upon return,
XMregister A is set to a value between 0 and 3 if the rename was
XMsuccessful and 0FFH (255 decimal) if the first filename could not be
Xfound in the directory scan.





                               5-23





CP/M Operating System Manual                5.2  Call Conventions






               FUNCTION 24:  RETURN LOG-IN VECTOR

               Entry Parameters:
                     Register C:  18H

               Returned Value:
                   Registers HL:  Log-in Vector



     MThe log-in vector value returned by CP/M is a 16-bit value in
XMHL, where the least significant bit of L corresponds to the first
XMdrive A and the high-order bit of H corresponds to the sixteenth
XMdrive, labeled P.  A 0 bit indicates that the drive is not on-line,
XMwhile a 1 bit marks a drive that is actively on-line as a result of
XMan explicit disk drive selection or an implicit drive select caused
XMby a file operation that specified a nonzero dr field.  The user
XMshould note that compatibility is maintained with earlier releases,
Xbecause registers A and L contain the same values upon return.






                FUNCTION 25:  RETURN CURRENT DISK

                Entry Parameters:
                      Register C:  19H

                Returned Value:
                     Register  A:  Current Disk



     MFunction 25 returns the currently selected default disk number
XMin register A.  The disk numbers range from 0 through 15
Xcorresponding to drives A through P.















                               5-24





CP/M Operating System Manual                5.2  Call Conventions






                  FUNCTION 26:  SET DMA ADDRESS

                Entry Parameters:
                      Register C:  1AH
                    Registers DE:  DMA Address



     MDMA is an acronym for Direct Memory Address, which is often
XMused in connection with disk controllers that directly access the
XMmemory of the mainframe computer to transfer data to and from the
XMdisk subsystem.  Although many computer systems use non-DMA access
XM(that is, the data is transferred through programmed I/O
XMoperations), the DMA address has, in CP/M, come to mean the address
XMat which the 128-byte data record resides before a disk write and
XMafter a disk read.  Upon cold start, warm start, or disk system
XMreset, the DMA address is automatically set to BOOT+0080H.  The Set
XMDMA function can be used to change this default value to address
XManother area of memory where the data records reside.  Thus, the DMA
XMaddress becomes the value specified by DE until it is changed by a
XMsubsequent Set DMA function, cold start, warm start, or disk system
Xreset.






                 FUNCTION 27:  GET ADDR (ALLOC)

              Entry Parameters:
                    Register C:  1BH

              Returned Value:
                  Registers HL:  ALLOC Address



     MAn allocation vector is maintained in main memory for each on-
XMline disk drive.  Various system programs use the information
XMprovided by the allocation vector to determine the amount of
XMremaining storage (see the STAT program).  Function 27 returns the
XMbase address of the allocation vector for the currently selected
XMdisk drive.  However, the allocation information might be invalid if
XMthe selected disk has been marked Read-Only.  Although this function
XMis not normally used by application programs, additional details of
Xthe allocation vector are found in Chapter 6.






                               5-25





CP/M Operating System Manual                5.2  Call Conventions






                FUNCTION 28:  WRITE PROTECT DISK

                    Entry Parameters:
                          Register C:  1CH



     MThe Write Protect Disk function provides temporary write
XMprotection for the currently selected disk.  Any attempt to write to
XMthe disk before the next cold or warm start operation produces the
Xmessage:

        BDOS ERR on d:R/O






               FUNCTION 29:  GET READ-ONLY VECTOR

             Entry Parameters:
                   Register C:  1DH

             Returned Value:
                 Registers HL:  R/O Vector Value



     MFunction 29 returns a bit vector in register pair HL, which
XMindicates drives that have the temporary Read-Only bit set.  As in
XMFunction 24, the least significant bit corresponds to drive A, while
XMthe most significant bit corresponds to drive P.  The R/O bit is set
XMeither by an explicit call to Function 28 or by the automatic
Xsoftware mechanisms within CP/M that detect changed disks.


















                               5-26





CP/M Operating System Manual                5.2  Call Conventions






                FUNCTION 30:  SET FILE ATTRIBUTES

             Entry Parameters:
                   Register C:  1EH
                 Registers DE:  FCB Address

             Returned Value:
                  Register  A:  Directory Code



     MThe Set File Attributes function allows programmatic
XMmanipulation of permanent indicators attached to files.  In
XMparticular, the R/O and System attributes (t1' and t2') can be set
XMor reset.  The DE pair addresses an unambiguous filename with the
XMappropriate attributes set or reset.  Function 30 searches for a
XMmatch and changes the matched directory entry to contain the
XMselected indicators.  Indicators f1' through f4' are not currently
XMused, but may be useful for applications programs, since they are
XMnot involved in the matching process during file open and close
XMoperations.  Indicators f5' through f8' and t3' are reserved for
Xfuture system expansion.






               FUNCTION 31:  GET ADDR (DISK PARMS)

                Entry Parameters:
                      Register C:  1FH

                Returned Value:
                    Registers HL:  DPB Address



     MThe address of the BIOS resident disk parameter block is
XMreturned in HL as a result of this function call.  This address can
XMbe used for either of two purposes.  First, the disk parameter
XMvalues can be extracted for display and space computation purposes,
XMor transient programs can dynamically change the values of current
XMdisk parameters when the disk environment changes, if required.
XNormally, application programs will not require this facility.








                               5-27





CP/M Operating System Manual                5.2  Call Conventions






                 FUNCTION 32:  SET/GET USER CODE

               Entry Parameters:
                     Register C:  20H
                     Register E:  OFFH (get) or
                                  User Code (set)

               Returned Value:
                    Register  A:  Current Code or
                                  (no value)



     MAn application program can change or interrogate the currently
XMactive user number by calling Function 32.  If register E = 0FFH,
XMthe value of the current user number is returned in register A,
XMwhere the value is in the range of 0 to 15.  If register E is not
XM0FFH, the current user number is changed to the value of E, modulo
X16.


































                               5-28





CP/M Operating System Manual                5.2  Call Conventions






                    FUNCTION 33:  READ RANDOM

                 Entry Parameters:
                       Register C:  21H

                 Returned Value:
                      Register  A:  Return Code



     MThe Read Random function is similar to the sequential file read
XMoperation of previous releases, except that the read operation takes
XMplace at a particular record number, selected by the 24-bit value
XMconstructed from the 3-byte field following the FCB (byte positions
XMr0 at 33, r1 at 34, and r2 at 35).  The user should note that the
XMsequence of 24 bits is stored with least significant byte first
XM(r0), middle byte next (r1), and high byte last (r2).  CP/M does not
XMreference byte r2, except in computing the size of a file (Function
XM35).  Byte r2 must be zero, however, since a nonzero value indicates
Xoverflow past the end of file.

     MThus, the r0, r1 byte pair is treated as a double-byte, or word
XMvalue, that contains the record to read.  This value ranges from 0
XMto 65535, providing access to any particular record of the 8-
XMmegabyte file.  To process a file using random access, the base
XMextent (extent 0) must first be opened.  Although the base extent
XMmight or might not contain any allocated data, this ensures that the
XMfile is properly recorded in the directory and is visible in DIR
XMrequests.  The selected record number is then stored in the random
Xrecord field (r0, r1), and the BDOS is called to read the record.

     MUpon return from the call, register A either contains an error
XMcode, as listed below, or the value 00, indicating the operation was
XMsuccessful.  In the latter case, the current DMA address contains
XMthe randomly accessed record.  Note that contrary to the sequential
XMread operation, the record number is not advanced.  Thus, subsequent
Xrandom read operations continue to read the same record.

     MUpon each random read operation, the logical extent and current
XMrecord values are automatically set.  Thus, the file can be
XMsequentially read or written, starting from the current randomly
XMaccessed position.  However, note that, in this case, the last
XMrandomly read record will be reread as one switches from random mode
XMto sequential read and the last record will be rewritten as one
XMswitches to a sequential write operation.  The user can simply
XMadvance the random record position following each random read or
Xwrite to obtain the effect of sequential I/O operation.






                               5-29





CP/M Operating System Manual                5.2  Call Conventions



     MError codes returned in register A following a random read are
Xlisted below.


        01   reading unwritten data

        02   (not returned in random mode)

        03   cannot close current extent

        04   seek to unwritten extent

        05   (not returned in read mode)

        06   seek past physical end of disk


     MError codes 01 and 04 occur when a random read operation
XMaccesses a data block that has not been previously written or an
XMextent that has not been created, which are equivalent conditions.
XMError code 03 does not normally occur under proper system operation.
XMIf it does, it can be cleared by simply rereading or reopening
XMextent zero as long as the disk is not physically write protected.
XMError code 06 occurs whenever byte r2 is nonzero under the current
XM2.0 release.  Normally, nonzero return codes can be treated as
XMmissing data, with zero return codes indicating operation complete.
X





























                               5-30





CP/M Operating System Manual                5.2  Call Conventions






                   FUNCTION 34:  WRITE RANDOM

                Entry Parameters:
                      Register C:  22H
                    Registers DE:  FCB Address

                Returned Value:
                     Register  A:  Return Code



     MThe Write Random operation is initiated similarly to the Read
XMRandom call, except that data is written to the disk from the
XMcurrent DMA address.  Further, if the disk extent or data block that
XMis the target of the write has not yet been allocated, the
XMallocation is performed before the write operation continues.  As in
XMthe Read Random operation, the random record number is not changed
XMas a result of the write.  The logical extent number and current
XMrecord positions of the FCB are set to correspond to the random
XMrecord that is being written.  Again, sequential read or write
XMoperations can begin following a random write, with the notation
XMthat the currently addressed record is either read or rewritten
XMagain as the sequential operation begins.  You can also simply
XMadvance the random record position following each write to get the
XMeffect of a sequential write operation.  Note that reading or
XMwriting the last record of an extent in random mode does not cause
Xan automatic extent switch as it does in sequential mode.

     MThe error codes returned by a random write are identical to the
XMrandom read operation with the addition of error code 05, which
XMindicates that a new extent cannot be created as a result of
Xdirectory overflow.





















                               5-31





CP/M Operating System Manual                5.2  Call Conventions






                 FUNCTION 35:  COMPUTE FILE SIZE

                  Entry Parameters:
                        Register C:  23H
                      Registers DE:  FCB Address

                  Returned Value:
                      Random Record Field Set



     MWhen computing the size of a file, the DE register pair
XMaddresses an FCB in random mode format (bytes r0, r1, and r2 are
XMpresent).  The FCB contains an unambiguous filename that is used in
XMthe directory scan.  Upon return, the random record bytes contain
XMthe virtual file size, which is, in effect, the record address of
XMthe record following the end of the file.  Following a call to
XMFunction 35, if the high record byte r2 is 01, the file contains the
XMmaximum record count 65536.  Otherwise, bytes r0 and r1 constitute a
XM16-bit value as before (r0 is the least significant byte), which is
Xthe file size.

     MData can be appended to the end of an existing file by simply
XMcalling Function 35 to set the random record position to the end of
XMfile and then performing a sequence of random writes starting at the
Xpreset record address.

     MThe virtual size of a file corresponds to the physical size
XMwhen the file is written sequentially.  If the file was created in
XMrandom mode and holes exist in the allocation, the file might
XMcontain fewer records than the size indicates.  For example, if only
XMthe last record of an 8-megabyte file is written in random mode
XM(that is, record number 65535), the virtual size is 65536 records,
Xalthough only one block of data is actually allocated.



















                               5-32





CP/M Operating System Manual                5.2  Call Conventions






                 FUNCTION 36:  SET RANDOM RECORD

                 Entry Parameters:
                       Register C:  24H
                     Registers DE:  FCB Address

                 Returned Value:
                        Random Record Field Set



     MThe Set Random Record function causes the BDOS automatically to
XMproduce the random record position from a file that has been read or
XMwritten sequentially to a particular point.  The function can be
Xuseful in two ways.

     MFirst, it is often necessary initially to read and scan a
XMsequential file to extract the positions of various key fields.  As
XMeach key is encountered, Function 36 is called to compute the random
XMrecord position for the data corresponding to this key.  If the data
XMunit size is 128 bytes, the resulting record position is placed into
XMa table with the key for later retrieval.  After scanning the entire
XMfile and tabulating the keys and their record numbers, the user can
XMmove instantly to a particular keyed record by performing a random
XMread, using the corresponding random record number that was saved
XMearlier.  The scheme is easily generalized for variable record
XMlengths, because the program need only store the buffer-relative
XMbyte position along with the key and record number to find the exact
Xstarting position of the keyed data at a later time.

     MA second use of Function 36 occurs when switching from a
XMsequential read or write over to random read or write.  A file is
XMsequentially accessed to a particular point in the file, Function 36
XMis called, which sets the record number, and subsequent random read
Xand write operations continue from the selected point in the file.


















                               5-33





CP/M Operating System Manual                5.2  Call Conventions






                    FUNCTION 37:  RESET DRIVE

                 Entry Parameters:
                       Register C:  25H
                     Registers DE:  Drive Vector

                 Returned Value:
                      Register  A:  00H



     MThe Reset Drive function allows resetting of specified drives.
XMThe passed parameter is a 16-bit vector of drives to be reset; the
Xleast significant bit is drive A:.

     MTo maintain compatibility with MP/M, CP/M returns a zero value.
X





            FUNCTION 40:  WRITE RANDOM WITH ZERO FILL

                 Entry Parameters:
                       Register C:  28H
                     Registers DE:  FCB Address

                 Returned Value:
                      Register  A:  Return Code



     MThe Write With Zero Fill operation is similar to Function 34,
XMwith the exception that a previously unallocated block is filled
Xwith zeros before the data is written.

















                               5-34





CP/M Operating System Manual           5.3  A Sample Copy Program


W5.3  A Sample File-to-File Copy Program

     MT&She following program provides a relatively simple example of
XMfile operations.  The program source file is created as COPY.ASM
XMusing the CP/M ED program and then assembled using ASM or MAC,
XMresulting in a HEX file.  The LOAD program is used to produce a
XMCOPY.COM file that executes directly under the CCP.  The program
XMbegins by setting the stack pointer to a local area and proceeds to
XMmove the second name from the default area at 006CH to a 33-byte
XMFile Control Block called DFCB.  The DFCB is then prepared for file
XMoperations by clearing the current record  field.  At this point,
XMthe source and destination FCBs are ready for processing, because
XMthe SFCB at 005CH is properly set up by the CCP upon entry to the
XMCOPY program.  That is, the first name is placed into the default
XMFCB, with the proper fields zeroed, including the current record
XMfield at 007CH.  The program continues by opening the source file,
XMdeleting any existing destination file, and creating the destination
XMfile.  If all this is successful, the program loops at the label
XMCOPY until each record is read from the source file and placed into
XMthe destination file.  Upon completion of the data transfer, the
XMdestination file is closed and the program returns to the CCP
Xcommand level by jumping to BOOT.
	9	U0


                            ;        sample file-to-file copy program
                            ;
                            ;        at the ccp level, the command
                            ;
                            ;             copy a:x.y b:u.v
                            ;
                            ;        copies the file named x.y from drive
                            ;        a to a file named u.v. on drive b.
                            ;
0000 =                      boot     equ 0000h      ;system reboot
0005 =                      bdos     equ 0005h      ;bdos entry point
005c =                      fcbl     equ 005ch      ;first file name
005c =                      sfcb     equ fcbl       ;source fcb
006c =                      fcb2     equ 006ch      ;second file name
0080 =                      dbuff    equ 0080h      ;default buffer
0100 =                      tpa      equ 0100h      ;beginning of tpa
                            ;
0009 =                      printf   equ 9          ;print buffer func#
000f =                      openf    equ 15         ;open file func#
0010 =                      closef   equ 16         ;close file func#
0013 =                      deletef  equ 19         ;delete file func#
0014 =                      readf    equ 20         ;sequential read
0015 =                      writef   equ 21         ;sequential write
0016 =                      makef    equ 22         ;make file func#
                            ;
0100                                 org tpa        ;beginning of tpa
0100 311b02                          lxi sp,stack   ;local stack
                            ;
                            ;        move second file name to dfcb
0103 0e10                            mvi c,16       ;half an fcb


                               5-35





CP/M Operating System Manual           5.3  A Sample Copy Program


0105 116c00                          lxi d,fcb2     ;source of move
0108 21da01                          lxi h,dfcb     ;destination fcb
010b 1a                     mfcb:    Idax d         ;source fcb
010c 13                              inx  d         ;ready next
010d 77                              mov  m,a       ;dest fcb
010e 23                              inx  h         ;ready next
010f 0d                              dcr  c         ;count 16...0
0110 c10b01                          jnz  mfcb      ;loop 16 times
                            ;
                            ;        name has been removed, zero cr
0113 af                              xra  a         ;a = 00h
0114 32fa01                          sta  dfcbcr    ;current rec = 0
                            ;
                            ;        source and destination fcb's ready
                            ;
0117 115c00                          lxi  d,sfcb    ;source file
011a cd6901                          call open      ;error if 255
011d 118701                          lxi  d,nofile  ;ready message
0120 3c                              inr  a         ;255 becomes 0
0121 cc6101                          cz   finis     ;done if no file
                            ;
                            ;        source file open, prep destination
0124 11da01                          lxi  d,dfcb    ;destination
0127 cd7301                          call delete    ;remove if present
                            ;
012a 11da01                          lxi  d,dfcb    ;destination
012d cd8201                          call make      ;create the file
0130 119601                          lxi  d,nodir   ;ready message
0133 3c                              inr  a         ;255 becomes 0
0134 cc6101                          cz   finis     ;done if no dir space
                            ;
                            ;        source file open, dest file open
                            ;        copy until end of file on source
                            ;
0137 115c00                 copy:    lxi  d,sfcb    ;source
013a cd7801                          call read      ;read next record
013d b7                              ora  a         ;end of file?
013e c25101                          jnz  eofile    ;skip write if so
                            ;
                            ;        not end of file, write the record
0141 11da01                          lix  d,dfcb    ;destination
0144 cd7d01                          call write     ;write record
0147 11a901                          lxi  d,space   ;ready message
014a b7                              ora  a         ;00 if write ok
014b c46101                          cnz  finis     ;end if so
014e c33701                          jmp  copy      ;loop until eof
                            ;
                            eofile:  ;end of file, close destination
0151 11da01                          lxi  d,dfcb    ;destination
0154 cd6e01                          call close     ;255 if error
0157 21bb01                          lxi  h,wrprot  ;ready message
015a 3c                              inr  a         ;255 becomes 00
015b cc6101                          cz   finis     ;shouldn't happen
                            ;
                            ;        copy operation complete, end


                               5-36





CP/M Operating System Manual           5.3  A Sample Copy Program


015e 11cc01                          lxi  d,normal  ;ready message
                            ;
                            finis    ;write message given by de, reboot
0161 0e09                            mvi  c,printf
0163 cd0500                          call bdos      ;write message
0166 c30000                          jmp  boot      ;reboot system
                            ;
                            ;        system interface subroutines
                            ;        (all return directly from bdos)
                            ;
0169 0e0f                   open:    mvi  c,openf
016b c30500                          jmp  bdos
                            ;
016e 0e10                   close:   mvi  c,closef
0170 c30500                          jmp  bdos
                            ;
0173 0e13                   delete   mvi  c,deletef
0175 c30500                          jmp  bdos
                            ;
0178 0e14                   read:    mvi  c,readf
017a c30500                          jmp  bdos
                            ;
017d 0e15                   write:   mvi  c,writef
017f c30500                          jmp  bdos
                            ;
0182 0e16                   make:    mvi  c,makef
0184 c30500                          jmp  bdos
                            ;
                            ;        console messages
0187 6e6f20f                nofile:  db   'no source file$'
0196 6e6f209                nodir:   db   'no directory space$'
01a9 6f7574f                space:   db   'out of dat space$'
01bb 7772695                wrprot:  db   'write protected?$'
01cc 636f700                normal:  db   'copy complete$'
                            ;
                            ;        data areas
01da                        dfcb:    ds   33        ;destination fcb
01fa                        dfcbcr   equ  dfcb+32   ;current record
                            ;
01fb                                 ds   32        ;16 level stack
                            stack:
021b                                 end
	9	K0


     MNote that there are several simplifications in this particular
XMprogram.  First, there are no checks for invalid filenames that
XMcould contain ambiguous references.  This situation could be
XMdetected by scanning the 32-byte default area starting at location
XM005CH for ASCII question marks.  A check should also be make to
XMensure that the filenames have been included (check locations 005DH
XMand 006DH for nonblank ASCII characters).  Finally, a check should
XMbe made to ensure that the source and destination filenames are
XMdifferent.  An improvement in speed could be obtained by buffering
XMmore data on each read operation.  One could, for example, determine


                               5-M37



X

CP/M Operating System Manual           5.3  A Sample Copy Program


Mthe size of memory by fetching FBASE from location 0006H and using
XMthe entire remaining portion of memory for a data buffer.  In this
XMcase, the programmer simply resets the DMA address to the next
XMsuccessive 128-byte area before each read.  Upon writing to the
XMdestination file, the DMA address is reset to the beginning of the
XMbuffer and incremented by 128 bytes to the end as each record is
Xtransferred to the destination file.


W5.4  A Sample File Dump Utility

     MT&She following file dump program is slightly more complex than
XMthe simple copy program given in the previous section.  The dump
XMprogram reads an input file, specified in the CCP command line, and
XMdisplays the content of each record in hexadecimal format at the
XMconsole.  Note that the dump program saves the CCP's stack upon
XMentry, resets the stack to a local area, and restores the CCP's
XMstack before returning directly to the CCP.  Thus, the dump program
Xdoes not perform and warm start at the end of processing.
	9	U0


x.in 5
                            ;DUMP program reads input file and displays
                            hex data
                            ;
0100                                 org  100h
0005 =                      bdos     equ  0005h =   ;bdos entry point
0001 =                      cons     equ  1         ;read console
0002 =                      typef    equ  2         ;type function
0009 =                      printf   equ  9         ;buffer print entry
000b =                      brkf     equ  11        ;break key function
                                                    ;(true if char
000f =                      openf    equ  15        ;file open
0014 =                      readf    equ  20        ;read function
                            ;
005c =                      fcb      equ  5ch       ;file control block
                                                    ;address
0080 =                      buff     equ  80h       ;input disk buffer
                                                    ;address
                            ;
                            ;        non graphic characters
000d =                      cr       equ  0dh       ;carriage return
000a =                      If       equ  0ah       ;line feed
                            ;
                            ;        file control block definitions
005c =                      fcbdn    equ  fcb+0     ;disk name
005d =                      fcbfn    equ  fcb+1     ;file name
0065 =                      fcbft    equ  fcb+9     ;disk file type (3
                                                    ;characters)
0068 =                      fcbrl    equ  fcb+12    ;file's current reel
                                                    ;number
006b =                      fcbrc    equ  fcb+15    ;file's record count (0 to
                                                    ;128)128)
007c =                      fcbcr'   equ  fcb+32    ;current (next) record


                               5-38





CP/M Operating System Manual      5.4  A Sample File Dump Utility


                                                    ;number (0
007d =                      fcbin    equ  fcb+33    ;fcb length
                            ;
                            ;        set up stack
0100 210000                          lxi  h,0
0103 39                              dad  sp
                            ;        entry stack pointer in hl from the ccp
0104 221502                          shld oldsp
                            ;        set sp to local stack area (restored at
                            ;        finis)
0107 315702                          lxi  sp,stktop
                            ;        read and print successive buffers
010a cdc101                          call setup     ;set up input file
010d feff                            cpi  255       ;255 if file not present
010f c21b01                          jnz  openok    ;skip if open is ok
                            ;
                            ;        file not there, give error message and
                            ;        return
0112 11f301                          lxi  d,opnmsg
0115 cd9c01                          call err
0118 c35101                          jmp finis      ;to return
                            ;
                            openok:  ;open operation ok, set buffer index to
                                     ;end
011b 3e80                            mvi  a,80h
011d 321302                          sta  ibp       ;set buffer pointer to 80h
                            ;        hl contains next address to print
0120 210000                          lxi  h,0       ;start with 0000
                            ;
                            gloop:
0123 e5                              push h         ;save line position
0124 cda201                          call gnb
0127 e1                              pop  h         ;recall line position
0138 da5101                          jc   finis     ;carry set by gnb if end
                                                    ;file
012b 47                              mov  b,a
                            ;        print hex values
                            ;        check for line fold
012c 7d
                                     mov  a,l
012d e60f                            ani  0fh       ;check low 4 bits
012f c24401                          jnz nonum
                            ;        print line number
0132 cd7201                          call crlf
                            ;
                            ;        check for break key
0135 cd5901                          call break
                            ;        accum lsb = 1 if character ready
0138 0f                              rrc            ;into carry
0139 da5101                          jc   finis     ;don't print any more
                            ;
013c 7c                              mov  a,h
013d cd8f01                          call phex
0140 7d                              mov  a,l
0141 cd8f01                          call phex


                               5-39





CP/M Operating System Manual      5.4  A Sample File Dump Utility


                            nonum
0144 23                              inx  h         ;to next line number
0145 3e20                            mvi  a,''
0147 cd6501                          call pchar
014a 78                              mov  a,b
014b cd8f01                          call phex
014e c32301                          jmp  gloop
                            ;
                            finis
                            ;        end of dump, return to cco
                            ;        (note that a jmp to 0000h reboots)
0151 cd7201                          call crif
0154 2a1502                          lhld oldsp
0157 f9                              sphl
                            ;        stack pointer contains ccp's stack
                            ;        location
0158 c9                              ret            ;to the ccp
                            ;
                            ;
                            ;        subroutines
                            ;
                            break:   ;check break key (actually any key will
                                     ;do)
0159 e5d5c5                          push h! push d! push b; environment
                                     ;saved
015c 0e0b                            mvi  c,brkf
015e cd0500                          call bdos
0161 c1d1e1                          pop b! pop d! pop h; environment
                                     restored
0164 c9                              ret
                            ;
                            pchar:   ;print a character
0165 e5d5c5                          push h! push d! push b; saved
0168 0e02                            mvi  c, typef
016a 5f                              mov  e,a
016b cd0500                          call bdos
016e c1d1e1                          pop b! pop d! pop h; restored
0171 c9                              ret
                            ;
                            crlf
0172 3e0d                            mvi  a,cr
0174 cd6501                          call pchar
0177 3e0a                            mvi  a,lf
0179 cd6501                          call pchar
017c c9                              ret
                            ;
                            ;
                            pnib:    ;print nibble in reg a
017d e60f                            ani  ofh       ;low 4 bits
017f fe0a                            cpi  10
0181 d28901                          jnc  p10
                            ;        less than or equal to 9
0184 c630                            adi  '0'
0186 c38b01                          jmp  prn
                            ;


                               5-40





CP/M Operating System Manual      5.4  A Sample File Dump Utility


                            ;        greater or equal to 10
0189 c637                   p10:     adi  'a' - 10
018b cd6501                 prn:     call pchar
018e c9                              ret
                            ;
                            phex     ;print hex char in reg a
018f f5                              pushpsw
0190 0f                              rrc
0191 0f                              rrc
0192 0f                              rrc
0193 0f                              rrc
0194 cd7d01                          call pnib      ;print nibble
0197 f1                              pop  psw
0198 cd7d01                          call pnip
019b c9                              ret
                            ;
                            err:     ;print error message
                            ;        d,e addresses message ending with "$"
019c 0e09                            mvi  c,printf  ;print buffer
                                                    ;function
019e cd0500                          call bdos
01a1 c9                              ret
                            ;
                            ;
                            gnb:     ;get next byte
01a2 3a1302                          lda  ibp
01a5 fe80                            cpi  80h
01a7 c2b301                          jnz  g0
                            ;        read another buffer
                            ;
                            ;
 01aa cdce01                         call diskr
01ad b7                              ora  a         ;zero value if read ok
01ae cab301                          jz   g0        ;for another byte
                            ;        end of data, return with carry set for eof
01b1 37                              stc
01b2 c9                              ret
                            ;
                            g0:      ;read the byte at buff+reg a
01b3 5f                              mov  e,a       ;Is byte of buffer index
01b4 1600                            mvi  d,0       ;double precision
                                                    ;index to de
01b6 3c                              inr  a         ;index=index+1
01b7 321302                          sta  ibp       ;back to memory
                            ;        pointer is incremented
                            ;        save the current file address
01ba 218000                          lxi  h,buff
01bd 19                              dad  d
                            ;        absolute character address is in hl
01be 7e                              mov  a,m
                            ;        byte is in the accumulator
01bf b7                              ora  a         ;reset carry bit
01c0 c9                              ret
                            ;
                            setup:   ;set up file


                               5-41





CP/M Operating System Manual      5.4  A Sample File Dump Utility


                            ;        open the file for input
01c1 af                              xra  a         ;zero to accum
01c2 327c00                          sta  fcbcr     ;clear current record
                            ;
01c5 115c00                          lxi  d,fcb
01c8 0e0f                            mvi  c,openf
01ca cd0500                          call bdos
                            ;        255 in accum if open error
01cd c9                              ret
                            ;
                            diskr:   ;read disk file record
01ce e5d5c5                          push h! push d! push b
01d1 115c00                          lxi  d,fcb
01d4 0e14                            mvi  c,readf
01d6 cd0500                          call bdos
01d9 c1d1e1                          pop b! pop d! pop h
01dc c9                              ret
                            ;
                            ;        fixed message area
01dd 46494c0                signon:  db   'file dump version 2.0$'
01f3 0d0a4e0                opnmsg:  db   cr,lf,'no  input file present on
                                          disk$'

                            ;        variable area
0213                        ibp:     ds   2         ;input buffer pointer
0215                        oldsp:   ds   2         ;entry sp value from ccp
                            ;
                            ;        stack area
0217                        ;        ds   64        ;reserve 32 level stack
                            stktop:
                            ;
0257                                 end
	9	K0


W5.5  A Sample Random Access Program

     MT&Shis chapter concludes with an extensive example of random
XMaccess operation.  The program listed below performs the simple
XMfunction of reading or writing random records upon command from the
XMterminal.  When a program has been created, assembled, and placed
Xinto a file labeled RANDOM.COM, the CCP level command

        RANDOM X.DAT

Mstarts the test program.  The program looks for a file by the name
XMX.DAT and, if found, proceeds to prompt the console for input.  If
XMnot found, the file is created before the prompt is given.  Each
Xprompt takes the form

        next command?

Mand is followed by operator input, followed by a carriage return.
XThe input commands take the form



                               5-42





CP/M Operating System Manual   5.5   Sample Random Access Program


        nW  nR  Q

Mwhere n is an integer value in the range 0 to 65535, and W, R, and Q
XMare simple command characters corresponding to random write, random
XMread, and quit processing, respectively.  If the W command is
Xissued, the RANDOM program issues the prompt

        type data:

MThe operator then responds by typing up to 127 characters, followed
XMby a carriage return.  RANDOM then writes the character string into
XMthe X.DAT file at record n.  If the R command is issued, RANDOM
XMreads record number n and displays the string value at the console,
XMIf the Q command is issued, the X.DAT file is closed, and the
XMprogram returns to the CCP.  In the interest of brevity, the only
Xerror message is

        error, try again.

     MThe program begins with an initialization section where the
XMinput file is opened or created, followed by a continuous loop at
XMthe label ready where the individual commands are interpreted.  The
XMDFBC at 005CH and the default buffer at 0080H are used in all disk
XMoperations.  The utility subroutines then follow, which contain the
XMprincipal input line processor, called readc.  This particular
XMprogram shows the elements of random access processing, and can be
Xused as the basis for further program development.
	9	U0


W                            Sample Random Access Program for CP/M 2.0

&S0100                              org    100h      ;base of tpa
                         ;
0000 =                   reboot   equ    0000h     ;system reboot
0005 =                   bdos     equ    0005h     ;bdos entry point
                         ;
0001 =                   coninp   equ    1         ;console input function
0002 =                   conout   equ    2         ;console output function
0009 =                   pstring  equ    9         ;print string until '$'
000a =                   rstring  equ    10        ;read console buffer
000c =                   version  equ    12        ;return version number
000f =                   openf    equ    15        ;file open function
0010 =                   closef   equ    16        ;close function
0016 =                   makef    equ    22        ;make file function
0021 =                   readr    equ    33        ;read random
0022 =                   writer   equ    34        ;write random
                         ;
005c =                   fcb      equ    005ch     ;default file control
                                                   ;block
007d =                   ranrec   equ    fcb+33    ;random record position
007f =                   ranovf   equ    fcb+35    ;high order (overflow)
                                                   ;byte
0080 =                   buff     equ    0080h     ;buffer address
                         ;


                               5-43





CP/M Operating System Manual   5.5   Sample Random Access Program


000d =                   cr       equ    0dh       ;carriage return
000a =                   lf       equ    0ah       ;line feed
                         ;


W                          Load SP, Set-Up File for Random Access

&S0100 31bc00                       lxi    sp,stack
                         ;
                         ;        version 2.0
0103 0e0c                         mvi    c,version
0105 cd0500                       call   bdos
0108 fe20                         cpi    20h       ;version 2.0 or better?
010a d21600                       jnc    versok
                         ;        bad version, message and go back
010d 111b00                       lxi    d,badver
0110 cdda00                       call   print
0113 c30000                       jmp    reboot
                         ;
                         versok:
                         ;        correct versionm for random access
0116 0e0f                         mvi    c,openf   ;open default fcb
0118 115c00                       lxi    d,fcb
011b cd 0500                      call   bdos
011e 3c                           inr    a         ;err 255 becomes zero
011f c23700                       jnz    ready
                         ;
                         ;        connot open file, so create it
0122 0e16                         mvi    c,makef
0124 115c00                       lxi    d,fcb
0127 cd0500                       call   bdos
012a 3c                           inr    a         ;err 255 becomes zero
012b c23700                       jnz    ready
                         ;
                         ;        cannot create file, directory full
012e 113a00                       lxi    d,nospace
0131 cdda00                       call   print
0134 c30000                       jmp    reboot    ;back to ccp


W                          Loop Back to Ready After Each Command

&S                         ;
                         ready:
                         ;        file is ready for processing
                         ;
0137 cde500                       call   readcom   ;read next command
013a 227d00                       shld   ranrec    ;store input record#
013d 217f00                       lxi    h,ranovf
0140 3600                         mvi    m,0       ;clear high byte if set
0142 fe51                         cpi    'Q'       ;quit?
0144 c25600                       jnz    notq
                         ;
                         ;        quit processing, close file
0147 0e10                         mvi    c,closef


                               5-44





CP/M Operating System Manual   5.5   Sample Random Access Program


0149 115c00                       lxi    d,fcb
014c cd0500                       call   bdos
014f 3c                           inr    a         ;err 255 becomes 0
0150 cab900                       jz     error     ;error message, retry
0153 c30000                       jmp    reboot    ;back to ccp
                         ;


W                          End of Quit Command, Process Write

&S                         notq:
                         ;        not the quit command, random write?
0156 fe57                         cpi    'W'
0158 c28900                       jnz    notw
                         ;
                         ;        this is a random write, fill buffer untill cr
015b 114d00                       lxi    d,datmsg
015e cdda00                       call   print     ;data prompt
0161 0e7f                         mvi    c,127     ;up to 127 characters
0163 218000                       lxi    h,buff    ;destination
                         rloop:   ;read next character to buff
0166 c5                           push   b         ;save counter
0167 e5                           push   h         ;next destination
0168 cdc200                       call   getchr    ;character to a
016b e1                           pop    h         ;restore counter
016c c1                           pop    b         ;restore next to fill
016d fe0d                         cpi    cr        ;end of line?
016f ca7800                       jz     erloop
                         ;        not end, store character
0172 77                           mov    m,a
0173 23                           inx    h         ;next to fill
0174 0d                           dcr    c         ;counter goes down
0175 c26600                       jnz    rloop     ;end of buffer?
                         erloop:
                         ;        end of read loop, store 00
0178 3600                         mvi    m,0
                         ;
                         ;        write the record to selected record number
017a 0e22                         mvi    c,writer
017c 115c00                       lxi    d,fcb
017c cd0500                       call   bdos
0182 b7                           ora    a         ;erro code zero?
0183 c2b900                       jnz    error     ;message if not
0186 c33700                       jmp    ready     ;for another record
                         ;


W                          End of Write Command, Process Read

&S                         notw:
                         ;        not a write command, read record?
0189 fe52                         cpi    'R'
018b c2b900                       jnz    error     ;skip if not
                         ;
                         ;        read random record


                               5-45





CP/M Operating System Manual   5.5   Sample Random Access Program


018e 0e21                         mvi    c,readr
0190 115c00                       lxi    d,fcb
0193 cd0500                       call   bdos
0196 b7                           ora    a         ;return code 00?
0197 c2b900                       jnz    error
                         ;
                         ;        read was successful, write to console
019a cdcf00                       call   crlf      ;new line
019d 0e80                         mvi    c,128     ;max 128 characters
019f 218000                       lxi    h,buff    ;next to get
                         wloop:
01a2 7e                           mov    a,m       ;next character
01a3 23                           inx    h         ;next to get
01a4 e67f                         ani    7fh       ;mask parity
01a6 ca3700                       jz     ready     ;for another command
                                                   ;if 00
01a9 c5                           push   b         ;save counter
01aa e5                           push   h         ;save next to get
01ab fe20                         cpi    ''        ;graphic?
01ad d4c800                       cnc    putchr    ;skip output if not
01b0 e1                           pop    h
01b1 c1                           pop    b
01b2 0d                           dcr    c         ;count=count-1
01b3 c2a200                       jnz    wloop
01b6 c33700                       jmp    ready
































                               5-46





CP/M Operating System Manual   5.5   Sample Random Access Program


W                          End of Read Command, All Errors End Up Here

&S                         ;
                         error:
01b9 115900                       lxi    d,errmsg
01bc cdda00                       call   print
01bf c33700                       jmp    ready
                         ;


W                          Utility Subroutines for Console I/O

&S                         getchr:
                                  ;read next console character to a
01c2 0e01                         mvi    c,coninp
01c4 cd0500                       call   bdos
01c7 c9                           ret
                         ;
                         putchr:
                                  ;write character from a to console
01c8 0e02                         mvi    c,conout
01ca 5f                           mov    e,a       ;character to send
01cb cd0500                       call   bdos      ;send character
01ce c9                           ret
                         ;
                         crlf:
                                  ;send carriage return line feed
01cf 3e0d                         mvi    a,cr      ;carriage return
01d1 cdc800                       call   putchr
01d4 3e0a                         mvi    a,lf      ;line feed
01d6 cdc800                       call   putchr
01d9 c9                           ret
                         ;
                         print:
                                  ;print the buffer addressed by de untill $
01da d5                           push   d
01db cdcf00                       call   crlf
01de d1                           pop    d         ;new line
01df 0e09                         mvi    c,pstring
01e0 cd0500                       call   bdos      ;print the string
01e4 c9                           ret
                         ;
                         readcom:
                                  ;read the next command line to the conbuf
01e5 116b00                       lxi    d,prompt
01e8 cdda00                       call   print     ;command?
01eb 0e0a                         mvi    c,rstring
01ed 117a00                       lxi    d,conbuf
01f0 cd0500                       call   bdos      ;read command line
                         ;        command line is present, scan it
01f3 210000                       lxi    h,0       ;start with 0000
01f6 117c00                       lxi    d,conlin  ;command line
01f9 1a                  readc:   ldax   d         ;next command
                                                   ;character
01fa 13                           inx    d         ;to next command


                               5-47





CP/M Operating System Manual   5.5   Sample Random Access Program


                                                   ;position
01fb b7                           ora    a         ;cannot be end of
                                                   ;command
01fc c8                           rz
                         ;        not zero, numeric?
01fd d630                         sui    '0'
01ff fe0a                         cpi    10        ;carry if numeric
0201 d21300                       jnc    endrd
                         ;        add-in next digit
0204 29                           dad    h         ;*2
0205 4d                           mov    c,l
0206 44                           mov    b,h       ;bc = value * 2
0207 29                           dad    h         ;*4
0208 29                           dad    h         ;*8
0209 09                           dad    b         ;*2 + *8 = *10
020a 85                           add    l         ;*digit
020b 6f                           mov    l,a
020c d2f900                       jnc    readc     ;for another char
020f24                            inr    h         ;overflow
0210 c3f900                       jmp    readc     ;for another char
                         endrd:
                         ;        end of read, restore value in a
0213 c630                         adi    '0'       ;command
0215 fe61                         cpi    'a'       ;translate case?
0217 d8                           rc
                         ;        lower case, mask lower case bits
0218 e65f                         ani    101$1111b
021a c9                           ret
                         ;


W                          String Data Area for Console Messages

&S                         badver:
021b 536f79                       db     'sorry, you need cp/m version 2$'
                         nospace:
023a 4e6f29                       db     'no directory space$'
                         datmsg:
024d 547970                       db     'type data: $'
                         errmsg:
0259 457272                       db     'error, try again.$'
                         prompt:
026b 4e6570                       db     'next command? $'
                         ;


W                          Fixed and Variable Data Area

&S027a 21                  conbuf:  db     conlen     ;length of console buffer
027b                     consiz:  ds     1          ;resulting size after read
027c                     conlin:  ds     32         ;length 32 buffer
0021 =                   conlen   equ    $-consiz
                         ;
029c                              ds     32         ;16 level stack
                         stack:
02bc                              end

                               5-48



	9	K0

CP/M Operating System Manual   5.5   Sample Random Access Program



     MMajor improvements could be made to this particular program to
XMenhance its operation.  In fact, with some work, this program could
XMevolve into a simple data base management system.  One could, for
XMexample, assume a standard record size of 128 bytes, consisting to
XMarbitrary fields within the record.  A program, called GETKEY, could
XMbe developed that first reads a sequential file and extracts a
Xspecific field defined by the operator.  For example, the command

        GETKEY NAMES.DAT LASTNAME 10 20

Mwould cause GETKEY to read the data base file NAMES.DAT and extract
XMthe LAST-NAME field from each record, starting in position 10 and
XMending at character 20.  GETKEY builds a table in memory consisting
XMof each particular LASTNAME field, along with its 16-bit record
XMnumber location within the file.  The GETKEY program then sorts this
XMlist and writes a new file, called LASTNAME.KEY, which is an
XMalphabetical list of LASTNAME fields with their corresponding record
XMnumbers.  This list is called an inverted index in information
Xretrieval parlance.

     MIf the programmer were to rename the program shown above as
XMQUERY and modify it so that it reads a sorted key file into memory,
Xthe command line might appear as

        QUERY NAMES.DAT LASTNAME.KEY

MInstead of reading a number, the QUERY program reads an alphanumeric
XMstring that is a particular key to find in the NAMES.DAT data base.
XMBecause the LASTNAME.KEY list is sorted, one can find a particular
XMentry rapidly by performing a binary search, similar to looking up a
XMname in the telephone book.  Starting at both ends of the list, one
XMexamines the entry halfway in between and, if not matched, splits
XMeither the upper half or the lower half for the next search.  You
XMwill quickly reach the item you are looking for and find the
XMcorresponding record number.  You should fetch and display this
XMrecord at the console, just as was done in the program shown above.
X
     MWith some more work, you can allow a fixed grouping size that
XMdiffers from the 128-byte record shown above.  This is accomplished
XMby keeping track of the record number and the byte offset within the
XMrecord.  Knowing the group size, you randomly access the record
XMcontaining the proper group, offset to the beginning of the group
XMwithin the record read sequentially until the group size has been
Xexhausted.

     MFinally, you can improve QUERY considerably by allowing boolean
XMexpressions, which compute the set of records that satisfy several
XMrelationships, such as a LASTNAME between HARDY and LAUREL and an
XMAGE lower than 45.  Display all the records that fit this
XMdescription.  Finally, if your lists are getting too big to fit into
Xmemory, randomly access key files from the disk as well.





                               5-49





CP/M Operating System Manual         5.6  System Function Summary


W5.6  System Function Summary

F&Sunction        Function                Input                Output
Number          Name

Decimal     Hex

 0           0   System Reset            C = 00H              none
 1           1   Console Input           C = 01H              A = ASCII char
 2           2   Console Output          E = char             none
 3           3   Reader Input                                 A = ASCII char
 4           4   Punch Output            E = char             none
 5           5   List Output             E = char             none
 6           6   Direct Console I/O      C = 06H              A = char or status

                                         E = 0FFH (input) or  (no value)
                                             0FEH (status) or
                                             char (output)
 7           7   Get I/O Byte            none                 A = I/O byte
                                                               Value
 8           8   Set I/O Byte            E = I/O Byte         none
 9           9   Print String            DE = Buffer Address  none
10           A   Read Console Buffer     DE = Buffer          Console
                                                               Characters
                                                               in Buffer
11           B   Get Console Status      none                 A = 00/non zero
12           C   Return Version Number   none                 HL: Version
                                                                 Number
13           D   Reset Disk System       none                   none
14           E   Select Disk             E = Disk Number        none
15           F   Open File               DE = FCB Address       FF if not found
16          10   Close File              DE = FCB Address       FF if not found
17          11   Search For First        DE = FCB Address       A = Directory
                                                                  Code
18          12   Search For Next         none                   A = Directory
                                                                  Code
19          13   Delete File             DE = FCB Address       A = none
20          14   Read Sequential         DE = FCB Address       A = Error Code
21          15   Write Sequential        DE = FCB Address       A = Error Code
22          16   Make File               DE = FCB Address       A = FF if no DIR
                                                                  Space
23          17   Rename File             DE = FCB Address       A = FF in not
                                                                  found
24          18   Return Login Vector     none                   HL = Login
                                                                   Vector*
25          19   Return Current Disk     none                   A = Current Disk
                                                                  Number
26          1A   Set DMA Address         DE = DMA Address       none
27          1B   Get ADDR (ALLOC)        none                   HL = ALLOC
                                                                   Address*
28          1C   Write Protect Disk      none                   none
29          1D   Get Read/only Vector    none                   HL = R/O
                                                                 Vector Value*
30          1E   Set File Attributes     DE = FCB Address       A = none
31          1F   Get ADDR (Disk Parms)   none                   HL = DPB


                               5-50





CP/M Operating System Manual         5.6  System Function Summary


                                                                 Address
32          20   Set/Get User Code       E = 0FFH for Get       User Number
                                         E = 00 to 0FH for Set
33          21   Read Random             DE = FCB Address       A = Error Code
34          22   Write Random            DE = FCB Address       A = Error Code
35          23   Compute File Size       DE = FCB Address       r0, r1, r2
36          24   Set Random Record       DE = FCB Address       r0, r1, r2
37          25   Reset Drive             DE = Drive Vector      A = 0
38          26   Access Drive            not supported
39          27   Free Drive              not supported
40          28   Write Random with Fill  DE = FCB               A = Error Code




*Note that A = L, and B = H upon return.


=End of Section 5






































                               5-51








=WSection 6

=&SWCP/M 2 Alteration



&SW6.1  Introduction

     MT&She standard CP/M system assumes operation on an Intel Model
XM800 microcomputer development system , but is designed so you can
XMalter a specific set of subroutines that define the hardware
Xoperating environment.

     MAlthough standard CP/M 2 is configured for single-density
XMfloppy disks, field-alteration features allow adaptation to a wide
XMvariety of disk subsystems from single-drive minidisks to high-
XMcapacity, hard disk systems.  To simplify the following adaptation
XMprocess, it is assumed that CP/M 2 is first configured for single-
XMdensity floppy disks where minimal editing and debugging tools are
XMavailable.  If an earlier version of CP/M is available, the
XMcustomizing process is eased considerably.  In this latter case, you
XMmight want to review the system generation process and skip to later
XMsections that discuss system alteration for nonstandard disk
Xsystems.

     MTo achieve device independence, CP/M is separated into three
Xdistinct modules:

   o BIOS is the Basic I/O System, which is environment dependent.

   o MBDOS is the Basic Disk Operating System, which is not dependent
X     upon the hardware configuration.

   o CCP is the Console Command Processor, which uses the BDOS.

     MOf these modules, only the BIOS is dependent upon the
XMparticular hardware.  You can patch the distribution version of CP/M
XMto provide a new BIOS that provides a customized interface between
XMthe remaining CP/M modules and the hardware system.  This document
XMprovides a step-by-step procedure for patching a new BIOS into CP/M.
X
     MAll disk-dependent portions of CP/M 2 are placed into a BIOS, a
XMresident disk parameter block, which is either hand coded or
XMproduced automatically using the disk definition macro library
XMprovided with CP/M 2.  The end user need only specify the maximum
XMnumber of active disks, the starting and ending sector numbers, the
XMdata allocation size, the maximum extent of the logical disk,
XMdirectory size information, and reserved track values.  The macros
XMuse this information to generate the appropriate tables and table
XMreferences for use during CP/M 2 operation.  Deblocking information
XMis provided, which aids in assembly or disassembly of sector sizes
XMthat are multiples of the fundamental 128-byte data unit, and the
XMsystem alteration manual includes general purpose subroutines that
XMuse the deblocking information to take advantage of larger sector
XMsizes.  Use of these subroutines, together with the table-drive data
XMaccess algorithms, makes CP/M 2 a universal data management system.
X

                               6-1




CP/M Operating System Manual                    6.1  Introduction


     MFile expansion is achieved by providing up to 512 logical file
XMextents, where each logical extent contains 16K bytes of data.  CP/M
XM2 is structured, however, so that as much as 128K bytes of data are
XMaddressed by a single physical extent, corresponding to a single
XMdirectory entry, maintaining compatibility with previous versions
Xwhile taking advantage of directory space.

     MIf CP/M is being tailored to a computer system for the first
XMtime, the new BIOS requires some simple software development and
XMtesting.  The standard BIOS is listed in Appendix A and can be used
XMas a model for the customized package.  A skeletal version of the
XMBIOS given in Appendix B can serve as the basis for a modified BIOS.
X
     MIn addition to the BIOS, you must write a simple memory loader,
XMcalled GETSYS, which brings the operating system into memory.  To
XMpatch the new BIOS into CP/M, you must write the reverse of GETSYS,
XMcalled PUTSYS, which places an altered version of CP/M back onto the
XMdisk.  PUTSYS can be derived from GETSYS by changing the disk read
XMcommands into disk write commands.  Sample skeletal GETSYS and
XMPUTSYS programs are described in Section 6.4 and listed in Appendix
XC.

     MTo make the CP/M system load automatically, you must also
XMsupply a cold start loader, similar to the one provided with CP/M,
XMlisted in Appendixes A and D.  A skeletal form of a cold start
XMloader is given in Appendix E, which serves as a model for the
Xloader.


W6.2  First-level System Regeneration

     MT&She procedure to patch the CP/M system is given below.  Address
XMreferences in each step are shown with H denoting the hexadecimal
XMradix, and are given for a 20K CP/M system.  For larger CP/M
XMsystems, a bias is added to each address that is shown with a +b
XMfollowing it, where b is equal to the memory size-20K.  Values for b
Xin various standard memory sizes are listed in Table 6-1.


W             Table 6-1.  Standard Memory Size Values

          Memory Size                Value

             24K:         b = 24K - 20K =  4K = 1000H

             32K:         b = 32K - 20K = 12K = 3000H

             40K:         b = 40K - 20K = 20K = 5000H

             48K:         b = 48K - 20K = 28K = 7000H

             56K:         b = 56K - 20K = 36K = 9000H

             62K:         b = 62K - 20K = 42K = A800H

             64K:         b = 64K - 20K = 44K = B000H


                               6-2




CP/M Operating System Manual        6.2  First-level Regeneration


     MNote that the standard distribution version of CP/M is set for
XMoperation within a 20K CP/M system. Therefore, you must first bring
XMup the 20K CP/M system, then configure it for actual memory size
X(see Section 6.3).

     Follow these steps to patch your CP/M system:


     1) MRead Section 6.4 and write a GETSYS program that reads the
X        Mfirst two tracks of a disk into memory.  The program from
X        Mthe disk must be loaded starting at location 3380H.  GETSYS
X        Mis coded to start at location 100H (base of the TPA) as
X        shown in Appendix C.

     2) MTest the GETSYS program by reading a blank disk into memory,
X        Mand check to see that the data has been read properly and
X        Mthat the disk has not been altered in any way by the GETSYS
X        program.

     3) MRun the GETSYS program using an initialized CP/M disk to see
X        Mif GETSYS loads CP/M starting at 3380H (the operating
X        system actually starts 128 bytes later at 3400H).

     4) MRead Section 6.4 and write the PUTSYS program.  This writes
X        Mmemory starting at 3380H back onto the first two tracks of
X        Mthe disk.  The PUTSYS program should be located at 200H, as
X        shown in Appendix C.

     5) MTest the PUTSYS program using a blank, uninitialized disk by
X        Mwriting a portion of memory to the first two tracks; clear
X        Mmemory and read it back using GETSYS.  Test PUTSYS
X        Mcompletely, because this program will be used to alter CP/M
X        on disk.

     6) MStudy Sections 6.5, 6.6, and 6.7 along with the distribution
X        Mversion of the BIOS given in Appendix A and write a simple
X        Mversion that performs a similar function for the customized
X        Menvironment.  Use the program given in Appendix B as a
X        Mmodel.  Call this new BIOS by name CBIOS (customized BIOS).
X        MImplement only the primitive disk operations on a single
X        Mdrive and simple console input/output functions in this
X        phase.

     7) MTest CBIOS completely to ensure that it properly performs
X        Mconsole character I/O and disk reads and writes.  Be
X        Mcareful to ensure that no disk write operations occur
X        Mduring read operations and check that the proper track and
X        Msectors are addressed on all reads and writes.  Failure to
X        Mmake these checks might cause destruction of the
X        initialized CP/M system after it is patched.

     8) MReferring to Table 6-3 in Section 6.5, note that the BIOS is
X        Mplaced between locations 4A00H and 4FFFH.  Read the CP/M
X        Msystem using GETSYS and replace the BIOS segment by the
X        MCBIOS developed in step 6 and tested in step 7.  This
X        replacement is done in memory.


                               6-3




CP/M Operating System Manual        6.2  First-level Regeneration


     9) MUse PUTSYS to place the patched memory image of CP/M onto
X        the first two tracks of a blank disk for testing.

    10) MUse GETSYS to bring the copied memory image from the test
X        Mdisk back into memory at 3380H and check to ensure that it
X        Mhas loaded back properly (clear memory, if possible, before
X        Mthe load).  Upon successful load, branch to the cold start
X        Mcode at location 4A00H.  The cold start routine initializes
X        Mpage zero, then jumps to the CCP at location 3400H, which
X        Mcalls the BDOS, which calls the CBIOS.  The CCP asks the
X        MCBIOS to read sixteen sectors on track 2, and CP/M types
X        A>, the system prompt.

        MIf difficulties are encountered, use whatever debug
X        Mfacilities are available to trace and breakpoint the CBIOS.
X
    11) MUpon completion of step 10, CP/M has prompted the console
X        Mfor a command input.  To test the disk write operation,
X        type

        SAVE 1 X.COM

        MAll commands must be followed by a carriage return.  CP/M
X        responds with another prompt after several disk accesses:

        A>

        If it does not, debug the disk write functions and retry.

    12) Test the directory command by typing

        DIR

        CP/M responds with

        A:X     COM

    13) Test the erase command by typing

        ERA X.COM

        MCP/M responds with the A prompt.  This is now an
X        Moperational system that only requires a bootstrap loader to
X        function completely.

    14) MWrite a bootstrap loader that is similar to GETSYS and place
X        Mit on track 0, sector 1, using PUTSYS (again using the test
X        Mdisk, not the distribution disk).  See Sections 6.5 and 6.8
X        for more information on the bootstrap operation.

    15) MRetest the new test disk with the bootstrap loader installed
X        Mby executing steps 11, 12, and 13.  Upon completion of
X        Mthese tests, type a CTRL-C.  The system executes a warm
X        start, which reboots the system, and types the A prompt.



                               6-4





CP/M Operating System Manual        6.2  First-level Regeneration


    16) MAt this point, there is probably a good version of the
X        Mcustomized CP/M system on the test disk.  Use GETSYS to
X        Mload CP/M from the test disk.  Remove the test disk, place
X        Mthe distribution disk, or a legal copy, into the drive, and
X        Muse PUTSYS to replace the distribution version with the
X        Mcustomized version.  Do not make this replacement if you
X        Mare unsure of the patch because this step destroys the
X        system that was obtained from Digital Research.

    17) Load the modified CP/M system and test it by typing

        DIR

        MCP/M responds with a list of files that are provided on the
X        Minitialized disk.  The file DDT.COM is the memory image for
X        Mthe debugger.  Note that from now on, you must always
X        Mreboot the CP/M system (CTRL-C is sufficient) when the disk
X        Mis removed and replaced by another disk, unless the new
X        disk is to be Read-Only.

    18) Load and test the debugger by typing

        DDT

        See Chapter 4 for operating procedures.

    19) MBefore making further CBIOS modifications, practice using
X        Mthe editor (see Chapter 2), and assembler (see Chapter 3).
X        MRecode and test the GETSYS, PUTSYS, and CBIOS programs
X        Musing ED, ASM, and DDT.  Code and test a COPY program that
X        Mdoes a sector-to-sector copy from one disk to another to
X        Mobtain back-up copies of the original disk.  Read the CP/M
X        MLicensing Agreement specifying legal responsibilities when
X        Mcopying the CP/M system.  Place the following copyright
X        notice:

        Copyright (c), 1983
         Digital Research

        on each copy that is made with the COPY program.

    20) MModify the CBIOS to include the extra functions for punches,
X        Mreaders, and sign-on messages, and add the facilities for
X        Madditional disk drives, if desired.  These changes can be
X        Mmade with the GETSYS and PUTSYS programs or by referring to
X        the regeneration process in Section 6.3.


     MYou should now have a good copy of the customized CP/M system.
XMAlthough the CBIOS portion of CP/M belongs to the user, the modified
Xversion cannot be legally copied.

     MIt should be noted that the system remains file-compatible with
XMall other CP/M systems (assuming media compatibility) which allows
Xtransfer of nonproprietary software between CP/M users.


                               6-5





CP/M Operating System Manual  6.3  Second-level System Generation


W6.3  Second-level System Generation

     MO&Snce the system is running, the next step is to configure CP/M
XMfor the desired memory size.  Usually, a memory image is first
XMproduced with the MOVCPM program (system relocator) and then placed
XMinto a named disk file.  The disk file can then be loaded, examined,
XMpatched, and replaced using the debugger and the system generation
Xprogram (refer to Chapter 1).

     MThe CBIOS and BOOT are modified using ED and assembled using
XMASM, producing files called CBIOS.HEX and BOOT.HEX, which contain
Xthe code for CBIOS and BOOT in Intel hex format.

     MTo get the memory image of CP/M into the TPA configured for the
Xdesired memory size, type the command:

        MOVCPM xx*

Mwhere xx is the memory size in decimal K bytes, for example, 32 for
X32K.  The response is as follows:

        CONSTRUCTING xxK CP/M VERS 2.0

        READY FOR "SYSGEN" OR

        "SAVE 34 CPMxx.COM"

     MAn image of CP/M in the TPA is configured for the requested
XMmemory size.  The memory image is at location 0900H through 227FH,
XMthat is, the BOOT is at 0900H, the CCP is at 980H, the BDOS starts
XMat 1180H, and the BIOS is at 1F80H.  Note that the memory image has
XMthe standard Model 800 BIOS and BOOT on it.  It is now necessary to
XMsave the memory image in a file so that you can patch the CBIOS and
XCBOOT into it:

        SAVE 34 CPMxx.COM

     MThe memory image created by the MOVCPM program is offset by a
XMnegative bias so that it loads into the free area of the TPA, and
XMthus does not interfere with the operation of CP/M in higher memory.
XMThis memory image can be subsequently loaded under DDT and examined
XMor changed in preparation for a new generation of the system.  DDT
Xis loaded with the memory image by typing:

        DDT CPMxx.COM       Loads DDT, then reads the CP/M image.

DDT should respond with the following:

        NEXT PC
        2300 0100
        -                                          The DDT prompt

MYou can then give the display and disassembly commands to examine
XMportions of the memory image between 900H and 227FH.  Note, however,
XMthat to find any particular address within the memory image, you


                               6-M6



X

CP/M Operating System Manual  6.3  Second-level System Generation


Mmust apply the negative bias to the CP/M address to find the actual
XMaddress.  Track 00, sector 01, is loaded to location 900H (the user
XMshould find the cold start loader at 900H to 97FH); track 00, sector
XM02, is loaded into 980H (this is the base of the CCP); and so on
XMthrough the entire CP/M system load.  In a 20K system, for example,
XMthe CCP resides at the CP/M address 3400H, but is placed into memory
XMat 980H by the SYSGEN program.  Thus, the negative bias, denoted by
Xn, satisfies

        3400H + n = 980H, or n =980H - 3400H

MAssuming two's complement arithmetic, n = D580H, which can be
Xchecked by

        3400H + D580H = 10980H = 0980H (ignoring high-order
                                       overflow).

     Note that for larger systems, n satisfies

        (3400H+b) + n = 980H, or
        n = 980H - (3400H + b), or
        n = D580H - b

The value of n for common CP/M systems is given below.


W           Table 6-2.  Common Values for CP/M Systems

         Memory Size      BIAS b      Negative Offset n

             20K          0000H     D580H - 0000H = D580H
             24K          1000H     D580H - 1000H = C580H
             32K          3000H     D580H - 3000H = A580H
             40K          5000H     D580H - 5000H = 8580H
             48K          7000H     D580H - 7000H = 6580H
             56K          9000H     D580H - 9000H = 4580H
             62K          A800H     D580H - A800H = 2D80H
             64K          B000H     D580H - B000H = 2580H


     MIf you want to locate the address x within the memory image
Xloaded under DDT in a 20K system, first type

        Hx,n            Hexadecimal sum and difference

Mand DDT responds with the value of x+n (sum) and x-n (difference).
XMThe first number printed by DDT is the actual memory address in the
XMimage where the data or code is located.  For example, the following
XDDT command:

        H3400,D580

Mproduces 980H as the sum, which is where the CCP is located in the
Xmemory image under DDT.



                               6-7





CP/M Operating System Manual  6.3  Second-level System Generation


     MType the L command to disassemble portions of the BIOS located
XMat (4A00H+b)-n, which, when one uses the H command, produces an
XMactual address of 1F80H.  The disassembly command would thus be as
Xfollows:

        L1F80

MIt is now necessary to patch in the CBOOT and CBIOS routines.  The
XMBOOT resides at location 0900H in the memory image.  If the actual
XMload address is n, then to calculate the bias (m), type the command:
X
        MH900,n          Subtract load address from target address.
X
     MThe second number typed by DDT in response to the command is
XMthe desired bias (m).  For example, if the BOOT executes at 0080H,
Xthe command

        H900,80

produces

        0980 0880       Sum and difference in hex.

MTherefore, the bias m would be 0880H.  To read-in the BOOT, give the
Xcommand:

        ICBOOT.HEX      Input file CBOOT.HEX

Then

        Rm              Read CBOOT with a bias of m (=900H-n).

Examine the CBOOT with

        L900

MYou are now ready to replace the CBIOS by examining the area at
XM1F80H, where the original version of the CBIOS resides, and then
Xtyping

        ICBIOS.HEX      Ready the hex file for loading.

     MAssume that the CBIOS is being integrated into a 20K CP/M
XMsystem and thus originates at location 4A00H.  To locate the CBIOS
XMproperly in the memory image under DDT, you must apply the negative
XMbias n for a 20K system when loading the hex file.  This is
Xaccomplished by typing

        RD580           Read the file with bias D580H.

MUpon completion of the read, reexamine the area where the CBIOS has
XMbeen loaded (use an L1F80 command) to ensure that it is properly
XMloaded.  When you are satisfied that the change has been made,
Xreturn from DDT using a CTRL-C or, G0 command.



                               6-8





CP/M Operating System Manual  6.3  Second-level System Generation


     MSYSGEN is used to replace the patched memory image back onto a
XMdisk (you use a test disk until sure of the patch) as shown in the
Xfollowing interaction:


        SYSGEN                    Start the SYSGEN program.

        SYSGEN VERSION 2.0        Sign-on message from SYSGEN.

        SOURCE DRIVE NAME         Respond with a carriage return
        (OR RETURN TO SKIP)       to skip the CP/M read operation
                                  because the system is already
                                  in memory.

        DESTINATION DRIVE NAME    Respond with B to write the new
        (OR RETURN TO REBOOT)     system to the disk in drive B.


        DESTINATION ON B,         Place a scratch disk in drive
        THEN TYPE RETURN          B, then press RETURN.

        FUNCTION COMPLETE
        DESTINATION DRIVE NAME
        (OR RETURN TO REBOOT)


     MPlace the scratch disk in drive A, then perform a cold start to
Xbring up the newly-configured CP/M system.

     MThe new CP/M system is then tested and the Digital Research
XMcopyright notice is placed on the disk, as specified in the
XLicensing Agreement:

        Copyright (c), 1979
         Digital Research


W6.4  Sample GETSYS and PUTSYS Programs

     MT&She following program provides a framework for the GETSYS and
XMPUTSYS programs referenced in Sections 6.1 and 6.2.  To read and
XMwrite the specific sectors, you must insert the READSEC and WRITESEC
Xsubroutines.














                               6-9





CP/M Operating System Manual        6.4  Sample GETSYS and PUTSYS


;  GETSYS PROGRAM -- READ TRACKS 0 AND 1 TO MEMORY AT 3380H
;  REGISTER                    USE

;         A               (SCRATCH REGISTER)

;         B               TRACK COUNT (0, 1)

;         C               SECTOR COUNT (1,2,...,26)

;         DE              (SCRATCH REGISTER PAIR)

;         HL              LOAD ADDRESS

;         SP              SET TO STACK ADDRESS

;
START:    LXI  SP,3380H   ;SET STACK POINTER TO SCRATCH
                          ;AREA
          LXI  H,3380H    ;SET BASE LOAD ADDRESS
          MVI  B,0        ;START WITH TRACK 0
RDTRK:                    ;READ NEXT TRACK (INITIALLY 0)
          MVI  C,1        ;READ STARTING WITH SECTOR 1

RDSEC:                    ;READ NEXT SECTOR
          CALL READSEC    ;USER-SUPPLIED SUBROUTINE
          LXI  D,128      ;MOVE LOAD ADDRESS TO NEXT 1/2
                          ;PAGE
          DAD  D          ;HL = HL + 128
          INR  C          ;SECTOR = SECTOR + 1
          MOV  A,C        ;CHECK FOR END OF TRACK
          CPI  27
          JC   RDSEC      ;CARRY GENERATED IF SECTOR <27

;
;  ARRIVE HERE AT END OF TRACK, MOVE TO NEXT TRACK
          INR  B
          MOV  A,B        ;TEST FOR LAST TRACK
          CPI  2
          JC   RDTRK      ;CARRY GENERATED IF TRACK <2

;
;  USER-SUPPLIED SUBROUTINE TO READ THE DISK
READSEC:
;  ENTER WITH TRACK NUMBER IN REGISTER B,
          SECTOR NUMBER IN REGISTER C, AND

;         ADDRESS TO FILL IN HL

;
          PUSH B          ;SAVE B AND C REGISTERS
          PUSH H          ;SAVE HL REGISTERS


W                  Listing 6-1.  GETSYS Program



                               6-10





CP/M Operating System Manual        6.4  Sample GETSYS and PUTSYS


          .................................................
          perform disk read at this point, branch to
          label START if an error occurs
          .................................................
          POP H           ;RECOVER HL
          POP B           ;RECOVER B AND C REGISTERS
          RET             ;BACK TO MAIN PROGRAM

          END START


W                    Listing 6-1.  (continued)



     MThis program is assembled and listed in Appendix B for
XMreference purposes, with an assumed origin of 100H.  The hexadecimal
XMoperation codes that are listed on the left might be useful if the
Xprogram has to be entered through the panel switches.

     MThe PUTSYS program can be constructed from GETSYS by changing
XMonly a few operations in the GETSYS program given above, as shown in
XMAppendix C.  The register pair HL becomes the dump address, next
XMaddress to write, and operations on these registers do not change
XMwithin the program.  The READSEC subroutine is replaced by a
XMWRITESEC subroutine, which performs the opposite function; data from
XMaddress HL is written to the track given by register B and sector
XMgiven by register C.  It is often useful to combine GETSYS and
XMPUTSYS into a single program during the test and development phase,
Xas shown in Appendix C.


W6.5  Disk Organization

     MT&She sector allocation for the standard distribution version of
XMCP/M is given here for reference purposes.  The first sector
XMcontains an optional software boot section (see the table on the
XMfollowing page.   Disk controllers are often set up to bring track
XM0, sector 1, into memory at a specific location, often location
XM0000H.  The program in this sector, called BOOT, has the
XMresponsibility of bringing the remaining sectors into memory
XMstarting at location 3400H+b.  If the controller does not have a
XMbuilt-in sector load, the program in track 0, sector 1 can be
XMignored.  In this case, load the program from track 0, sector 2, to
Xlocation 3400H+b.

     MAs an example, the Intel Model 800 hardware cold start loader
XMbrings track 0, sector 1, into absolute address 3000H.  Upon loading
XMthis sector, control transfers to location 3000H, where the
XMbootstrap operation commences by loading the remainder of track 0
XMand all of track 1 into memory, starting at 3400H+b.  Note that this
XMbootstrap loader is of little use in a non-microcomputer development
XMsystem environment, although it is useful to examine it because some
XMof the boot actions will have to be duplicated in the user's cold
Xstart loader.


                               6-11





CP/M Operating System Manual               6.5  Disk Organization


W             Table 6-3.  CP/M Disk Sector Allocation

Track #    Sector   Page#   Memory Address    CP/M Module name

  00         01             (boot address)    Cold Start Loader
  00         02      00        3400H+b               CCP
  '          03      '         3480H+b                '
  '          04      01        3500H+b                '
  '          05      '         3580H+b                '
  '          06      02        3600H+b                '
  '          07      '         3680H+b                '
  '          08      03        3700H+b                '
  '          09      '         3780H+b                '
  '          10      04        3800H+b                '
  '          11      '         3880H+b                '
  '          12      05        3900H+b                '
  '          13      '         3980H+b                '
  '          14      06        3A00H+b                '
  '          15      '         3A80H+b                '
  '          16      07        3B00H+b                '
  00         17      '         3B80H+b               CCP
  00         18      08        3C00H+b              BDOS
  '          19      '         3C80H+b                '
  '          20      09        3D00H+b                '
  '          21      '         3D80H+b                '
  '          22      10        3E00H+b                '
  '          23      '         3E80H+b                '
  '          24      11        3F00H+b                '
  '          25      '         3F80H+b                '
  '          26      12        4000H+b                '
  01         01      '         4080H+b                '
  '          02      13        4100H+b                '
  '          03      '         4180H+B                '
  '          04      14        4200H+b                '
  '          05      '         4280H+b                '
  '          06      15        4300H+b                '
  '          07      '         4380H+b                '
  '          08      16        4400H+b                '
  '          09      '         4480H+b                '
  '          10      17        4500H+b                '
  '          11      '         4580H+b                '
  '          12      18        4600H+b                '
  '          13      '         4680H+b                '
  '          14      19        4700H+b                '
  '          15      '         4780H+b                '
  '          16      20        4800H+b                '
  '          17      '         4880H+b                '
  '          18      21        4900H+b                '
  01         19      '         4900H+b              BDOS
  07         20      22        4A00H+b              BIOS
  '          21      '         4A80H+b                '
  '          22      23        4B00H+b                '
  '          23      '         4B80H+b                '
  '          24      24        4C00H+b                '
  01         25      '         4C80H+b              BIOS
  01         26      25        4D00H+b              BIOS
02-76      01-26                            (directory and data)

                               6-12




CP/M Operating System Manual               6.6  BIOS Entry Points


W6.6  The BIOS Entry Points

     MT&She entry points into the BIOS from the cold start loader and
XMBDOS are detailed below.  Entry to the BIOS is through a jump vector
XMlocated at 4A00H+b, as shown below.  See Appendixes A and B.  The
XMjump vector is a sequence of 17 jump instructions that send program
XMcontrol to the individual BIOS subroutines.  The BIOS subroutines
XMmight be empty for certain functions (they might contain a single
XMRET operation) during reconfiguration of CP/M, but the entries must
Xbe present in the jump vector.

     MThe jump vector at 4A00H+b takes the form shown below, where
Xthe individual jump addresses are given to the left:


     4A00H+b      JMP BOOT       ;ARRIVE HERE FROM COLD
                                  START LOAD

     4A03H+b      JMP WBOOT      ;ARRIVE HERE FOR WARM START

     4A06H+b      JMP CONST      ;CHECK FOR CONSOLE CHAR
                                  READY

     4A09H+b      JMP CONIN      ;READ CONSOLE CHARACTER IN

     4A0CH+b      JMP CONOUT     ;WRITE CONSOLE CHARACTER
                                  OUT

     4A0FH+b      JMP LIST       ;WRITE LISTING CHARACTER OUT

     4A12H+b      JMP PUNCH      ;WRITE CHARACTER TO PUNCH
                                  DEVICE

     4A15H+b      JMP READER     ;READ READER DEVICE

     4A18H+b      JMP HOME       ;MOVE TO TRACK 00 ON
                                  SELECTED DISK

     4A1BH+b      JMP SELDSK     ;SELECT DISK DRIVE

     4A1EH+b      JMP SETTRK     ;SET TRACK NUMBER

     4A21H+b      JMP SETSEC     ;SET SECTOR NUMBER

     4A24H+b      JMP SETDMA     ;SET DMA ADDRESS

     4A27H+b      JMP READ       ;READ SELECTED SECTOR

     4A2AH+b      JMP WRITE      ;WRITE SELECTED SECTOR

     4A2DH+b      JMP LISTST     ;RETURN LIST STATUS

     4A30H+b      JMP SECTRAN    ;SECTOR TRANSLATE
                                  SUBROUTINE


W                 Listing 6-2.  BIOS Entry Points

                               6-13




CP/M Operating System Manual               6.6  BIOS Entry Points


     MEach jump address corresponds to a particular subroutine that
XMperforms the specific function, as outlined below.  There are three
XMmajor divisions in the jump table:  the system reinitialization,
XMwhich results from calls on BOOT and WBOOT; simple character I/O,
XMperformed by calls on CONST, CONIN, CONOUT, LIST, PUNCH, READER, and
XMLISTST; and disk I/O, performed by calls on HOME, SELDSK, SETTRK,
XSETSEC, SETDMA, READ, WRITE, and SECTRAN.

     MAll simple character I/O operations are assumed to be performed
XMin ASCII, upper- and lower-case, with high-order (parity bit) set to
XMzero.  An end-of-file condition for an input device is given by an
XMASCII CTRL-Z (1AH).  Peripheral devices are seen by CP/M as logical
Xdevices and are assigned to physical devices within the BIOS.

     MTo operate, the BDOS needs only the CONST, CONIN, and CONOUT
XMsubroutines.  LIST, PUNCH, and READER can be used by PIP, but not
XMthe BDOS.  Further, the LISTST entry is currently used only by
XMDESPOOL, the print spooling utility.  Thus, the initial version of
XCBIOS can have empty subroutines for the remaining ASCII devices.

     MThe following list describes the characteristics of each
Xdevice.


   o MCONSOLE is the principal interactive console that communicates
X     Mwith the operator and it is accessed through CONST, CONIN, and
X     MCONOUT.  Typically, the CONSOLE is a device such as a CRT or
X     teletype.

   o MLIST is the principal listing device.  If it exists on the
X     Muser's system, it is usually a hard-copy device, such as a
X     printer or teletype.

   o MPUNCH is the principal tape punching device.  If it exists, it
X     is normally a high-speed paper tape punch or teletype.

   o MREADER is the principal tape reading device, such as a simple
X     optical reader or teletype.


     MA single peripheral can be assigned as the LIST, PUNCH, and
XMREADER device simultaneously.  If no peripheral device is assigned
XMas the LIST, PUNCH, or READER device, the CBIOS gives an appropriate
XMerror message so that the system does not hang if the device is
XMaccessed by PIP or some other user program.  Alternately, the PUNCH
XMand LIST routines can just simply return, and the READER routine can
XMreturn with a 1AH (CTRL-Z) in register A to indicate immediate end-
Xof-file.

     MFor added flexibility, you can optionally implement the IOBYTE
XMfunction, which allows reassignment of physical devices.  The IOBYTE
XMfunction creates a mapping of logical-to-physical devices that can
XMbe altered during CP/M processing, see the STAT command in Section
X1.6.1.




                               6-14




CP/M Operating System Manual               6.6  BIOS Entry Points

     MThe definition of the IOBYTE function corresponds to the Intel
XMstandard as follows:  a single location in memory, currently
XMlocation 0003H, is maintained, called IOBYTE, which defines the
XMlogical-to-physical device mapping that is in effect at a particular
XMtime.  The mapping is performed by splitting the IOBYTE into four
XMdistinct fields of two bits each, called the CONSOLE, READER, PUNCH,
Xand LIST fields, as shown in the following figure.


                      most significant      least significant

    IOBYTE AT 003H    LIST       PUNCH      READER     CONSOLE

                      bits 6,7  bits 4,5  bits 2,3   bits 0,1


W                   Figure 6-1.  IOBYTE Fields



     MThe value in each field can be in the range 0-3, defining the
XMassigned source or destination of each logical device.  Table 6-4
Xgives the values that can be assigned to each field.


W                 Table 6-4. IOBYTE Field Values

        Value                   Meaning

                    CONSOLE field (bits 0,1)

         0     console is assigned to the console printer
               device (TTY:)
         1     console is assigned to the CRT device (CRT:)
         2     batch mode:  use the READER as the CONSOLE input,
               and the LIST device as the CONSOLE output (BAT:)
         3     user-defined console device (UC1:)

                     READER field (bits 2,3)

         0     READER is the teletype device (TTY:)
         1     READER is the high speed reader device (PTR:)
         2     user-defined reader #1 (UR1:)
         3     user-defined reader #2 (UR2:)

                     PUNCH field (bits 4,5)

         0     PUNCH is the teletype device (TTY:)
         1     PUNCH is the high speed punch device (PTP:)
         2     user-defined punch #1 (UP1:)
         3     user-defined punch #2 (UP2:)

                      LIST field (bits 6,7)

         0     LIST is the teletype device (TTY:)
         1     LIST is the CRT device (CRT:)
         2     LIST is the line printer device (LPT:)
         3     user-defined list device (UL1:)

                               6-15




CP/M Operating System Manual               6.6  BIOS Entry Points


     MThe implementation of the IOBYTE is optional and effects only
XMthe organization of the CBIOS.  No CP/M systems use the IOBYTE
XM(although they tolerate the existence of the IOBYTE at location
XM0003H) except for PIP, which allows access to the physical devices,
XMand STAT, which allows logical-physical assignments to be make or
XMdisplayed.  For more information see Section 1.  In any case the
XMIOBYTE implementation should be omitted until the basic CBIOS is
XMfully implemented and tested; then you should add the IOBYTE to
Xincrease the facilities.

     MDisk I/O is always performed through a sequence of calls on the
XMvarious disk access subroutines that set up the disk number to
XMaccess, the track and sector on a particular disk, and the Direct
XMMemory Access (DMA) address involved in the I/O operation.  After
XMall these parameters have been set up, a call is made to the READ or
XWRITE function to perform the actual I/O operation.

     MThere is often a single call to SELDSK to select a disk drive,
XMfollowed by a number of read or write operations to the selected
XMdisk before selecting another drive for subsequent operations.
XMSimilarly, there might be a single call to set the DMA address,
XMfollowed by several calls that read or write from the selected DMA
XMaddress before the DMA address is changed.  The track and sector
XMsubroutines are always called before the READ or WRITE operations
Xare performed.

     MThe READ and WRITE routines should perform several retries (10
XMis standard) before reporting the error condition to the BDOS.  If
XMthe error condition is returned to the BDOS, it reports the error to
XMthe user.  The HOME subroutine might or might not actually perform
XMthe track 00 seek, depending upon controller characteristics; the
XMimportant point is that track 00 has been selected for the next
XMoperation and is often treated in exactly the same manner as SETTRK
Xwith a parameter of 00.

     MThe following table describes the exact responsibilities of
Xeach BIOS entry point subroutine.


W                  Table 6-5.  BIOS Entry Points

   Entry Point                    Function

	9	F0      BOOT     MThe BOOT entry point gets control from the cold
X               Mstart loader and is responsible for basic
X               Msystem initialization, including sending a
X               Msign-on message, which can be omitted in the
X               Mfirst version.  If the IOBYTE function is
X               Mimplemented, it must be set at this point.  The
X               Mvarious system parameters that are set by the
X               MWBOOT entry point must be initialized, and
X               Mcontrol is transferred to the CCP at 3400+b for
X               Mfurther processing.  Note that register C must
X               be set to zero to select drive A.



                               6-16





CP/M Operating System Manual               6.6  BIOS Entry Points


W                     Table 6-5.  (continued)

   Entry Point                    Function

      WBOOT    MThe WBOOT entry point gets control when a warm
X               Mstart occurs.  A warm start is performed
X               Mwhenever a user program branches to location
X               M0000H, or when the CPU is reset from the front
X               Mpanel.  The CP/M system must be loaded from the
X               Mfirst two tracks of drive A up to, but not
X               Mincluding, the BIOS, or CBIOS, if the user has
X               Mcompleted the patch.  System parameters must be
X               initialized as follows:

               location 0,1,2   MSet to JMP WBOOT for warm
X                                starts (000H: JMP 4A03H+b)

               location 3       MSet initial value of IOBYTE,
X                                if implemented in the CBIOS

               location 4       MHigh nibble = current user no;
X                                low nibble = current drive

               location 5,6,7   MSet to JMP BDOS, which is the
X                                Mprimary entry point to CP/M
X                                Mfor transient programs.
X                                (0005H: JMP 3C06H+b)

               MRefer to Section 6.9 for complete details of
X               Mpage zero use.  Upon completion of the
X               Minitialization, the WBOOT program must branch
X               Mto the CCP at 3400H+b to restart the system.
X               MUpon entry to the CCP, register C is set to the
X               Mdrive to select after system initialization.
X               MThe WBOOT routine should read location 4 in
X               Mmemory, verify that is a legal drive, and pass
X               it to the CCP in register C.

      CONST    MYou should sample the status of the currently
X               Massigned console device and return 0FFH in
X               Mregister A if a character is ready to read and
X               M00H in register A if no console characters are
X               ready.

      CONIN    MThe next console character is read into
X               Mregister A, and the parity bit is set, high-
X               Morder bit, to zero.  If no console character is
X               Mready, wait until a character is typed before
X               returning.








                               6-17





CP/M Operating System Manual               6.6  BIOS Entry Points


W                     Table 6-5.  (continued)

   Entry Point                    Function

      CONOUT   MThe character is sent from register C to the
X               Mconsole output device.  The character is in
X               MASCII, with high-order parity bit set to zero.
X               MYou might want to include a time-out on a line-
X               Mfeed or carriage return, if the console device
X               Mrequires some time interval at the end of the
X               Mline (such as a TI Silent 700 terminal).  You
X               Mcan filter out control characters that cause
X               Mthe console device to react in a strange way
X               M(CTRL-Z causes the Lear-Seigler terminal to
X               clear the screen, for example).

      LIST     MThe character is sent from register C to the
X               Mcurrently assigned listing device.  The
X               character is in ASCII with zero parity bit.

      PUNCH    MThe character is sent from register C to the
X               Mcurrently assigned punch device.  The character
X               is in ASCII with zero parity.

      READER   MThe next character is read from the currently
X               Massigned reader device into register A with
X               Mzero parity (high-order bit must be zero); an
X               Mend-of-file condition is reported by returning
X               an ASCII CTRL-Z(1AH).

      HOME     MThe disk head of the currently selected disk
X               M(initially disk A) is moved to the track 00
X               Mposition.  If the controller allows access to
X               Mthe track 0 flag from the drive, the head is
X               Mstepped until the track 0 flag is detected.  If
X               Mthe controller does not support this feature,
X               Mthe HOME call is translated into a call to
X               SETTRK with a parameter of 0.

      SELDSK   MThe disk drive given by register C is selected
X               Mfor further operations, where register C
X               Mcontains 0 for drive A, 1 for drive B, and so
X               Mon up to 15 for drive P (the standard CP/M
X               Mdistribution version supports four drives).  On
X               Meach disk select, SELDSK must return in HL the
X               Mbase address of a 16-byte area, called the Disk
X               MParameter Header, described in Section 6.10.
X               MFor standard floppy disk drives, the contents
X               Mof the header and associated tables do not
X               Mchange; thus, the program segment included in
X               Mthe sample CBIOS performs this operation
X               automatically.





                               6-18





CP/M Operating System Manual               6.6  BIOS Entry Points


W                     Table 6-5.  (continued)

   Entry Point                    Function

               MIf there is an attempt to select a nonexistent
X               Mdrive, SELDSK returns HL=0000H as an error
X               Mindicator.  Although SELDSK must return the
X               Mheader address on each call, it is advisable to
X               Mpostpone the physical disk select operation
X               Muntil an I/O function (seek, read, or write) is
X               Mactually performed, because disk selects often
X               Moccur without utimately performing any disk
X               MI/O, and many controllers unload the head of
X               Mthe current disk before selecting the new
X               Mdrive.  This causes an excessive amount of
X               Mnoise and disk wear.  The least significant bit
X               Mof register E is zero if this is the first
X               Moccurrence of the drive select since the last
X               cold or warm start.

      SETTRK   MRegister BC contains the track number for
X               Msubsequent disk accesses on the currently
X               Mselected drive.  The sector number in BC is the
X               Msame as the number returned from the SECTRAN
X               Mentry point.  You can choose to seek the
X               Mselected track at this time or delay the seek
X               Muntil the next read or write actually occurs.
X               MRegister BC can take on values in the range 0-
X               M76 corresponding to valid track numbers for
X               Mstandard floppy disk drives and 0-65535 for
X               nonstandard disk subsystems.

      SETSEC   MRegister BC contains the sector number, 1
X               Mthrough 26, for subsequent disk accesses on the
X               Mcurrently selected drive.  The sector number in
X               MBC is the same as the number returned from the
X               MSECTRAN entry point.  You can choose to send
X               Mthis information to the controller at this
X               Mpoint or delay sector selection until a read or
X               write operation occurs.

      SETDMA   MRegister BC contains the DMA (Disk Memory
X               MAccess) address for subsequent read or write
X               Moperations.  For example, if B = 00H and C =
X               M80H when SETDMA is called, all subsequent read
X               Moperations read their data into 80H through
X               M0FFH and all subsequent write operations get
X               Mtheir data from 80H through 0FFH, until the
X               Mnext call to SETDMA occurs.  The initial DMA
X               Maddress is assumed to be 80H.  The controller
X               Mneed not actually support Direct Memory Access.
X               MIf, for example, all data transfers are through
X               MI/O ports, the CBIOS that is constructed uses
X               Mthe 128-byte area starting at the selected DMA
X               Maddress for the memory buffer during the
X               subsequent read or write operations.


                               6-19




CP/M Operating System Manual               6.6  BIOS Entry Points


W                     Table 6-5.  (continued)

   Entry Point                    Function

      READ     MAssuming the drive has been selected, the track
X               Mhas been set, and the DMA address has been
X               Mspecified, the READ subroutine attempts to read
X               Mone sector based upon these parameters and
X               Mreturns the following error codes in register
X               A:

               0  no errors occurred

               1  nonrecoverable error condition occurred

               MCurrently, CP/M responds only to a zero or
X               Mnonzero value as the return code.  That is, if
X               Mthe value in register A is 0, CP/M assumes that
X               Mthe disk operation was completed properly.  IF
X               Man error occurs the CBIOS should attempt at
X               Mleast 10 retries to see if the error is
X               Mrecoverable.  When an error is reported the
X               MBDOS prints the message BDOS ERR ONx:  BAD
X               MSECTOR.  The operator then has the option of
X               Mpressing a carriage return to ignore the error,
X               or CTRL-C to abort.

      WRITE    MData is written from the currently selected DMA
X               Maddress to the currently selected drive, track,
X               Mand sector.  For floppy disks, the data should
X               Mbe marked as nondeleted data to maintain
X               Mcompatibility with other CP/M systems.  The
X               Merror codes given in the READ command are
X               Mreturned in register A, with error recovery
X               attempts as described above.

      LISTST   MYou return the ready status of the list device
X               Mused by the DESPOOL program to improve console
X               Mresponse during its operation.  The value 00 is
X               Mreturned in A if the list device is not ready
X               Mto accept a character and 0FFH if a character
X               Mcan be sent to the printer.  A 00 value should
X               Mbe returned if LIST status is not implemented.
X













                               6-20





CP/M Operating System Manual               6.6  BIOS Entry Points


W                     Table 6-5.  (continued)

   Entry Point                    Function

      SECTRAN  MLogical-to-physical sector translation is
X               Mperformed to improve the overall response of
X               MCP/M.  Standard CP/M systems are shipped with a
X               Mskew factor of 6, where six physical sectors
X               Mare skipped between each logical read
X               Moperation.  This skew factor allows enough time
X               Mbetween sectors for most programs to load their
X               Mbuffers without missing the next sector.  In
X               Mparticular computer systems that use fast
X               Mprocessors, memory, and disk subsystems, the
X               Mskew factor might be changed to improve overall
X               Mresponse.  However, the user should maintain a
X               Msingle-density IBM-compatible version of CP/M
X               Mfor information transfer into and out of the
X               computer system, using a skew factor of 6.

               MIn general, SECTRAN receives a logical sector
X               Mnumber relative to zero in BC and a translate
X               Mtable address in DE.  The sector number is used
X               Mas an index into the translate table, with the
X               Mresulting physical sector number in HL.  For
X               Mstandard systems, the table and indexing code
X               Mis provided in the CBIOS and need not be
X               changed.
	9	K0

W6.7  A Sample BIOS

     MT&She program shown in Appendix B can serve as a basis for your
XMfirst BIOS.  The simplest functions are assumed in this BIOS, so
XMthat you can enter it through a front panel, if absolutely
XMnecessary.  You must alter and insert code into the subroutines for
XMCONST, CONIN, CONOUT, READ, WRITE, and WAITIO subroutines.  Storage
XMis reserved for user-supplied code in these regions.  The scratch
XMarea reserved in page zero (see Section 6.9) for the BIOS is used in
Xthis program, so that it could be implemented in ROM, if desired.

     MOnce operational, this skeletal version can be enhanced to
XMprint the initial sign-on message and perform better error recovery.
XMThe subroutines for LIST, PUNCH, and READER can be filled out and
Xthe IOBYTE function can be implemented.


W6.8  A Sample Cold Start Loader

     MT&She program shown in Appendix E can serve as a basis for a cold
XMstart loader.  The disk read function must be supplied by the user,
XMand the program must be loaded somehow starting at location 0000.
XMSpace is reserved for the patch code so that the total amount of
Xstorage required for the cold start loader is 128 bytes.



                               6-21





CP/M Operating System Manual      6.8  A Sample Cold Start Loader


     MEventually, you might want to get this loader onto the first
XMdisk sector (track 0, sector 1) and cause the controller to load it
XMinto memory automatically upon system start up.  Alternatively, the
XMcold start loader can be placed into ROM, and above the CP/M system.
XMIn this case, it is necessary to originate the program at a higher
XMaddress and key in a jump instruction at system start up that
XMbranches to the loader.  Subsequent warm starts do not require this
XMkey-in operation, because the entry point WBOOT gets control, thus
XMbringing the system in from disk automatically.  The skeletal cold
XMstart loader has minimal error recovery, which might be enhanced in
Xlater versions.


W6.9  Reserved Locations in Page Zero

     MM&Sain memory page zero, between locations 00H and 0FFH, contains
XMseveral segments of code and data that are used during CP/M
XMprocessing.  The code and data areas are given in the following
Xtable.


W           Table 6-6.  Reserved Locations in Page Zero

     Locations                       Contents

	9	F0     000H-0002H       MContains a jump instruction to the warm
X                      Mstart entry location 4A03H+b.  This
X                      Mallows a simple programmed restart (JMP
X                      M0000H) or manual restart from the front
X                      panel.

     0003H-0003H      MContains the Intel standard IOBYTE is
X                      Moptionally included in the user's CBIOS
X                      (refer to Section 6.6).

     0004H-0004H      MCurrent default drive number
X                      (0=A,...,15=P).

     0005H-0007H      MContains a jump instruction to the BDOS
X                      Mand serves two purposes:  JMP 0005H
X                      Mprovides the primary entry point to the
X                      MBDOS, as described in Chapter 5, and
X                      MLHLD 0006H brings the address field of
X                      Mthe instruction to the HL register
X                      Mpair.  This value is the lowest address
X                      Min memory used by CP/M, assuming the
X                      MCCP is being overlaid.  The DDT program
X                      Mchanges the address field to reflect
X                      Mthe reduced memory size in debug mode.
X
     0008H-0027H      MInterrupt locations 1 through 5 not
X                      used.

     0030H-0037H      MInterrupt location 6 (not currently
X                      used) is reserved.


                               6-22





CP/M Operating System Manual 6.9  Reserved Locations in Page Zero


W                     Table 6-6.  (continued)

     Locations                       Contents

     0038H-003AH      MRestart 7; contains a jump instruction
X                      Minto the DDT or SID program when
X                      Mrunning in debug mode for programmed
X                      Mbreakpoints, but is not otherwise used
X                      by CP/M.

     003BH-003FH      Not currently used; reserved.

     0040H-004FH      MA 16-byte area reserved for scratch by
X                      MCBIOS, but is not used for any purpose
X                      in the distribution version of CP/M.

     0050H-005BH      Not currently used; reserved.

     005CH-007CH      MDefault File Control Block produced for
X                      a transient program by the CCP.

     007DH-007FH      MOptional default random record position.
X
     0080H-00FFH      MDefault 128-byte disk buffer, also
X                      Mfilled with the command line when a
X                      transient is loaded under the CCP.
	9	K0

     MThis information is set up for normal operation under the CP/M
XMsystem, but can be overwritten by a transient program if the BDOS
Xfacilities are not required by the transient.

     MIf, for example, a particular program performs only simple I/O
XMand must begin execution at location 0, it can first be loaded into
XMthe TPA, using normal CP/M facilities, with a small memory move
XMprogram that gets control when loaded.  The memory move program must
XMget control from location 0100H, which is the assumed beginning of
XMall transient programs.  The move program can then proceed to the
XMentire memory image down to location 0 and pass control to the
Xstarting address of the memory load.

     MIf the BIOS is overwritten or if location 0, containing the
XMwarm start entry point, is overwritten, the operator must bring the
XCP/M system back into memory with a cold start sequence.


W6.10  Disk Parameter Tables

     MT&Sables are included in the BIOS that describe the particular
XMcharacteristics of the disk subsystem used with CP/M.  These tables
XMcan be either hand-coded, as shown in the sample CBIOS in Appendix
XMB, or automatically generated using the DISKDEF macro library, as
XMshown in Appendix F.  The purpose here is to describe the elements
Xof these tables.




                               6-23




CP/M Operating System Manual          6.10  Disk Parameter Tables



     MIn general, each disk drive has an associated (16-byte) disk
XMparameter header that contains information about the disk drive and
XMprovides a scratch pad area for certain BDOS operations.  The format
XMof the disk parameter header for each drive is shown in Figure 6-2,
Xwhere each element is a word (16-bit) value.



XLT     0000     0000     0000     DIRBUF     DPB     CSV     ALV
16b     16b      16b      16b      16b        16b     16b     16b


W            Figure 6-2.  Disk Parameter Header Format



     MThe meaning of each Disk Parameter Header (DPH) element is
Xdetailed in Table 6-7.


W               Table 6-7.  Disk Parameter Headers

  Disk Parameter                 Meaning
      Header
	9	F0
      XLT           MAddress of the logical-to-physical
X                    Mtranslation vector, if used for this
X                    Mparticular drive, or the value 0000H if no
X                    Msector translation takes place (that is,
X                    Mthe physical and logical sector numbers
X                    Mare the same).  Disk drives with identical
X                    Msector skew factors share the same
X                    translate tables.

      0000          MScratch pad values for use within the
X                    BDOS, initial value is unimportant.

      DIRBUF        MAddress of a 128-byte scratch pad area for
X                    Mdirectory operations within BDOS.  All
X                    DPHs address the same scratch pad area.

      DPB           MAddress of a disk parameter block for this
X                    Mdrive.  Drives with identical disk
X                    Mcharacteristics address the same disk
X                    parameter block.

      CSV           MAddress of a scratch pad area used for
X                    Msoftware check for changed disks.  This
X                    address is different for each DPH.

      ALV           MAddress of a scratch pad area used by the
X                    MBDOS to keep disk storage allocation
X                    Minformation.  This address is different
X                    for each DPH.


                               6-24



	9	K0

CP/M Operating System Manual          6.10  Disk Parameter Tables



     MGiven n disk drives, the DPHs are arranged in a table whose
XMfirst row of 16 bytes corresponds to drive 0, with the last row
XMcorresponding to drive n-1.  In the following figure the lable
XDPBASE defines the base address of the DPH table.



   DPBASE:

      00  XLT 00  0000  0000  0000  DIRBUF DBP 00 CSV 00 ALV 00

      01  XLT 01  0000  0000  0000  DIRBUF DBP 01 CSV 01 ALV 01
                                    .
                                    .
                                    .
     n-1  XLTn-1  0000  0000  0000  DIRBUF DBTn-1 CSVn-1 ALVn-1


W            Figure 6-3.  Disk Parameter Header Table



     MA responsibility of the SELDSK subroutine is to return the base
XMaddress of the DPH for the selected drive.  The following sequence
XMof operations returns the table address, with a 0000H returned if
Xthe selected drive does not exist.


        NDISKS      EQU     4         ;NUMBER OF DISK DRIVES
        .....
        SELDSK:     ;SELECT DISK GIVEN BY BC
                    LSI     H,0000H   ;ERROR CODE
                    MOV     A,C       ;DRIVE OK?
                    CPI     NDISKS    ;CY IF SO
                    RNC               ;RET IF ERROR
                    ;NO ERROR, CONTINUE
                    MOV     L,C       ;LOW(DISK)
                    MOV     H,B       ;HIGH(DISK)
                    DAD     H         ;*2
                    DAD     H         ;*4
                    DAD     H         ;*8
                    DAD     H         ;*16
                    LXI     D,DPBASE;FIRST DPH
                    DAD     D         ;DPH(DISK)
                    RET


     MThe translation vectors, XLT 00 through XLTn-1, are located
XMelsewhere in the BIOS, and simply correspond one-for-one with the
XMlogical sector numbers zero through the sector count 1.  The Disk
XMParameter Block (DPB) for each drive is more complex.  As shown in
XMFigure 6-4, particular DPB, that is addressed by one or more DPHs,
Xtakes the general form:



                               6-25





CP/M Operating System Manual          6.10  Disk Parameter Tables


    SPT   BSH   BLM   EXM   DSM   DRM   AL0   AL1   CKS   0FF
    16b   8b    8b    8b    16b   16b   8b    8b    16b   16b


W            Figure 6-4.  Disk Parameter Block Format



Mwhere each is a byte or word value, as shown by the 8b or 16b
Xindicator below the field.

     The following field abbreviations are used in Figure 6-4:


   o SPT is the total number of sectors per track.

   o MBSH is the data allocation block shift factor, determined by
X     the data block allocation size.

   o BLM is the data allocation block mask (2[BSH-1]).

   o MEXM is the extent mask, determined by the data block allocation
X     size and the number of disk blocks.

   o DSM determines the total storage capacity of the disk drive.

   o MDRM determines the total number of directory entries that can
X     Mbe stored on this drive.  AL0, AL1 determine reserved directory
X     blocks.

   o CKS is the size of the directory check vector.

   o M0FF is the number of reserved tracks at the beginning of the
X     (logical) disk.

MThe values of BSH and BLM determine the data allocation size BLS,
XMwhich is not an entry in the DPB.  Given that the designer has
XMselected a value for BLS, the values of BSH and BLM are shown Table
X6-8.


W                 Table 6-8.  BSH and BLM Values

                    BLS         BSH         BLM

                    1024         3            7
                    2048         4           15
                    4096         5           31
                    8192         6           63
                  16,384         7          127


Mwhere all values are in decimal.  The value of EXM depends upon both
XMthe BLS and whether the DSM value is less than 256 or greater than
X255, as shown in Table 6-9.


                               6-26





CP/M Operating System Manual          6.10  Disk Parameter Tables


W                     Table 6-9.  EXM Values

                    BLS             EXM values

                              DSM<256    DSM>255

                    1024         0         N/A
                    2048         1          0
                    4096         3          1
                    8192         7          3
                  16,384        15          7


     MThe value of DSM is the maximum data block number supported by
XMthis particular drive, measured in BLS units.  The product (DSM+1)
XMis the total number of bytes held by the drive and must be within
XMthe capacity of the physical disk, not counting the reserved
Xoperating system tracks.

     MThe DRM entry is the one less than the total number of
XMdirectory entries that can take on a 16-bit value.  The values of
XMAL0 and AL1, however, are determined by DRM.  The values AL0 and AL1
XMcan together be considered a string of 16-bits, as shown in Figure
X6-5.



                AL0                            AL1

 00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15


W                    Figure 6-5.  AL0 and AL1



     MPosition 00 corresponds to the high-order bit of the byte
XMlabeled AL0 and 15 corresponds to the low-order bit of the byte
XMlabeled AL1.  Each bit position reserves a data block for number of
XMdirectory entries, thus allowing a total of 16 data blocks to be
XMassigned for directory entries (bits are assigned starting at 00 and
XMfilled to the right until position 15).  Each directory entry
Xoccupies 32 bytes, resulting in the following tabulation:


W                  Table 6-10.   BLS Tabulation

                   BLS         Directory Entries

                    1024         32 times # bits
                    2048         64 times # bits
                    4096        128 times # bits
                    8192        256 times # bits
                  16,384        512 times # bits



                               6-27





CP/M Operating System Manual          6.10  Disk Parameter Tables



     MThus, if DRM = 127 (128 directory entries) and BLS = 1024,
XMthere are 32 directory entries per block, requiring 4 reserved
XMblocks.  In this case, the 4 high-order bits of AL0 are set,
Xresulting in the values AL0 = 0F0H and AL1 = 00H.

     MThe CKS value is determined as follows:  if the disk drive
XMmedia is removable, then CKS = (DRM+1)/4, where DRM is the last
XMdirectory entry number.  If the media are fixed, then set CKS = 0
X(no directory records are checked in this case).

     MFinally, the 0FF field determines the number of tracks that are
XMskipped at the beginning of the physical disk.  This value is
XMautomatically added whenever SETTRK is called and can be used as a
XMmechanism for skipping reserved operating system tracks or for
Xpartitioning a large disk into smaller segmented sections.

     MTo complete the discussion of the DPB, several DPHs can address
XMthe same DPB if their drive characteristics are identical.  Further,
XMthe DPB can be dynamically changed when a new drive is addressed by
XMsimply changing the pointer in the DPH; because the BDOS copies the
XMDPB values to a local area whenever the SELDSK function is invoked.
X
     MReturning back to DPH for a particular drive, the two address
XMvalues CSV and ALV remain.  Both addresses reference an area of
XMuninitialized memory following the BIOS.  The areas must be unique
XMfor each drive, and the size of each area is determined by the
Xvalues in the DPB.

     MThe size of the area addressed by CSV is CKS bytes, which is
XMsufficient to hold the directory check information for this
XMparticular drive,  If CKS = (DRM+1)/4, you must reserve (DRM+1)/4
XMbytes for directory check use.  If CKS = 0, no storage is reserved.
X
     MThe size of the area addressed by ALV is determined by the
XMmaximum number of data blocks allowed for this particular disk and
Xis computed as (DSM/8)+1.

     MThe CBIOS shown in Appendix B demonstrates an instance of these
XMtables for standard 8-inch, single-density drives.  It might be
XMuseful to examine this program and compare the tabular values with
Xthe definitions given above.


W6.11  The DISKDEF Macro Library

     MA&S macro library called DISKDEF (shown in Appendix F), greatly
XMsimplifies the table construction process.  You must have access to
XMthe MAC macro assembler, of course, to use the DISKDEF facility,
XMwhile the macro library is included with all CP.M 2 distribution
Xdisks.






                               6-28





CP/M Operating System Manual      6.11  The DISKDEF Macro Library



     MA BIOS disk definition consists of the following sequence of
Xmacro statements:

        MACLIB         DISKDEF
        .....
        DISKS          n
        DISKDEF        0,...
        DISKDEF        1,...
        .....
        DISKDEF        n-1
        .....
        ENDEF

Mwhere the MACLIB statement loads the DISKDEF.LIB file, on the same
XMdisk as the BIOS, into MAC's internal tables.  The DISKS macro call
XMfollows, which specifies the number of drives to be configured  with
XMthe user's system, where n is an integer in the range 1 to 16.  A
XMseries of DISKDEF macro calls then follow that define the
XMcharacteristics of each logical disk, 0 through n-1, corresponding
XMto logical drives A through P.  The DISKS and DISKDEF macros
XMgenerate the in-line fixed data tables described in the previous
XMsection and thus must be placed in a nonexecutable portion of the
XBIOS, typically directly following the BIOS jump vector.

     MThe remaining portion of the BIOS is defined following the
XMDISKDEF macros, with the ENDEF macro call immediately preceding the
XMEND statement.  The ENDEF (End of Diskdef) macro generates the
XMnecessary uninitialized RAM areas that are located in memory above
Xthe BIOS.

     The DISKDEF macro call takes the form:

        DISKDEF  dn,fsc,lsc,[skf],bls dks,dir,cks,ofs,[0]

where

   o dn is the logical disk number, 0 to n-1.
   o fsc is the first physical sector number (0 or 1).
   o lsc is the last sector number.
   o skf is the optional sector skew factor.
   o bls is the data allocation block size.
   o dks is the number of blocks on the disk.
   o dir is the number of directory entries.
   o cks is the number of checked directory entries.
   o ofs is the track offset to logical track 00.
   o [0] is an optional 1.4 compatibility flag.


     MThe value dn is the drive number being defined with this
XMDISKDEF macro invocation.  The fsc parameter accounts for differing
XMsector numbering systems and is usually 0 to 1.  The lsc is the last
XMnumbered sector on a track.  When present, the skf parameter defines
XMthe sector skew factor, which is used to create a sector translation
Xtable according to the skew.


                               6-29





CP/M Operating System Manual      6.11  The DISKDEF Macro Library



     MIf the number of sectors is less than 256, a single-byte table
XMis created, otherwise each translation table element occupies two
XMbytes.  No translation table is created if the skf parameter is
Xomitted, or equal to 0.

     MThe bls parameter specifies the number of bytes allocated to
XMeach data block, and takes on the values 1024, 2048, 4096, 8192, or
XM16384.  Generally, performance increases with larger data block
XMsizes because there are fewer directory references, and logically
XMconnected data records are physically close on the disk.  Further,
XMeach directory entry addresses more data and the BIOS-resident RAM
Xspace is reduced.

     MThe dks parameter specifies the total disk size in bls units.
XMThat is, if the bls = 2048 and dks = 1000, the total disk capacity
XMis 2,048,000 bytes.  If dks is greater than 255, the block size
XMparameter bls must be greater than 1024.  The value of dir is the
XMtotal number of directory entries that might exceed 255, if desired.
X
     MThe cks parameter determines the number of directory items to
XMcheck on each directory scan and is used internally to detect
XMchanged disks during system operation, where an intervening cold or
XMwarm start has not occurred.  When this situation is detected, CP/M
XMautomatically marks the disk Read-Only so that data is not
Xsubsequently destroyed.

     MAs stated in the previous section, the value of cks = dir when
XMthe medium is easily changed, as is the case with a floppy disk
XMsubsystem.  If the disk is permanently mounted, the value of cks is
XMtypically 0, because the probability of changing disks without a
Xrestart is low.

     MThe ofs value determines the number of tracks to skip when this
XMparticular drive is addressed, which can be used to reserve
XMadditional operating system space or to simulate several logical
XMdrives on a single large capacity physical drive.  Finally, the [0]
XMparameter is included when file compatibility is required with
XMversions of 1.4 that have been modified for higher density disks.
XMThis parameter ensures that only 16K is allocated for each directory
XMrecord, as was the case for previous versions.  Normally, this
Xparameter is not included.

     For convenience and economy of table space, the special form:

        DISKDEF      i,j

Mgives disk i the same characteristics as a previously defined drive
XMj.  A standard four-drive, single-density system, which is
XMcompatible with version 1.4, is defined using the following macro
Xinvocations:

        DISKS        4
        DISKDEF      0,1,26,6,1024,243,64,2
        DISKDEF      1,0


                               6-30





CP/M Operating System Manual      6.11  The DISKDEF Macro Library


        DISKDEF      2,0
        DISKDEF      3,0
        ....
        ENDEF

Mwith all disks having the same parameter values of 26 sectors per
XMtrack, numbered 1 through 26, with 6 sectors skipped between each
XMaccess, 1024 bytes per data block, 243 data blocks for a total of
XM243K-byte disk capacity, 64 checked directory entries, and two
Xoperating system tracks.

     MThe DISKS macro generates n DPHs, starting at the DPH table
XMaddress DPBASE generated by the macro.  Each disk header block
XMcontains sixteen bytes, as described above, and correspond one-for-
XMone to each of the defined drives.  In the four-drive standard
Xsystem, for example, the DISKS macro generates a table of the form:

     DPBASE     EQU$
     DPE0:      DW XLT0,0000H,0000H,0000H,DIRBUF,DPB0,CSV0,ALV0
     DPE1:      DW XLT0,0000H,0000H,0000H,DIRBUF,DPB0,CSV1,ALV1
     DPE2:      DW XLT0,0000H,0000H,0000H,DIRBUF,DPB0,CSV2,ALV2
     DPE3:      DW XLT0,0000H,0000H,0000H,DIRBUF,DPB0,CSV3,ALV3

Mwhere the DPH labels are included for reference purposes to show the
XMbeginning table addresses for each drive 0 through 3.  The values
XMcontained within the DPH are described in detail in the previous
XMsection.  The check and allocation vector addresses are generated by
XMthe ENDEF macro in the ram area following the BIOS code and tables.
X
     MNote that if the skf (skew factor) parameter is omitted, or
XMequal to 0, the translation table is omitted and a 0000H value is
XMinserted in the XLT position of the DPH for the disk.  In a
XMsubsequent call to perform the logical-to-physical translation,
XMSECTRAN receives a translation table address of DE = 0000H and
XMsimply returns the original logical sector from BC in the HL
Xregister pair.

     MA translate table is constructed when the skf parameter is
XMpresent, and the (nonzero) table address is placed into the
XMcorresponding DPHs.  The following for example, is constructed when
XMthe standard skew factor skf = 6 is specified in the DISKDEF macro
Xcall:

        XLT0:    DB    1,7,13,19,25,5,11,17,23,3,9,15,21
                 DB    2,8,14,20,26,6,12,18,24,4,10,16,22

     MFollowing the ENDEF macro call, a number of uninitialized data
XMareas are defined.  These data areas need not be a part of the BIOS
XMthat is loaded upon cold start, but must be available between the
XMBIOS and the end of memory.  The size of the uninitialized RAM area
XMis determined by EQU statements generated by the ENDEF macro.  For a
XMstandard four-drive system, the ENDEF macro might produce the
Xfollowing EQU statement:




                               6-31





CP/M Operating System Manual      6.11  The DISKDEF Macro Library


        4C72 =        BEGDAT EQU $
                      (data areas)

        4DB0 =        ENDDAT EQU $

        013C =        DATSIZ EQU $-BEGDAT

Mwhich indicates that uninitialized RAM begins at location 4C72H,
XMends at 4DB0H-1, and occupies 013CH bytes.  You must ensure that
Xthese addresses are free for use after the system is loaded.

     MAfter modification, you can use the STAT program to check drive
XMcharacteristics, because STAT uses the disk parameter block to
Xdecode the drive information.  A STAT command of the form:

        STAT d:DSK:

Mdecodes the disk parameter block for drive d (d=A,...,P) and
Xdisplays the following values:


        r:  128-byte record capacity
        k:  kilobyte drive capacity
        d:  32-byte directory entries
        c:  checked directory entries
        e:  records/extent
        b:  records/block
        s:  sectors/track
        t:  reserved tracks


     MThree examples of DISKDEF macro invocations are shown below
XMwith corresponding STAT parameter values.  The last example produces
Xa full 8-megabyte system.

                   DISKDEF 0,1,58,,2048,256,128,128,2
        r=4096,    k=512, d=128, c=128, e=256, b=16, s=58, t=2

                   DISKDEF 0,1,58,,2048,1024,300,0,2
        r=16348,   k=2048, d=300, c=0, e=128, b=16, s=58, t=2

                   DISKDEF 0,1,58,,16348,512,128,128,2
        r=65536,   k=8192, d=128, c=128, e=1024, b=128, s=58, t=2


W6.12  Sector Blocking and Deblocking

     MU&Spon each call to BIOS WRITE entry point, the CP/M BDOS
XMincludes information that allows effective sector blocking and
XMdeblocking where the host disk subsystem has a sector size that is a
XMmultiple of the basic 128-byte unit.  The purpose here is to present
XMa general-purpose algorithm that can be included within the BIOS and
XMthat uses the BDOS information to perform the operations
Xautomatically.



                               6-32





CP/M Operating System Manual        6.12  Blocking and Deblocking


     MOn each call to WRITE, the BDOS provides the following
Xinformation in register C:

        0   =   (normal sector write)
        1   =   (write to directory sector)
        2   =   (write to the first sector
                of a new data block)

     MCondition 0 occurs whenever the next write operation is into a
XMpreviously written area, such as a random mode record update; when
XMthe write is to other than the first sector of an unallocated block;
XMor when the write is not into the directory area.  Condition 1
XMoccurs when a write into the directory area is performed.  Condition
XM2 occurs when the first record (only) of a newly allocated data
XMblock is written.  In most cases, application programs read or write
XMmultiple 128-byte sectors in sequence; thus, there is little
XMoverhead involved in either operation when blocking and deblocking
XMrecords, because preread operations can be avoided when writing
Xrecords.

     MAppendix G lists the blocking and deblocking algorithms in
XMskeletal form; this file is included on your CP/M disk.  Generally,
XMthe algorithms map all CP/M sector read operations onto the host
XMdisk through an intermediate buffer that is the size of the host
XMdisk sector.  Throughout the program, values and variables that
XMrelate to the CP/M sector involved in a seek operation are prefixed
XMby sek, while those related to the host disk system are prefixed by
XMhst.  The equate statements beginning on line 29 of Appendix G
XMdefine the mapping between CP/M and the host system, and must be
Xchanged if other than the sample host system is involved.

     MThe entry points BOOT and WBOOT must contain the initialization
XMcode starting on line 57, while the SELDSK entry point must be
XMaugmented by the code starting on line 65.  Note that although the
XMSELDSK entry point computes and returns the Disk Parameter Header
XMaddress, it does not physically select the host disk at this point
XM(it is selected later at READHST or WRITEHST).  Further, SETTRK,
XMSETTRK, and SETMA simply store the values, but do not take any other
XMaction at this point.  SECTRAN performs a trivial function of
Xreturning the physical sector number.

     MThe principal entry points are READ and WRITE, starting on
XMlines 110 and 125, respectively.  These subroutines take the place
Xof your previous READ and WRITE operations.

     MThe actual physical read or write takes place at either
XMWRITEHST or READHST, where all values have been prepared:  hstdsk is
XMthe host disk number, hsttrk is the host track number, and hstsec is
XMthe host sector number, which may require translation to physical
XMsector number.  You must insert code at this point that performs the
XMfull sector read or write into or out of the buffer at hstbuf of
XMlength hstsiz.  All other mapping functions are performed by the
Xalgorithms.




                               6-33





CP/M Operating System Manual        6.12  Blocking and Deblocking


     MThis particular algorithm was tested using an 80-megabyte hard
XMdisk unit that was originally configured for 128-byte sectors,
XMproducing approximately 35 megabytes of formatted storage.  When
XMconfigured for 512-byte host sectors, usable storage increased to 57
XMmegabytes, with a corresponding 400% improvement in overall
XMresponse.  In this situation, there is no apparent overhead involved
XMin deblocking sectors, with the advantage that user programs still
XMmaintain 128-byte sectors.  This is primarily because of the
XMinformation provided by the BDOS, which eliminates the necessity for
Xpreread operations.


=End of Section 6












































                               6-34



