	N





















CP/M

Operating System

Manual










Copyright (c) 1982

Digital Research
P.O. Box 579
160 Central Avenue
Pacific Grove, CA 93950
(408) 649-3896
TWX 910 360 5001




All Rights Reserved

















C






COPYRIGHT

Copyright (c) 1976, 1977, 1978, 1979, 1982, 1983,
and 1984 by Digital Research Inc.  All rights
reserved.  No part of this publication may be
reproduced, transmitted, transcribed, stored in a
retrieval system, or translated into any language or
computer language, in any form or by any means,
electronic, mechanical, magnetic, optical, chemical,
manual or otherwise, without the prior written
permission of Digital Research Inc., Post Office Box
579, Pacific Grove, California, 93950.

Thus, readers are granted permission to include the
example programs, either in whole or in part, in
their own programs.


DISCLAIMER

Digital Research Inc. makes no representations or
warranties with respect to the contents hereof and
specifically disclaims any implied warranties of
merchantability or fitness for any particular
purpose.  Further, Digital Research Inc. reserves
the right to revise this publication and to make
changes from time to time in the content hereof
without obligation of Digital Research Inc. to
notify any person of such revision or changes.


TRADEMARKS

CP/M, CP/NET, and Digital Research and its logo are
registered trademarks of Digital Research.  ASM,
DESPOOL, DDT, LINK-80, MAC, MP/M, PL/I-80 and SID
are trademarks of Digital Research.  IBM is a
registered trademark of International Business
Machines.  Intel is a registered trademark of Intel
Corporation.  TI Silent 700 is a trademark of Texas
Instruments Incorporated.  Zilog and Z80 are
registered trademarks of Zilog, Inc.



The CP/M Operating System Manual was prepared using
the Digital Research TEX Text Formatter and printed
in the United States of America.


*********************************
*   First Edition:  1976        *
*  Second Edition:  July 1982   *
*   Third Edition:  March 1983  *
*  Fourth Edition:  March 1984  *
*********************************




K





Table of Contents



1  CP/M Features and Facilities

   1.1  Introduction  . . . . . . . . . . . . . . . . . . .   1-1

   1.2  Functional Description  . . . . . . . . . . . . . .   1-3

        1.2.1  General Command Structure  . . . . . . . . .   1-3
        1.2.2  File References  . . . . . . . . . . . . . .   1-3

   1.3  Switching Disks . . . . . . . . . . . . . . . . . .   1-5
   1.4  Built-in Commands . . . . . . . . . . . . . . . . .   1-6

        1.4.1  ERA Command  . . . . . . . . . . . . . . . .   1-6
        1.4.2  DIR Command  . . . . . . . . . . . . . . . .   1-7
        1.4.3  REN Command  . . . . . . . . . . . . . . . .   1-8
        1.4.4  SAVE Command . . . . . . . . . . . . . . . .   1-8
        1.4.5  TYPE Command . . . . . . . . . . . . . . . .   1-9
        1.4.6  USER Command . . . . . . . . . . . . . . . .   1-9

   1.5  Line Editing and Output Control . . . . . . . . . .  1-10

   1.6  Transient Commands  . . . . . . . . . . . . . . . .  1-11

        1.6.1  STAT Command . . . . . . . . . . . . . . . .  1-12
        1.6.2  ASM Command  . . . . . . . . . . . . . . . .  1-18
        1.6.3  LOAD Command . . . . . . . . . . . . . . . .  1-19
        1.6.4  PIP  . . . . . . . . . . . . . . . . . . . .  1-20
        1.6.5  ED Command . . . . . . . . . . . . . . . . .  1-29
        1.6.6  SYSGEN Command . . . . . . . . . . . . . . .  1-31
        1.6.7  SUBMIT Command . . . . . . . . . . . . . . .  1-33
        1.6.8  DUMP Command . . . . . . . . . . . . . . . .  1-35
        1.6.9  MOVCPM Command . . . . . . . . . . . . . . .  1-35

   1.7  BDOS Error Messages . . . . . . . . . . . . . . . .  1-37

   1.8  CP/M Operation on the Model 800 . . . . . . . . . .  1-38


2  The CP/M Editor

   2.1  Introduction to ED  . . . . . . . . . . . . . . . .   2-1

        2.1.1  ED Operation . . . . . . . . . . . . . . . .   2-1
        2.1.2  Text Transfer Functions  . . . . . . . . . .   2-3
        2.1.3  Memory Buffer Organization . . . . . . . . .   2-4
        2.1.4  Line Numbers and ED Start-up . . . . . . . .   2-5
        2.1.5  Memory Buffer Operation  . . . . . . . . . .   2-6
        2.1.6  Command Strings  . . . . . . . . . . . . . .   2-7
        2.1.7  Text Search and Alteration . . . . . . . . .  2-10
        2.1.8  Source Libraries . . . . . . . . . . . . . .  2-13
        2.1.9  Repetitive Command Execution . . . . . . . .  2-14


                               iii








Table of Contents

(continued)



   2.2  ED Error Conditions . . . . . . . . . . . . . . . .  2-14

   2.3  Control Characters and Commands . . . . . . . . . .  2-16


3  CP/M Assembler

   3.1  Introduction  . . . . . . . . . . . . . . . . . . .   3-1

   3.2  Program Format  . . . . . . . . . . . . . . . . . .   3-3

   3.3  Forming the Operand . . . . . . . . . . . . . . . .   3-4

        3.3.1  Labels . . . . . . . . . . . . . . . . . . .   3-4
        3.3.2  Numeric Constants  . . . . . . . . . . . . .   3-5
        3.3.3  Reserved Words . . . . . . . . . . . . . . .   3-5
        3.3.4  String Constants . . . . . . . . . . . . . .   3-6
        3.3.5  Arithmetic and Logical Operators . . . . . .   3-7
        3.3.6  Precedence of Operators  . . . . . . . . . .   3-8

   3.4  Assembler Directives  . . . . . . . . . . . . . . .   3-9

        3.4.1  The ORG Directive  . . . . . . . . . . . . .  3-10
        3.4.2  The END Directive  . . . . . . . . . . . . .  3-10
        3.4.3  The EQU Directive  . . . . . . . . . . . . .  3-11
        3.4.4  The SET Directive  . . . . . . . . . . . . .  3-11
        3.4.5  The IF and ENDIF Directives  . . . . . . . .  3-12
        3.4.6  The DB Directive . . . . . . . . . . . . . .  3-13
        3.4.7  The DW Directive . . . . . . . . . . . . . .  3-14
        3.4.8  The DS Directive . . . . . . . . . . . . . .  3-14

   3.5  Operation Codes . . . . . . . . . . . . . . . . . .  3-15

        3.5.1  Jumps, Calls, and Returns  . . . . . . . . .  3-15
        3.5.2  Immediate Operand Instructions . . . . . . .  3-17
        3.5.3  Increment and Decrement Instructions . . . .  3-17
        3.5.4  Data Movement Instructions . . . . . . . . .  3-18
        3.5.5  Arithmetic Logic Unit Operations . . . . . .  3-19
        3.5.6  Control Instructions . . . . . . . . . . . .  3-21

   3.6  Error Messages  . . . . . . . . . . . . . . . . . .  3-21

   3.7  A Sample Session  . . . . . . . . . . . . . . . . .  3-23








                               iv








Table of Contents

(continued)



4  CP/M Dynamic Debugging Tool

   4.1  Introduction  . . . . . . . . . . . . . . . . . . .   4-1

   4.2  DDT Commands  . . . . . . . . . . . . . . . . . . .   4-3

        4.2.1  The A (Assembly) Command . . . . . . . . . .   4-3
        4.2.2  The D (Display) Command  . . . . . . . . . .   4-4
        4.2.3  The F (Fill) Command . . . . . . . . . . . .   4-5
        4.2.4  The G (Go) Command . . . . . . . . . . . . .   4-5
        4.2.5  The I (Input) Command  . . . . . . . . . . .   4-6
        4.2.6  The L (List) Command . . . . . . . . . . . .   4-6
        4.2.7  The M (Move) Command . . . . . . . . . . . .   4-7
        4.2.8  The R (Read) Command . . . . . . . . . . . .   4-7
        4.2.9  The S (Set) Command  . . . . . . . . . . . .   4-8
        4.2.1- The T (Trace) Command  . . . . . . . . . . .   4-8
        4.2.11 The U (Untrace) Command  . . . . . . . . . .   4-9
        4.2.12 The X (Examine) Command  . . . . . . . . . .   4-9

   4.3  Implementation Notes  . . . . . . . . . . . . . . .  4-10

   4.4  A Sample Program  . . . . . . . . . . . . . . . . .  4-11


5  CP/M 2 System Interface

   5.1  Introduction  . . . . . . . . . . . . . . . . . . .   5-1

   5.2  Operating System Call Conventions . . . . . . . . .   5-3

   5.3  A Sample File-to-File Copy Program  . . . . . . . .  5-35

   5.4  A Sample File Dump Utility  . . . . . . . . . . . .  5-38

   5.5  A Sample Random Access Program  . . . . . . . . . .  5-42

   5.6  System Function Summary . . . . . . . . . . . . . .  5-50


6  CP/M 2 Alteration

   6.1  Introduction  . . . . . . . . . . . . . . . . . . .   6-1

   6.2  First-level System Regeneration . . . . . . . . . .   6-2

   6.3  Second-level System Generation  . . . . . . . . . .   6-5

   6.4  Sample GETSYS and PUTSYS Programs . . . . . . . . .   6-9



                               v








Table of Contents

(continued)



   6.5  Disk Organization . . . . . . . . . . . . . . . . .  6-11

   6.6  The BIOS Entry Points . . . . . . . . . . . . . . .  6-13

   6.7  A Sample BIOS . . . . . . . . . . . . . . . . . . .  6-21

   6.8  A Sample Cold Start Loader  . . . . . . . . . . . .  6-21

   6.9  Reserved Locations in Page Zero . . . . . . . . . .  6-22

   6.10  Disk Parameter Tables  . . . . . . . . . . . . . .  6-23

   6.11  The DISKDEF Macro Library  . . . . . . . . . . . .  6-28

   6.12  Sector Blocking and Deblocking . . . . . . . . . .  6-32




































                               vi








Appendixes



A  Basic Input/Output System (BIOS)  . . . . . . . . . . .   A-1


B  A Skeletal CBIOS  . . . . . . . . . . . . . . . . . . .   B-1


C  A Skeletal GETSYS/PUTSYS Program  . . . . . . . . . . .   C-1


D  The Model 800 Cold Start Loader for CP/M 2  . . . . . .   D-1


E  A Skeletal Cold Start Loader  . . . . . . . . . . . . .   E-1


F  CP/M Disk Definition Library  . . . . . . . . . . . . .   F-1


G  Blocking and Deblocking Algorithms  . . . . . . . . . .   G-1


H  Glossary  . . . . . . . . . . . . . . . . . . . . . . .   H-1


I  CP/M Error Messages . . . . . . . . . . . . . . . . . .   I-1




























                               vii








Tables, Figures, and Listings



Tables

     1-1.   Line-editing Control Characters . . . . . . . .  1-10
     1-2.   CP/M Transient Commands . . . . . . . . . . . .  1-11
     1-3.   Physical Devices  . . . . . . . . . . . . . . .  1-14
     1-4.   PIP Parameters  . . . . . . . . . . . . . . . .  1-24

     2-1.   ED Text Transfer Commands . . . . . . . . . . .   2-3
     2-2.   Editing Commands  . . . . . . . . . . . . . . .   2-6
     2-3.   Line-editing Controls . . . . . . . . . . . . .   2-7
     2-4.   Error Message Symbols . . . . . . . . . . . . .  2-13
     2-5.   ED Control Characters . . . . . . . . . . . . .  2-14
     2-6.   ED Commands . . . . . . . . . . . . . . . . . .  2-15

     3-1.   Reserved Characters . . . . . . . . . . . . . .   3-6
     3-2.   Arithmetic and Logical Operators  . . . . . . .   3-7
     3-3.   Assembler Directives  . . . . . . . . . . . . .   3-9
     3-4.   Jumps, Calls, and Returns . . . . . . . . . . .  3-15
     3-5.   Immediate Operand Instructions  . . . . . . . .  3-16
     3-6.   Increment and Decrement Instructions  . . . . .  3-17
     3-7.   Data Movement Instructions  . . . . . . . . . .  3-17
     3-8.   Arithmetic Logic Unit Operations  . . . . . . .  3-18
     3-9.   Error Codes . . . . . . . . . . . . . . . . . .  3-20
     3-10.  Error Messages  . . . . . . . . . . . . . . . .  3-21

     4-1.   Line-editing Controls . . . . . . . . . . . . .   4-2
     4-2.   DDT Commands  . . . . . . . . . . . . . . . . .   4-2
     4-3.   CPU Registers . . . . . . . . . . . . . . . . .   4-9

     5-1.   CP/M Filetypes  . . . . . . . . . . . . . . . .   5-6
     5-2.   File Control Block Fields . . . . . . . . . . .   5-7
     5-3.   Edit Control Characters . . . . . . . . . . . .  5-20

     6-1.   Standard Memory Size Values . . . . . . . . . .   6-2
     6-2.   Common Values for CP/M Systems  . . . . . . . .   6-7
     6-3.   CP/M Disk Sector Allocation . . . . . . . . . .  6-11
     6-4.   IOBYTE Field Values . . . . . . . . . . . . . .  6-15
     6-5.   BIOS Entry Points . . . . . . . . . . . . . . .  6-16
     6-6.   Reserved Locations in Page Zero . . . . . . . .  6-21
     6-7.   Disk Parameter Headers  . . . . . . . . . . . .  6-23
     6-8.   BSH and BLM Values  . . . . . . . . . . . . . .  6-25
     6-9.   EXM Values  . . . . . . . . . . . . . . . . . .  6-25
     6-10.  BLS Tabluation  . . . . . . . . . . . . . . . .  6-26

     I-1.   CP/M Error Messages . . . . . . . . . . . . . .   I-1


Figures

     2-1.   Overall ED Operation  . . . . . . . . . . . . .   2-2
     2-2.   Memory Buffer Organization  . . . . . . . . . .   2-2


                               viii








Tables, Figures, and Listings

(continued)



Figures

     2-3.   Logical Organization of Memory Buffer . . . . .   2-4

     5-1.   CP/M Memory Organization  . . . . . . . . . . .   5-1
     5-2.   File Control Block Format . . . . . . . . . . .   5-7

     6-1.   IOBYTE Fields . . . . . . . . . . . . . . . . .  6-15
     6-2.   Disk Parameter Header Format  . . . . . . . . .  6-22
     6-3.   Disk Parameter Header Table . . . . . . . . . .  6-23
     6-4.   Disk Parameter Block Format . . . . . . . . . .  6-24
     6-5.   AL0 and AL1 . . . . . . . . . . . . . . . . . .  6-25


Listings

     6-1.   GETSYS Program  . . . . . . . . . . . . . . . .   6-9
     6-2.   BIOS Entry Points . . . . . . . . . . . . . . .  6-13

































                               ix








Section 1

CP/M Features and Facilities



1.1  Introduction

     CP/M  is a monitor control program for microcomputer system
development that uses floppy disks or Winchester hard disks for
backup storage.  Using a computer system based on the Intel  8080
microcomputer, CP/M provides an environment for program
construction, storage, and editing, along with assembly and program
check-out facilities.  CP/M can be easily altered to execute with
any computer configuration that uses a Zilog  Z80  or an Intel 8080
Central Processing Unit (CPU) and has at least 20K bytes of main
memory with up to 16 disk drives.  A detailed discussion of the
modifications required for any particular hardware environment is
given in Section 6.  Although the standard Digital Research version
operates on a single-density Intel Model 800, microcomputer
development system several different hardware manufacturers support
their own input-output (I/O) drivers for CP/M.

     The CP/M monitor provides rapid access to programs through a
comprehensive file management package.  The file subsystem supports
a named file structure, allowing dynamic allocation of file space as
well as sequential and random file access.  Using this file system,
a large number of programs can be stored in both source and machine-
executable form.

     CP/M 2 is a high-performance, single console operating system
that uses table-driven techniques to allow field reconfiguration to
match a wide variety of disk capacities.  All fundamental file
restrictions are removed, maintaining upward compatibility from
previous versions of release 1.

     Features of CP/M 2 include field specification of one to
sixteen logical drives, each containing up to eight megabytes.  Any
particular file can reach the full drive size with the capability of
expanding to thirty-two megabytes in future releases.  The directory
size can be field-configured to contain any reasonable number of
entries, and each file is optionally tagged with Read-Only and
system attributes.  Users of CP/M 2 are physically separated by user
numbers, with facilities for file copy operations from one user area
to another.  Powerful relative-record random access functions are
present in CP/M 2 that provide direct access to any of the 65536
records of an eight-megabyte file.

     CP/M also supports ED, a powerful context editor, ASM , an
Intel-compatible assembler, and DDT , debugger subsystems.  Optional
software includes a powerful Intel-compatible macro assembler,
symbolic debugger, along with various high-level languages.  When
coupled with CP/M's Console Command Processor (CCP), the resulting
facilities equal or exceed similar large computer facilities.



                               1-1





CP/M Operating System Manual                    1.1  Introduction


     CP/M is logically divided into several distinct parts:

   o BIOS (Basic I/O System), hardware-dependent
   o BDOS (Basic Disk Operating System)
   o CCP (Console Command Processor)
   o TPA (Transient Program Area)

     The BIOS provides the primitive operations necessary to access
the disk drives and to interface standard peripherals:  teletype,
CRT, paper tape reader/punch, and user-defined peripherals.  You can
tailor peripherals for any particular hardware environment by
patching this portion of CP/M.  The BDOS provides disk management by
controlling one or more disk drives containing independent file
directories.  The BDOS implements disk allocation strategies that
provide fully dynamic file construction while minimizing head
movement across the disk during access.  The BDOS has entry points
that include the following primitive operations, which the program
accesses:

   o SEARCH looks for a particular disk file by name.
   o OPEN opens a file for further operations.
   o CLOSE closes a file after processing.
   o RENAME changes the name of a particular file.
   o READ reads a record from a particular file.
   o WRITE writes a record to a particular file.
   o SELECT selects a particular disk drive for further operations.

     The CCP provides a symbolic interface between your console and
the remainder of the CP/M system.  The CCP reads the console device
and processes commands, which include listing the file directory,
printing the contents of files, and controlling the operation of
transient programs, such as assemblers, editors, and debuggers.  The
standard commands that are available in the CCP are listed in
Section 1.2.1.

     The last segment of CP/M is the area called the Transient
Program Area (TPA).  The TPA holds programs that are loaded from the
disk under command of the CCP.  During program editing, for example,
the TPA holds the CP/M text editor machine code and data areas.
Similarly, programs created under CP/M can be checked out by loading
and executing these programs in the TPA.

     Any or all of the CP/M component subsystems can be overlaid by
an executing program.  That is, once a user's program is loaded into
the TPA, the CCP, BDOS, and BIOS areas can be used as the program's
data area.  A bootstrap loader is programmatically accessible
whenever the BIOS portion is not overlaid; thus, the user program
need only branch to the bootstrap loader at the end of execution and
the complete CP/M monitor is reloaded from disk.

     The CP/M operating system is partitioned into distinct modules,
including the BIOS portion that defines the hardware environment in
which CP/M is executing.  Thus, the standard system is easily
modified to any nonstandard environment by changing the peripheral
drivers to handle the custom system.


                               1-2





CP/M Operating System Manual          1.2  Functional Description


1.2  Functional Description

     You interact with CP/M primarily through the CCP, which reads
and interprets commands entered through the console.  In general,
the CCP addresses one of several disks that are on-line.  The
standard system addresses up to sixteen different disk drives.
These disk drives are labeled A through P.  A disk is logged-in if
the CCP is currently addressing the disk.  To clearly indicate which
disk is the currently logged disk, the CCP always prompts the
operator with the disk name followed by the symbol >, indicating
that the CCP is ready for another command.  Upon initial start-up,
the CP/M system is loaded from disk A, and the CCP displays the
following message:

        CP/M VER x.x

where x.x is the CP/M version number.  All CP/M systems are
initially set to operate in a 20K memory space, but can be easily
reconfigured to fit any memory size on the host system (see Section
1.6.9).  Following system sign-on, CP/M automatically logs in disk
A, prompts you with the symbol A>, indicating that CP/M is currently
addressing disk A, and waits for a command.  The commands are
implemented at two levels:  built-in commands and transient
commands.


1.2.1  General Command Structure

     Built-in commands are a part of the CCP program, while
transient commands are loaded into the TPA from disk and executed.
The following are built-in commands:

   o ERA erases specified files.
   o DIR lists filenames in the directory.
   o REN renames the specified file.
   o SAVE saves memory contents in a file.
   o TYPE types the contents of a file on the logged disk.

Most of the commands reference a particular file or group of files.
The form of a file reference is specified in Section 1.2.2.


1.2.2  File References

     A file reference identifies a particular file or group of files
on a particular disk attached to CP/M.  These file references are
either unambiguous (ufn) or ambiguous (afn).  An unambiguous file
reference uniquely identifies a single file, while an ambiguous file
reference is satisfied by a number of different files.

     File references consist of two parts:  the primary filename and
the filetype.  Although the filetype is optional, it usually is
generic.  For example, the filetype ASM is used to denote that the
file is an assembly language source file, while the primary filename
distinguishes each particular source file.  The two names are
separated by a period, as shown in the following example:

                               1-3





CP/M Operating System Manual          1.2  Functional Description


        filename.typ

In this example, filename is the primary filename of eight
characters or less, and typ is the filetype of no more than three
characters.  As mentioned above, the name

        filename

is also allowed and is equivalent to a filetype consisting of three
blanks.  The characters used in specifying an unambiguous file
reference cannot contain any of the following special characters:

        < > . , ; : = ? * [ ] _ % | ( ) / \textbackslash

while all alphanumerics and remaining special characters are
allowed.

     An ambiguous file reference is used for directory search and
pattern matching.  The form of an ambiguous file reference is
similar to an unambiguous reference, except the symbol ? can be
interspersed throughout the primary and secondary names.  In various
commands throughout CP/M, the ? symbol matches any character of a
filename in the ? position.  Thus, the ambiguous reference

        X?Z.C?M

matches the following unambiguous filenames

        XYZ.COM

and

        X3Z.CAM

The * wildcard character can also be used in an ambiguous file
reference.  The * character replaces all or part of a filename or
filetype.  Note that

        *.*

equals the ambiguous file reference

        ????????.???

while

        filename.*

and

        *.typ

are abbreviations for

        filename.???


                               1-4





CP/M Operating System Manual          1.2  Functional Description



and

        ????????.typ

respectively.  As an example,

        A>DIR *.*

is interpreted by the CCP as a command to list the names of all disk
files in the directory.  The following example searches only for a
file by the name X.Y:

        A>DIR X,Y

Similarly, the command

        A>DIR X?Y.C?M

causes a search for all unambiguous filenames on the disk that
satisfy this ambiguous reference.

     The following file references are valid unambiguous file
references:

        X
        X.Y
        XYZ
        XYZ.COM
        GAMMA
        GAMMA.1

     As an added convenience, the programmer can generally specify
the disk drive name along with the filename.  In this case, the
drive name is given as a letter A through P followed by a colon (:).
The specified drive is then logged-in before the file operation
occurs.  Thus, the following are valid file references with disk
name prefixes:

        A:X.Y
        P:XYZ.COM
        B:XYZ
        B:X.A?M
        C:GAMMA
        C:*.ASM

All alphabetic lower-case letters in file and drive names are
translated to upper-case when they are processed by the CCP.


1.3  Switching Disks

     The operator can switch the currently logged disk by typing the
disk drive name, A through P, followed by a colon when the CCP is
waiting for console input.  The following sequence of prompts and
commands can occur after the CP/M system is loaded from disk A:

                               1-5





CP/M Operating System Manual                 1.3  Switching Disks



        CP/M VER 2.2
        A>DIR                     List all files on disk A.
        A:SAMPLE ASM SAMPLE PRN
        A>B:                      Switch to disk B.
        B>DIR *.ASM               List all ASM files on B.
        B:DUMP ASM FILES ASM
        b>A:                      Switch back to A.


1.4  Built-in Commands

     The file and device reference forms described can now be used
to fully specify the structure of the built-in commands.  Assume the
following abbreviations in the description below:

        ufn   unambiguous file reference
        afn   ambiguous file reference

Recall that the CCP always translates lower-case characters to
upper-case characters internally.  Thus, lower-case alphabetics are
treated as if they are upper-case in command names and file
references.


1.4.1  ERA Command

Syntax:

        ERA afn

     The ERA (erase) command removes files from the currently
logged-in disk, for example, the disk name currently prompted by
CP/M preceding the >.  The files that are erased are those that
satisfy the ambiguous file reference afn.  The following examples
illustrate the use of ERA:


        ERA X.Y         The file named X.Y on the currently logged
                        disk is removed from the disk directory and
                        the space is returned.

        ERA X.*         All files with primary name X are removed
                        from the current disk.

        ERA *.ASM       All files with secondary name ASM are
                        removed from the current disk.

        ERA X?Y.C?M     All files on the current disk that satisfy
                        the ambiguous reference X?Y.C?M are
                        deleted.






                               1-6





CP/M Operating System Manual               1.4  Built-in Commands


        ERA *.*         Erase all files on the current disk.  In
                        this case, the CCP prompts the console with
                        the message

                        ALL FILES (Y/N)?

                        which requires a Y response before files
                        are actually removed.

        ERA b:*.PRN     All files on drive B that satisfy the
                        ambiguous reference ????????.PRN are
                        deleted, independently of the currently
                        logged disk.



1.4.2  DIR Command

Syntax:

        DIR afn

     The DIR (directory) command causes the names of all files that
satisfy the ambiguous filename afn to be listed at the console
device.  As a special case, the command

        DIR

lists the files on the currently logged disk (the command DIR is
equivalent to the command DIR *.*).  The following are valid DIR
commands:

        DIR X.Y
        DIR X?Z.C?M
        DIR ??.Y

     Similar to other CCP commands, the afn can be preceded by a
drive name.  The following DIR commands cause the selected drive to
be addressed before the directory search takes place:

        DIR B:
        DIR B:X.Y
        DIR B:*.A?M

     If no files on the selected disk satisfy the directory request,
the message NO FILE appears at the console.











                               1-7





CP/M Operating System Manual               1.4  Built-in Commands


1.4.3  REN Command

Syntax:

        REN ufn1=ufn2

     The REN (rename) command allows you to change the names of
files on disk.  The file satisfying ufn2 is changed to ufn1.  The
currently logged disk is assumed to contain the file to rename
(ufn2).  You can also type a left-directed arrow instead of the
equal sign if the console supports this graphic character.  The
following are examples of the REN command:


        REN X.Y=Q.R            The file Q.R is changed to X.Y.

        REN XYZ.COM=XYZ.XXX    The file XYZ.XXX is changed to
                               XYZ.COM.


     The operator precedes either ufn1 or ufn2 (or both) by an
optional drive address.  If ufn1 is preceded by a drive name, then
ufn2 is assumed to exist on the same drive.  Similarly, if ufn2 is
preceded by a drive name, then ufn1 is assumed to exist on the drive
as well.  The same drive must be specified in both cases if both
ufn1 and ufn2 are preceded by drive names.  The following REN
commands illustrate this format:


        REN A:X.ASM=Y.ASM      The file Y.ASM is changed to X.ASM
                               on drive A.

        REN B:ZAP.BAS=ZOT.BAS  The file ZOT.BAS is changed to
                               ZAP.BAS on drive B.

        REN B:A.ASM=B:A.BAK    The file A.BAK is renamed to A.ASM
                               on drive B.


     If ufn1 is already present, the REN command responds with the
error FILE EXISTS and not perform the change.  If ufn2 does not
exist on the specified disk, the message NO FILE is printed at the
console.


1.4.4  SAVE Command

Syntax:

        SAVE n ufn

     The SAVE command places n pages (256-byte blocks) onto disk
from the TPA and names this file ufn.  In the CP/M distribution
system, the TPA starts at 100H (hexadecimal) which is the second
page of memory.  The SAVE command must specify 2 pages of memory if


                               1-8





CP/M Operating System Manual               1.4  Built-in Commands


the user's program occupies the area from 100H through 2FFH.  The
machine code file can be subsequently loaded and executed.  The
following are examples of the SAVE command:


        SAVE 3X.COM            Copies 100H through 3FFH to X.COM.

        SAVE 40 Q              Copies 100H through 28FFH to Q.
                               Note that 28 is the page count in
                               28FFH, and that 28H = 2*16+8=40
                               decimal.

        SAVE 4 X.Y             Copies 100H through 4FFH to X.Y.


The SAVE command can also specify a disk drive in the ufn portion of
the command, as shown in the following example:

        SAVE 10 B:ZOT.COM      Copies 10 pages, 100H through 0AFFH,
                               to the file ZOT.COM on drive B.



1.4.5  TYPE Command

Syntax:

        TYPE ufn

     The TYPE command displays the content of the ASCII source file
ufn on the currently logged disk at the console device.  The
following are valid TYPE commands:

        TYPE X.Y
        TYPE X.PLM
        TYPE XXX

     The TYPE command expands tabs, CTRL-I characters, assuming tab
positions are set at every eighth column.  The ufn can also
reference a drive name.

        TYPE B:X.PRN    The file X.PRN from drive B is displayed.


1.4.6  USER Command

Syntax:

        USER n

     The USER command allows maintenance of separate files in the
same directory.  In the syntax line, n is an integer value in the
range 0 to 15.  On cold start, the operator is automatically logged
into user area number 0, which is compatible with standard CP/M 1
directories.  You can issue the USER command at any time to move to


                               1-9





CP/M Operating System Manual               1.4  Built-in Commands


another logical area within the same directory.  Drives that are
logged-in while addressing one user number are automatically active
when the operator moves to another.  A user number is simply a
prefix that accesses particular directory entries on the active
disks.

     The active user number is maintained until changed by a
subsequent USER command, or until a cold start when user 0 is again
assumed.


1.5  Line Editing and Output Control

     The CCP allows certain line-editing functions while typing
command lines.  The CTRL-key sequences are obtained by pressing the
control and letter keys simultaneously.  Further, CCP command lines
are generally up to 255 characters in length; they are not acted
upon until the carriage return key is pressed.


Table 1-1.  Line-editing Control Characters

F
     Character                      Meaning

      CTRL-C      Reboots CP/M system when pressed at start of
                  line.

      CTRL-E      Physical end of line; carriage is returned,
                  but line is not sent until the carriage
                  return key is pressed.

      CTRL-H      Backspaces one character position.

      CTRL-J      Terminates current input (line feed).

      CTRL-M      Terminates current input (carriage return).

      CTRL-P      Copies all subsequent console output to the
                  currently assigned list device (see Section
                  1.6.1).  Output is sent to the list device
                  and the console device until the next CTRL-P
                  is pressed.

      CTRL-R      Retypes current command line; types a clean
                  line following character deletion with
                  rubouts.

      CTRL-S      Stops the console output temporarily.
                  Program execution and output continue when
                  you press any character at the console, for
                  example another CTRL-S.  This feature stops
                  output on high speed consoles, such as CRTs,
                  in order to view a segment of output before
                  continuing.



                               1-10



K


CP/M Operating System Manual 1.5  Line Editing and Output Control


Table 1-1.  (continued)

F
     Character                      Meaning

      CTRL-U      Deletes the entire line typed at the
                  console.

      CTRL-X      Same as CTRL-U.

      CTRL-Z      Ends input from the console (used in PIP and
                  ED).

      RUB/DEL     Deletes and echoes the last character typed
                  at the console.
K


1.6  Transient Commands

     Transient commands are loaded from the currently logged disk
and executed in the TPA.  The transient commands for execution under
the CCP are below.  Additional functions are easily defined by the
user (see Section 1.6.3).


Table 1-2.  CP/M Transient Commands

F
     Command                      Function

     STAT       Lists the number of bytes of storage remaining
                on the currently logged disk, provides
                statistical information about particular
                files, and displays or alters device
                assignment.

     ASM        Loads the CP/M assembler and assembles the
                specified program from disk.

     LOAD       Loads the file in Intel HEX machine code
                format and produces a file in machine
                executable form which can be loaded into the
                TPA.  This loaded program becomes a new
                command under the CCP.

     DDT        Loads the CP/M debugger into TPA and starts
                execution.

     PIP        Loads the Peripheral Interchange Program for
                subsequent disk file and peripheral transfer
                operations.

     ED         Loads and executes the CP/M text editor
                program.

     SYSGEN     Creates a new CP/M system disk.



                               1-11



K


CP/M Operating System Manual              1.6  Transient Commands


Table 1-2.  (continued)

F
     Command                      Function

     SUBMIT     Submits a file of commands for batch
                processing.

     DUMP       Dumps the contents of a file in hex.

     MOVCPM     Regenerates the CP/M system for a particular
                memory size.

K

     Transient commands are specified in the same manner as built-in
commands, and additional commands are easily defined by the user.
For convenience, the transient command can be preceded by a drive
name which causes the transient to be loaded from the specified
drive into the TPA for execution.  Thus, the command

        B:STAT

causes CP/M to temporarily log in drive B for the source of the STAT
transient, and then return to the original logged disk for
subsequent processing.


1.6.1  STAT Command

Syntax:

        STAT
        STAT "command line"

     The STAT command provides general statistical information about
file storage and device assignment.  Special forms of the command
line allow the current device assignment to be examined and altered.
The various command lines that can be specified are shown with an
explanation of each form to the right.


        STAT            If you type an empty command line, the STAT
                        transient calculates the storage remaining
                        on all active drives, and prints one of the
                        following messages:

                        d: R/W, SPACE:  nnnK

                        d: R/O, SPACE:  nnnK

                        for each active drive d:, where R/W
                        indicates the drive can be read or written,
                        and R/O indicates the drive is Read-Only (a
                        drive becomes R/O by explicitly setting it
                        to Read-Only, as shown below, or by
                        inadvertently changing disks without


                               1-12





CP/M Operating System Manual              1.6  Transient Commands


                        performing a warm start).  The space
                        remaining on the disk in drive d: is given
                        in kilobytes by nnn.

        STAT d:         If a drive name is given, then the drive is
                        selected before the storage is computed.
                        Thus, the command STAT B: could be issued
                        while logged into drive A, resulting in the
                        message

                        BYTES REMAINING ON B:  nnnK

        STAT afn        The command line can also specify a set of
                        files to be scanned by STAT.  The files
                        that satisfy afn are listed in alphabetical
                        order, with storage requirements for each
                        file under the heading:

                        RECS BYTES EXT D:FILENAME.TYP
                        rrrr bbbK ee d:filename.typ

                        where rrrr is the number of 128-byte
                        records allocated to the file, bbb is the
                        number of kilobytes allocated to the file
                        (bbb=rrrr*128/1024), ee is the number of
                        16K extensions (ee=bbb/16), d is the drive
                        name containing the file (A...P), filename
                        is the eight-character primary filename,
                        and typ is the three-character filetype.
                        After listing the individual files, the
                        storage usage is summarized.

        STAT d:afn      The drive name can be given ahead of the
                        afn.  The specified drive is first
                        selected, and the form STAT afn is
                        executed.

        STAT d:=R/O     This form sets the drive given by d to
                        Read-Only, remaining in effect until the
                        next warm or cold start takes place.  When
                        a disk is Read-Only, the message

                        BDOS ERR ON d:  Read-Only

                        appears if there is an attempt to write to
                        the Read-Only disk.  CP/M waits until a key
                        is pressed before performing an automatic
                        warm start, at which time the disk becomes
                        R/W.








                               1-13





CP/M Operating System Manual              1.6  Transient Commands



     The STAT command allows you to control the physical-to-logical
device assignment.  See the IOBYTE function described in Sections 5
and 6.  There are four logical peripheral devices that are, at any
particular instant, each assigned one of several physical peripheral
devices.  The following is a list of the four logical devices:


   o CON: is the system console device, used by CCP for
     communication with the operator.

   o RDR: is the paper tape reader device.

   o PUN: is the paper tape punch device.

   o LST: is the output list device.


     The actual devices attached to any particular computer system
are driven by subroutines in the BIOS portion of CP/M.  Thus, the
logical RDR: device, for example, could actually be a high speed
reader, teletype reader, or cassette tape.  To allow some
flexibility in device naming and assignment, several physical
devices are defined in Table 1-3.


Table 1-3.  Physical Devices
F

     Device                       Meaning

      TTY:    Teletype device (slow speed console)

      CRT:    Cathode ray tube device (high speed console)

      BAT:    Batch processing (console is current RDR:,
              output goes to current LST: device)

      UC1:    User-defined console

      PTR:    Paper tape reader (high speed reader)

      UR1:    User-defined reader #1

      UR2:    User-defined reader #2

      PTP:    Paper tape punch (high speed punch)

      UP1:    User-defined punch #1

      UP2:    User-defined punch #2

      LPT:    Line printer

      UL1:    User-defined list device #1
K



                               1-14





CP/M Operating System Manual              1.6  Transient Commands



     It is emphasized that the physical device names might not
actually correspond to devices that the names imply.  That is, you
can implement the PTP: device as a cassette write operation.  The
exact correspondence and driving subroutine is defined in the BIOS
portion of CP/M.  In the standard distribution version of CP/M,
these devices correspond to their names on the Model 800 development
system.

     The command,

        STAT VAL:

produces a summary of the available status commands, resulting in
the output:

        Temp R/O Disk d:$R/O
        Set Indicator: filename.typ $R/O $R/W $SYS $DIR
        Disk Status: DSK: d:DSK
        Iobyte Assign:

which gives an instant summary of the possible STAT commands and
shows the permissible logical-to-physical device assignments:

        CON: = TTY: CRT: BAT: UC1:
        RDR: = TTY: PTR: UR1: UR2:
        PUN: = TTY: PTP: UP1: UP2:
        LST: = TTY: CRT: LPT: UL1:

The logical device to the left takes any of the four physical
assignments shown to the right.  The current logical-to-physical
mapping is displayed by typing the command:

        STAT DEV:

This command produces a list of each logical device to the left and
the current corresponding physical device to the right.  For
example, the list might appear as follows:

        CON: = CRT:
        RDR: = UR1:
        PUN: = PTP:
        LST: = TTY:

The current logical-to-physical device assignment is changed by
typing a STAT command of the form:

        STAT ld1 = pd1, ld2 = pd2, ... , ldn = pdn

where ld1 through ldn are logical device names and pd1 through pdn
are compatible physical device names.  For example, ldi and pdi
appear on the same line in the VAL: command shown above.  The
following example shows valid STAT commands that change the current
logical-to-physical device assignments:



                               1-15





CP/M Operating System Manual              1.6  Transient Commands


        STAT CON:=CRT:
        STAT PUN:=TTY:, LST:=LPT:, RDR:=TTY:

     The command form,

        STAT d:filename.typ $S

where d: is an optional drive name and filename.typ is an
unambiguous or ambiguous filename, produces the following output
display format:


        Size        Recs      Bytes          Ext Acc

           48        48         6K       1 R/O A:ED.COM
           55        55        12K       1 R/O (A:PIP.COM)
        65536       128        16K       2 R/W A:X.DAT


where the $S parameter causes the Size field to be displayed.
Without the $S, the Size field is skipped, but the remaining fields
are displayed.  The Size field lists the virtual file size in
records, while the Recs field sums the number of virtual records in
each extent.  For files constructed sequentially, the Size and Recs
fields are identical.  The Bytes field lists the actual number of
bytes allocated to the corresponding file.  The minimum allocation
unit is determined at configuration time; thus, the number of bytes
corresponds to the record count plus the remaining unused space in
the last allocated block for sequential files.  Random access files
are given data areas only when written, so the Bytes field contains
the only accurate allocation figure.  In the case of random access,
the Size field gives the logical end-of-file record position and the
Recs field counts the logical records of each extent.  Each of these
extents, however, can contain unallocated holes even though they are
added into the record count.

     The Ext field counts the number of physical extents allocated
to the file.  The Ext count corresponds to the number of directory
entries given to the file.  Depending on allocation size, there can
be up to 128K bytes (8 logical extents) directly addressed by a
single directory entry.  In a special case, there are actually 256K
bytes that can be directly addressed by a physical extent.

     The Acc field gives the R/O or R/W file indicator, which you
can change using the commands shown.  The four command forms,

        STAT d:filename.typ $R/O
        STAT d:filename.typ $R/W
        STAT d:filename.typ $SYS
        STAT d:filename.typ $DIR

set or reset various permanent file indicators.  The R/O indicator
places the file, or set of files, in a Read-Only status until
changed by a subsequent STAT command.  The R/O status is recorded in
the directory with the file so that it remains R/O through


                               1-16





CP/M Operating System Manual              1.6  Transient Commands


intervening cold start operations.  The R/W indicator places the
file in a permanent Read-Write status.  The SYS indicator attaches
the system indicator to the file, while the DIR command removes the
system indicator.  The filename.typ may be ambiguous or unambiguous,
but files whose attributes are changed are listed at the console
when the change occurs.  The drive name denoted by d: is optional.

     When a file is marked R/O, subsequent attempts to erase or
write into the file produce the following BDOS message at your
screen:

        BDOS Err on d: File R/O

lists the drive characteristics of the disk named by d: that is in
the range A:, B:,...,P:.  The drive characteristics are listed in
the following format:

            d: Drive Characteristics
        65536: 128 Byte Record Capacity
         8192: Kilobyte Drive Capacity
          128: 32 Byte Directory Entries
            0: Checked Directory Entries
         1024: Records/Extent
          128: Records/Block
           58: Sectors/Track
            2: Reserved Tracks

where d: is the selected drive, followed by the total record
capacity (65536 is an eight-megabyte drive), followed by the total
capacity listed in kilobytes.  The directory size is listed next,
followed by the checked entries.  The number of checked entries is
usually identical to the directory size for removable media, because
this mechanism is used to detect changed media during CP/M operation
without an intervening warm start.  For fixed media, the number is
usually zero, because the media are not changed without at least a
cold or warm start.

     The number of records per extent determines the addressing
capacity of each directory entry (1024 times 128 bytes, or 128K in
the previous example).  The number of records per block shows the
basic allocation size (in the example, 128 records/block times 128
bytes per record, or 16K bytes per block).  The listing is then
followed by the number of physical sectors per track and the number
of reserved tracks.

     For logical drives that share the same physical disk, the
number of reserved tracks can be quite large because this mechanism
is used to skip lower-numbered disk areas allocated to other logical
disks.  The command form

        STAT DSK:

produces a drive characteristics table for all currently active
drives.  The final STAT command form is



                               1-17





CP/M Operating System Manual              1.6  Transient Commands


        STAT USR:

which produces a list of the user numbers that have files on the
currently addressed disk.  The display format is

        Active User:   0
        Active Files:  0 1 3

where the first line lists the currently addressed user number, as
set by the last CCP USER command, followed by a list of user numbers
scanned from the current directory. In this case, the active user
number is 0 (default at cold start) with three user numbers that
have active files on the current disk.  The operator can
subsequently examine the directories of the other user numbers by
logging in with USER 1 or USER 3 commands, followed by a DIR command
at the CCP level.


1.6.2  ASM Command

Syntax:

        ASM ufn

     The ASM command loads and executes the CP/M 8080 assembler.
The ufn specifies a source file containing assembly language
statements, where the filetype is assumed to be ASM and is not
specified.  The following ASM commands are valid:

        ASM X
        ASM GAMMA

The two-pass assembler is automatically executed.  Assembly errors
that occur during the second pass are printed at the console.

     The assembler produces a file:

        X.PRN

where X is the primary name specified in the ASM command.  The PRN
file contains a listing of the source program with embedded tab
characters if present in the source program, along with the machine
code generated for each statement and diagnostic error messages, if
any.  The PRN file is listed at the console using the TYPE command,
or sent to a peripheral device using PIP (see Section 1.6.4).  Note
that the PRN file contains the original source program, augmented by
miscellaneous assembly information in the leftmost 16 columns; for
example, program addresses and hexadecimal machine code.  The PRN
file serves as a backup for the original source file.  If the source
file is accidentally removed or destroyed, the PRN file can be
edited by removing the leftmost 16 characters of each line (see
Section 2).  This is done by issuing a single editor macro command.
The resulting file is identical to the original source file and can
be renamed from PRN to ASM for subsequent editing and assembly.  The
file


                               1-18





CP/M Operating System Manual              1.6  Transient Commands



        X.HEX

is also produced, which contains 8080 machine language in Intel HEX
format suitable for subsequent loading and execution (see Section
1.6.3).  For complete details of CP/M's assembly language program,
see Section 3.

     The source file for assembly is taken from an alternate disk by
prefixing the assembly language filename by a disk drive name.  The
command

        ASM B:ALPHA

loads the assembler from the currently logged drive and processes
the source program ALPHA.ASM on drive B.  The HEX and PRN files are
also placed on drive B in this case.


1.6.3  LOAD Command

Syntax:

        LOAD ufn

     The LOAD command reads the file ufn, which is assumed to
contain HEX format machine code, and produces a memory image file
that can subsequently be executed.  The filename ufn is assumed to
be of the form:

        X.HEX

and only the filename X need be specified in the command.  The LOAD
command creates a file named

        X.COM

that marks it as containing machine executable code.  The file is
actually loaded into memory and executed when the user types the
filename X immediately after the prompting character > printed by
the CCP.

     Generally, the CCP reads the filename X following the prompting
character and looks for a built-in function name.  If no function
name is found, the CCP searches the system disk directory for a file
by the name

        X.COM

If found, the machine code is loaded into the TPA, and the program
executes.  Thus, the user need only LOAD a hex file once; it can be
subsequently executed any number of times by typing the primary
name.  This way, you can invent new commands in the CCP.
Initialized disks contain the transient commands as COM files, which
are optionally deleted.  The operation takes place on an alternate
drive if the filename is prefixed by a drive name.  Thus,

                               1-19





CP/M Operating System Manual              1.6  Transient Commands



        LOAD B:BETA

brings the LOAD program into the TPA from the currently logged disk
and operates on drive B after execution begins.

Note:  the BETA.HEX file must contain valid Intel format hexadecimal
machine code records (as produced by the ASM program, for example)
that begin at 100H of the TPA.  The addresses in the hex records
must be in ascending order; gaps in unfilled memory regions are
filled with zeroes by the LOAD command as the hex records are read.
Thus, LOAD must be used only for creating CP/M standard COM files
that operate in the TPA.  Programs that occupy regions of memory
other than the TPA are loaded under DDT.


1.6.4  PIP

Syntax:

        PIP
        PIP destination=source#1, source#2, ..., source #n

     PIP is the CP/M Peripheral Interchange Program that implements
the basic media conversion operations necessary to load, print,
punch, copy, and combine disk files.  The PIP program is initiated
by typing one of the following forms:

        PIP
        PIP command line

In both cases PIP is loaded into the TPA and executed.  In the first
form, PIP reads command lines directly from the console, prompted
with the * character, until an empty command line is typed (for
example, a single carriage return is issued by the operator).  Each
successive command line causes some media conversion to take place
according to the rules shown below.

     In the second form, the PIP command is equivalent to the first,
except that the single command line given with the PIP command is
automatically executed, and PIP terminates immediately with no
further prompting of the console for input command lines.  The form
of each command line is

        destination = source#1, source#2, ..., source#n

where destination is the file or peripheral device to receive the
data, and source#1, ..., source#n is a series of one or more files
or devices that are copied from left to right to the destination.

     When multiple files are given in the command line (for example,
n>1), the individual files are assumed to contain ASCII characters,
with an assumed CP/M end-of-file character (CTRL-Z) at the end of
each file (see the O parameter to override this assumption).  Lower-
case ASCII alphabetics are internally translated to upper-case to be


                               1-20





CP/M Operating System Manual              1.6  Transient Commands


consistent with CP/M file and device name conventions.  Finally, the
total command line length cannot exceed 255 characters.  CTRL-E can
be used to force a physical carriage return for lines that exceed
the console width.

     The destination and source elements are unambiguous references
to CP/M source files with or without a preceding disk drive name.
That is, any file can be referenced with a preceding drive name (A:
through P:) that defines the particular drive where the file can be
obtained or stored.  When the drive name is not included, the
currently logged disk is assumed.  The destination file can also
appear as one or more of the source files, in which case the source
file is not altered until the entire concatenation is complete.  If
it already exists, the destination file is removed if the command
line is properly formed.  It is not removed if an error condition
arises.  The following command lines, with explanations to the
right, are valid as input to PIP:


        X=Y                    Copies to file X from file Y, where
                               X and Y are unambiguous filenames;
                               Y remains unchanged.

        X=Y,Z                  Concatenates files Y and z and
                               copies to file X, with Y and Z
                               unchanged.

        X.ASM=Y.ASM,Z.ASM      Creates the file X.ASM from the
                               concatenation of the Y and Z.ASM
                               files.

        NEW.ZOT=B:OLD.ZAP      Moves a copy of OLD.ZAPP from drive
                               B to the currently logged disk;
                               names the file NEW.ZOT.

        B:A.U=B:B.V,A:C.W,D.X  Concatenates file B.V from drive B
                               with C.W from drive a and D.X from
                               the logged disk; creates the file
                               A.U on drive b.


     For convenience, PIP allows abbreviated commands for
transferring files between disk drives.  The abbreviated PIP forms
are

        PIP d:=afn
        PIP d1=d2:afn
        PIP ufn = d2:
        PIP d1:ufn = d2:

The first form copies all files from the currently logged disk that
satisfy the afn to the same files on drive d, where d = A...P.  The
second form is equivalent to the first, where the source for the
copy is drive d2, where d2 = A...P.  The third form is equivalent to
the command PIP d1:ufn=d2:ufn which copies the file given by ufn


                               1-21





CP/M Operating System Manual              1.6  Transient Commands


from drive d2 to the file ufn on drive d1:.  The fourth form is
equivalent to the third, where the source disk is explicitly given
by d2:.

     The source and destination disks must be different in all of
these cases.  If an afn is specified, PIP lists each ufn that
satisfies the afn as it is being copied.  If a file exists by the
same name as the destination file, it is removed after successful
completion of the copy and replaced by the copied file.

     The following PIP commands give examples of valid disk-to-disk
copy operations:


        B:=*.COM        Copies all files that have the secondary
                        name COM to drive B from the current drive.

        A:=B:ZAP.*      Copies all files that have the primary name
                        ZAP to drive A from drive B.

        ZAP.ASM=B:      Same as ZAP.ASM=B:ZAP.ASM

        B:ZOT.COM=A:    Same as B:ZOT.COM=A:ZOT.COM

        B:=GAMMA.BAS    Same as B:GAMMA.BAS=GAMMA.BAS

        B:=A:GAMMA.BAS  Same as B:GAMMA.BAS=A:GAMMA.BAS


     PIP allows reference to physical and logical devices that are
attached to the CP/M system.  The device names are the same as given
under the STAT command, along with a number of specially named
devices.  The following is a list of logical devices given in the
STAT command

        CON: (console)
        RDR: (reader)
        PUN: (punch)
        LST: (list)

while the physical devices are

        TTY: (console), reader, punch, or list)
        CRT: (console, or list), UC1: (console)
        PTR: (reader), UR1: (reader), UR2: (reader)
        PTP: (punch), UP1: (punch), UP2: (punch)
        LPT: (list), UL1: (list)

The BAT: physical device is not included, because this assignment is
used only to indicate that the RDR: and LST: devices are used for
console input/output.

     The RDR, LST, PUN, and CON devices are all defined within the
BIOS portion of CP/M, and are easily altered for any particular I/O
system.  The current physical device mapping is defined by IOBYTE;


                               1-22





CP/M Operating System Manual              1.6  Transient Commands


see Section 6 for a discussion of this function.  The destination
device must be capable of receiving data, for example, data cannot
be sent to the punch, and the source devices must be capable of
generating data, for example, the LST: device cannot be read.

     The following list describes additional device names that can
be used in PIP commands.


   o NUL: sends 40 nulls (ASCII 0s) to the device.  This can be
     issued at the end of punched output.

   o EOF: sends a CP/M end-of-file (ASCII CTRL-Z) to the destination
     device (sent automatically at the end of all ASCII data
     transfers through PIP).

   o INP: is a special PIP input source that can be patched into the
     PIP program.  PIP gets the input data character-by-character,
     by CALLing location 103H, with data returned in location 109H
     (parity bit must be zero).

   o OUT: is a special PIP output destination that can be patched
     into the PIP program.  PIP CALLs location 106H with data in
     register C for each character to transmit.  Note that locations
     109H through 1FFH of the PIP memory image are not used and can
     be replaced by special purpose drivers using DDT (see Section
     4).

   o PRN: is the same as LST:, except that tabs are expanded at
     every eighth character position, lines are numbered, and page
     ejects are inserted every 60 lines with an initial eject (same
     as using PIP options [t8np]).


     File and device names can be interspersed in the PIP commands.
In each case, the specific device is read until end-of-file (CTRL-Z
for ASCII files, and end-of-data for non-ASCII disk files).  Data
from each device or file are concatenated from left to right until
the last data source has been read.

     The destination device or file is written using the data from
the source files, and an end-of-file character, CTRL-Z, is appended
to the result for ASCII files.  If the destination is a disk file, a
temporary file is created ($$$ secondary name) that is changed to
the actual filename only on successful completion of the copy.
Files with the extension COM are always assumed to be non-ASCII.

     The copy operation can be aborted at any time by pressing any
key on the keyboard.  PIP responds with the message ABORTED to
indicate that the operation has not been completed.  If any
operation is aborted, or if an error occurs during processing, PIP
removes any pending commands that were set up while using the SUBMIT
command.




                               1-23





CP/M Operating System Manual              1.6  Transient Commands


     PIP performs a special function if the destination is a disk
file with type HEX (an Intel hex-formatted machine code file), and
the source is an external peripheral device, such as a paper tape
reader.  In this case, the PIP program checks to ensure that the
source file contains a properly formed hex file, with legal
hexadecimal values and checksum records.

     When an invalid input record is found, PIP reports an error
message at the console and waits for corrective action.  Usually,
you can open the reader and rerun a section of the tape (pull the
tape back about 20 inches).  When the tape is ready for the reread,
a single carriage return is typed at the console, and PIP attempts
another read.  If the tape position cannot be properly read,
continue the read by typing a return following the error message,
and enter the record manually with the ED program after the disk
file is constructed.

     PIP allows the end-of-file to be entered from the console if
the source file is an RDR: device.  In this case, the PIP program
reads the device and monitors the keyboard.  If CTRL-Z is typed at
the keyboard, the read operation is terminated normally.

     The following are valid PIP commands:


        PIP LST: = X.PRN

                        Copies X.PRN to the LST device and
                        terminates the PIP program.

        PIP

                        Starts PIP for a sequence of commands.  PIP
                        prompts with *.

        *CON:=X.ASM,Y.ASM,Z.ASM

                        Concatenates three ASM files and copies to
                        the CON device.

        *X.HEX=CON:,Y.HEX,PTR:

                        Creates a HEX file by reading the CON until
                        a CTRL-Z is typed, followed by data from
                        Y.HEX and PTR until a CTRL-Z is
                        encountered.

        PIP PUN:=NUL:,X.ASM,EOF:,NUL:

                        Sends 40 nulls to the punch device; copies
                        the X.ASM file to the punch, followed by an
                        end-of-file, CTRL-Z, and 40 more null
                        characters.

        (carriage return)

                        A single carriage return stops PIP.

                               1-24




CP/M Operating System Manual              1.6  Transient Commands



     You can also specify one or more PIP parameters, enclosed in
left and right square brackets, separated by zero or more blanks.
Each parameter affects the copy operation, and the enclosed list of
parameters must immediately follow the affected file or device.
Generally, each parameter can be followed by an optional decimal
integer value (the S and Q parameters are exceptions).  Table 1-4
describes valid PIP parameters.


Table 1-4.  PIP Parameters
F

     Parameter                      Meaning

       B         Blocks mode transfer.  Data are buffered by
                 PIP until an ASCII x-off character, CTRL-S,
                 is received from the source device.  This
                 allows transfer of data to a disk file from a
                 continuous reading device, such as a cassette
                 reader.  Upon receipt of the x-off, PIP
                 clears the disk buffers and returns for more
                 input data.  The amount of data that can be
                 buffered depends on the memory size of the
                 host system.  PIP issues an error message if
                 the buffers overflow.

       Dn        Deletes characters that extend past column n
                 in the transfer of data to the destination
                 from the character source.  This parameter is
                 generally used to truncate long lines that
                 are sent to a narrow printer or console
                 device.

       E         Echoes all transfer operations to the console
                 as they are being performed.

       F         Filters form-feeds from the file.  All
                 embedded form-feeds are removed.  The P
                 parameter can be used simultaneously to
                 insert new form-feeds.

       Gn        Gets file from user number n (n in the range
                 0-15).

       H         Transfers HEX data.  All data are checked for
                 proper Intel hex file format.  Nonessential
                 characters between hex records are removed
                 during the copy operation.  The console is
                 prompted for corrective action in case errors
                 occur.

       I         Ignores :00 records in the transfer of Intel
                 hex format file.  The I parameter
                 automatically sets the H parameter.



                               1-25



K


CP/M Operating System Manual              1.6  Transient Commands


Table 1-4.  (continued)
F

     Parameter                      Meaning

       L         Translates upper-case alphabetics to lower-
                 case.

       N         Adds line numbers to each line transferred to
                 the destination, starting at one and
                 incrementing by 1.  Leading zeroes are
                 suppressed, and the number is followed by a
                 colon.  If N2 is specified, leading zeroes
                 are included and a tab is inserted following
                 the number.  The tab is expanded if T is set.

       O         Transfers non-ASCII object files.  The normal
                 CP/M end-of-file is ignored.

       Pn        Includes page ejects at every n lines with an
                 initial page eject.  If n = 1 or is excluded
                 altogether, page ejects occur every 60 lines.
                 If the F parameter is used, form-feed
                 suppression takes place before the new page
                 ejects are inserted.

       Qs^Z      Quits copying from the source device or file
                 when the string s, terminated by CTRL-Z, is
                 encountered.

       R         Reads system files.

       Ss^Z      Start copying from the source device when the
                 string s, terminated by CTRL-Z, is
                 encountered.  The S and Q parameters can be
                 used to abstract a particular section of a
                 file, such as a subroutine.  The start and
                 quit strings are always included in the copy
                 operation.

                 If you specify a command line after the PIP
                 command keyword, the CCP translates strings
                 following the S and Q parameters to upper-
                 case.  If you do not specify a command line,
                 PIP does not perform the automatic upper-case
                 translation.

       Tn        Expands tabs, CTRL-I characters, to every nth
                 column during the transfer of characters to
                 the destination from the source.

       U         Translates lower-case alphabetics to upper-
                 case during the copy operation.





                               1-26



K


CP/M Operating System Manual              1.6  Transient Commands


Table 1-4.  (continued)
F

     Parameter                      Meaning

       V         Verifies that data have been copied correctly
                 by rereading after the write operation (the
                 destination must be a disk file).

       W         Writes over R/O files without console
                 interrogation.

       Z         Zeros the parity bit on input for each ASCII
                 character.
K


     The following examples show valid PIP commands that specify
parameters in the file transfer.


        PIP X.ASM=B:[v]

                        Copies X.ASM from drive B to the current
                        drive and verifies that the data were
                        properly copied.


        PIP LPT:=X.ASM[nt8u]

                        Copies X.ASM to the LPT: device; numbers
                        each line, expands tabs to every eighth
                        column, and translates lower-case
                        alphabetics to upper-case.


        PIP PUN:=X.HEX[i],Y.ZOT[h]

                        First copies X.HEX to the PUN: device and
                        ignores the trailing :00 record in X.HEX;
                        continues the transfer of data by reading
                        Y.ZOT, which contains HEX records,
                        including any :00 records it contains.


        PIP X.LIB=Y.ASM[sSUBRI:^z qJMP L3^z]

                        Copies from the file Y.ASM into the file
                        X.LIB.  The command starts the copy when
                        the string SUBR1: has been found, and quits
                        copying after the string JMP L3 is
                        encountered.







                               1-27





CP/M Operating System Manual              1.6  Transient Commands


        PIP PRN:=X.ASM[p50]

                        Sends X.ASM to the LST: device with line
                        numbers, expands tabs to every eighth
                        column, and ejects pages at every 50th
                        line.  The assumed parameter list for a PRN
                        file is nt8p60; p50 overrides the default
                        value.


     Under normal operation, PIP does not overwrite a file that is
set to a permanent R/O status.  If an attempt is made to overwrite
an R/O file, the following prompt appears:

        DESTINATION FILE IS R/O, DELETE (Y/N)?

If you type Y, the file is overwritten.  Otherwise, the following
response appears:

        ** NOT DELETED **

The file transfer is skipped, and PIP continues with the next
operation in sequence.  To avoid the prompt and response in the case
of R/O file overwrite, the command line can include the W parameter,
as shown in this example:

        PIP A:=B:*.COM[W]

The W parameter copies all nonsystem files to the A drive from the B
drive and overwrites any R/O files in the process.  If the operation
involves several concatenated files, the W parameter need only be
included with the last file in the list, as in this example:

        PIP A.DAT=B.DAT,F:NEW.DAT,G:OLD.DAT[W]

     Files with the system attribute can be included in PIP
transfers if the R parameter is included; otherwise, system files
are not recognized.  For example, the command line:

        PIP ED.COM=B:ED.COM[R]

reads the ED.COM file from the B drive, even if it has been marked
as an R/O and system file.  The system file attributes are copied,
if present.

     Downward compatibility with previous versions of CP/M is only
maintained if the file does not exceed one megabyte, no file
attributes are set, and the file is created by user 0.  If
compatibility is required with nonstandard, for example, double-
density versions of 1.4, it might be necessary to select 1.4
compatibility mode when constructing the internal disk parameter
block.  See Section 6 and refer to Section 6.10, which describes
BIOS differences.




                               1-28





CP/M Operating System Manual              1.6  Transient Commands


Note:  to copy files into another user area, PIP.COM must be located
in that user area.  Use the following procedure to make a copy of
PIP.COM in another user area.


        USER 0                            Log in user 0.

        DDT PIP.COM (note PIP size s)     Load PIP to memory.

        GO                                Return to CCP.

        USER 3                            Log in user 3.

        SAVEs PIP.COM


In this procedure, s is the integral number of memory pages, 256-
byte segments, occupied by PIP.  The number s can be determined when
PIP.COM is loaded under DDT, by referring to the value under the
NEXT display.  If, for example, the next available address is 1D00,
then PIP.COM requires 1C hexadecimal pages, or 1 times 16 + 12 = 28
pages, and the value of s is 28 in the subsequent save.  Once PIP is
copied in this manner, it can be copied to another disk belonging to
the same user number through normal PIP transfers.


1.6.5  ED Command

Syntax:

        ED ufn

     The ED program is the CP/M system context editor that allows
creation and alteration of ASCII files in the CP/M environment.
Complete details of operation are given in Section 2.  ED allows the
operator to create and operate upon source files that are organized
as a sequence of ASCII characters, separated by end-of-line
characters (a carriage return/line-feed sequence).  There is no
practical restriction on line length (no single line can exceed the
size of the working memory) that is defined by the number of
characters typed between carriage returns.

     The ED program has a number of commands for character string
searching, replacement, and insertion that are useful for creating
and correcting programs or text files under CP/M.  Although the CP/M
has a limited memory work space area (approximately 5000 characters
in a 20K CP/M system), the file size that can be edited is not
limited, since data are easily paged through this work area.

     If it does not exist, ED creates the specified source file and
opens the file for access.  If the source file does exist, the
programmer appends data for editing (see the A command).  The
appended data can then be displayed, altered, and written from the
work area back to the disk (see the W command).  Particular points
in the program can be automatically paged and located by context,


                               1-29





CP/M Operating System Manual              1.6  Transient Commands


allowing easy access to particular portions of a large file (see the
N command).

     If you type the following command line:

        ED X.ASM

the ED program creates an intermediate work file with the name

        X.$$$

to hold the edited data during the ED run.  Upon completion of ED,
the X.ASM file (original file) is renamed to X.BAK, and the edited
work file is renamed to X.ASM.  Thus, the X.BAK file contains the
original unedited file, and the X.ASM file contains the newly edited
file.  The operator can always return to the previous version of a
file by removing the most recent version and renaming the previous
version.  If the current X.ASM file has been improperly edited, the
following sequence of commands reclaim the back-up file.


        DIR X.*               Checks to see that BAK file is
                              available.

        ERA X.ASM             Erases most recent version.

        REN X.ASM=X.BAK       Renames the BAK file to ASM.


You can abort the edit at any point (reboot, power failure, CTRL-C,
or CTRL-Q command) without destroying the original file.  In this
case, the BAK file is not created and the original file is always
intact.

     The ED program allows the user to edit the source on one disk
and create the back-up file on another disk.  This form of the ED
command is

        ED ufn d:

where ufn is the name of the file to edit on the currently logged
disk and d is the name of an alternate drive.  The ED program reads
and processes the source file and writes the new file to drive d
using the name ufn.  After processing, the original file becomes the
back-up file.  If the operator is addressing disk A, the following
command is valid.

        ED X.ASM b:

This edits the file X.ASM on drive A, creating the new file X.$$$ on
drive B.  After a successful edit, A:X.ASM is renamed to A:X.BAK,
and B:X.$$$ is renamed to B:X.ASM.  For convenience, the currently
logged disk becomes drive B at the end of the edit.  Note that if a
file named B:X.ASM exists before the editing begins, the following
message appears on the screen:


                               1-30





CP/M Operating System Manual              1.6  Transient Commands



        FILE EXISTS

This message is a precaution against accidentally destroying a
source file.  You should first erase the existing file and then
restart the edit operation.

     Similar to other transient commands, editing can take place on
a drive different from the currently logged disk by preceding the
source filename by a drive name.  The following are examples of
valid edit requests:


        ED A:X.ASM       Edits the file X.ASM on drive A, with new
                         file and back-up on drive A.

        ED B:X.ASM A:    Edits the file X.ASM on drive B to the
                         temporary file X.$$$ on drive A.  After
                         editing, this command changes X.ASM on
                         drive B to X.BAK and changes X.$$$ on
                         drive A to X.ASM.


1.6.6  SYSGEN Command

Syntax:

        SYSGEN

     The SYSGEN transient command allows generation of an
initialized disk containing the CP/M operating system.  The SYSGEN
program prompts the console for commands by interacting as shown.


        SYSGEN <cr>

                        Initiates the SYSGEN program.


        SYSGEN VERSION x.x

                        SYSGEN sign-on message.


        SOURCE DRIVE NAME
        (OR RETURN TO SKIP)

                        Respond  with  the  drive name (one of the
                        letters A, B, C, or D) of the disk
                        containing a CP/M system, usually A.  If a
                        copy of CP/M already exists in memory due
                        to a MOVCPM command, press only a carriage
                        return.  Typing a drive name d causes the
                        response:



                               1-31





CP/M Operating System Manual              1.6  Transient Commands


        SOURCE ON d THEN TYPE RETURN

                        Place a disk containing the CP/M operating
                        system on drive d (d is one of A, B, C, or
                        D).  Answer by pressing a carriage return
                        when ready.


        FUNCTION COMPLETE

                        System is copied to memory.  SYSGEN then
                        prompts with the following:


        DESTINATION DRIVE NAME
        (OR RETURN TO REBOOT)

                        If a  disk is  being initialized, place the
                        new disk into a drive and answer with the
                        drive name.  Otherwise, press a carriage
                        return and the system reboots from drive A.
                        Typing drive name d causes SYSGEN to prompt
                        with the following message:


        DESTINATION ON d
        THEN TYPE RETURN

                        Place new  disk into drive d; press return
                        when ready.


        FUNCTION COMPLETE

                        New disk is initialized in drive d.


The DESTINATION prompt is repeated until a single carriage return is
pressed at the console, so that more than one disk can be
initialized.

     Upon completion of a successful system generation, the new disk
contains the operating system, and only the built-in commands are
available.  An IBM-compatible disk appears to CP/M as a disk with an
empty directory; therefore, the operator must copy the appropriate
COM files from an existing CP/M disk to the newly constructed disk
using the PIP transient.

     You can copy all files from an existing disk by typing the
following PIP command:

        PIP B: = A:*.*[v]





                               1-32





CP/M Operating System Manual              1.6  Transient Commands


This command copies all files from disk drive A to disk drive B and
verifies that each file has been copied correctly.  The name of each
file is displayed at the console as the copy operation proceeds.

     Note that a SYSGEN does not destroy the files that already
exist on a disk; it only constructs a new operating system.  If a
disk is being used only on drives B through P and will never be the
source of a bootstrap operation on drive A, the SYSGEN need not take
place.


1.6.7  SUBMIT Command

Syntax:

        SUBMIT ufn parm#1 ... parm#n

     The SUBMIT command allows CP/M commands to be batched for
automatic processing.  The ufn given in the SUBMIT command must be
the filename of a file that exists on the currently logged disk,
with an assumed file type of SUB.  The SUB file contains CP/M
prototype commands with possible parameter substitution.  The actual
parameters parm#1 ... parm#n are substituted into the prototype
commands, and, if no errors occur, the file of substituted commands
are processed sequentially by CP/M.

     The prototype command file is created using the ED program,
with interspersed $ parameters of the form:

        $1 $2 $3 ...$n

corresponding to the number of actual parameters that will be
included when the file is submitted for execution.  When the SUBMIT
transient is executed, the actual parameters parm#1 ... parm#n are
paired with the formal parameters $1 ... $n in the prototype
commands.  If the numbers of formal and actual parameters do not
correspond, the SUBMIT function is aborted with an error message at
the console.  The SUBMIT function creates a file of substituted
commands with the name

        $$$.SUB

on the logged disk.  When the system reboots, at the termination of
the SUBMIT, this command file is read by the CCP as a source of
input rather than the console.  If the SUBMIT function is performed
on any disk other than drive A, the commands are not processed until
the disk is inserted into drive A and the system reboots.  You can
abort command processing at any time by pressing the rubout key when
the command is read and echoed.  In this case, the $$$.SUB file is
removed and the subsequent commands come from the console.  Command
processing is also aborted if the CCP detects an error in any of the
commands.  Programs that execute under CP/M can abort processing of
command files when error conditions occur by erasing any existing
$$$.SUB file.



                               1-33





CP/M Operating System Manual              1.6  Transient Commands


     To introduce dollar signs into a SUBMIT file, you can type a $$
which reduces to a single $ within the command file.  A caret, ^,
precedes an alphabetic character s, which produces a single CTRL-X
character within the file.

     The last command in a SUB file can initiate another SUB file,
allowing chained batch commands:

     Suppose the file ASMBL.SUB exists on disk and contains the
prototype commands

        ASM $1
        DIR $1.*
        ERA *.BAK
        PIP $2:=$1.PRN
        ERA $1.PRN

then, you issue the following command:

        SUBMIT ASMBL X PRN

The SUBMIT program reads the ASMBL.SUB file, substituting X: for all
occurrences of $1 and PRN for all occurrences of $2.  This results
in a $$$.SUB file containing the commands:

        ASM X
        DIR X.*
        ERA *.BAK
        PIP PRN:=X.PRN
        ERA X.PRN

which are executed in sequence by the CCP.

     The SUBMIT function can access a SUB file on an alternate drive
by preceding the filename by a drive name.  Submitted files are only
acted upon when they appear on drive A.  Thus, it is possible to
create a submitted file on drive B that is executed at a later time
when inserted in drive A.

     An additional utility program called XSUB extends the power of
the SUBMIT facility to include line input to programs as well as the
CCP.  The XSUB command is included as the first line of the SUBMIT
file.  When it is executed, XSUB self-relocates directly below the
CCP.  All subsequent SUBMIT command lines are processed by XSUB so
that programs that read buffered console input, BDOS Function 10,
receive their input directly from the SUBMIT file.  For example, the
file SAVER.SUB can contain the following SUBMIT lines:

        XSUB
        DDT
        |$1.COM
        R
        GO
        SAVE 1 $2.COM



                               1-34





CP/M Operating System Manual              1.6  Transient Commands


a subsequent SUBMIT command, such as

        A>SUBMIT SAVER PIP Y

substitutes X for $1 and Y for $2 in the command stream.  The XSUB
program loads, followed by DDT, which is sent to the command lines
PIP.COM, R, and G0, thus returning to the CCP.  The final command
SAVE 1 Y.COM is processed by the CCP.

     The XSUB program remains in memory and prints the message

        (xsub active)

on each warm start operation to indicate its presence.  Subsequent
SUBMIT command streams do not require the XSUB, unless an
intervening cold start occurs.  Note that XSUB must be loaded after
the optional CP/M DESPOOL utility, if both are to run
simultaneously.


1.6.8  DUMP Command

Syntax:

        DUMP ufn

     The DUMP program types the contents of the disk file (ufn) at
the console in hexadecimal form.  The file contents are listed
sixteen bytes at a time, with the absolute byte address listed to
the left of each line in hexadecimal.  Long typeouts can be aborted
by pressing the rubout key during printout.  The source listing of
the DUMP program is given in Section 5 as an example of a program
written for the CP/M environment.


1.6.9  MOVCPM Command

Syntax:

        MOVCPM

     The MOVCPM program allows you to reconfigure the CP/M system
for any particular memory size.  Two optional parameters can be used
to indicate the desired size of the new system and the disposition
of the new system at program termination.  If the first parameter is
omitted or an * is given, the MOVCPM program reconfigures the system
to its maximum size, based upon the kilobytes of contiguous RAM in
the host system (starting at 0000H).  If the second parameter is
omitted, the system is executed, but not permanently recorded; if *
is given, the system is left in memory, ready for a SYSGEN
operation.  The MOVCPM program relocates a memory image of CP/M and
places this image in memory in preparation for a system generation
operation.  The following is a list of MOVCPM command forms:




                               1-35





CP/M Operating System Manual              1.6  Transient Commands


        MOVCPM         Relocates and executes CP/M for management
                       of the current memory configuration (memory
                       is examined for contiguous RAM, starting at
                       100H).  On completion of the relocation, the
                       new system is executed but not permanently
                       recorded on the disk.  The system that is
                       constructed contains a BIOS for the Intel
                       microcomputer development system 800.

        MOVCPM  n      Creates a relocated CP/M system for
                       management of an n kilobyte system (n must
                       be in the range of 20 to 64), and executes
                       the system as described.

        MOVCPM  * *    Constructs a relocated memory image for the
                       current memory configuration, but leaves the
                       memory image in memory in preparation for a
                       SYSGEN operation.

        MOVCPM  n *    Constructs a relocated memory image for an n
                       kilobyte memory system, and leaves the
                       memory image in preparation for a SYSGEN
                       operation.


     For example, the command,

        MOVCPM  * *

constructs a new version of the CP/M system and leaves it in memory,
ready for a SYSGEN operation.  The message

        READY FOR 'SYSGEN' OR
        'SAVE 34 CPMxx.COM'

appears at the console upon completion, where xx is the current
memory size in kilobytes.  You can then type the following sequence:


        SYSGEN                     This starts the system
                                   generation.

        SOURCE DRIVE NAME          Respond with a carriage return
        (OR RETURN TO SKIP)        to skip the CP/M read operation,
                                   because the system is already
                                   in memory as a result of the
                                   previous MOVCPM operation.

        DESTINATION DRIVE NAME     Respond  with B  to  write new
        (OR RETURN TO REBOOT)      system to the disk in drive B.
                                   SYSGEN prompts with the
                                   following message:

        DESTINATION ON B,          Place the  new disk on drive B
        THEN TYPE RETURN           and press the RETURN key when
                                   ready.

                               1-36





CP/M Operating System Manual              1.6  Transient Commands



     If you respond with A rather than B above, the system is
written to drive A rather than B.  SYSGEN continues to print this
prompt:

        DESTINATION DRIVE NAME (OR RETURN TO REBOOT)

until you respond with a single carriage return, which stops the
SYSGEN program with a system reboot.

     You can then go through the reboot process with the old or new
disk.  Instead of performing the SYSGEN operation, you can type a
command of the form:

        SAVE 34 CPMxx.COM

at the completion of the MOVCPM function, where xx is the value
indicated in the SYSGEN message.  The CP/M memory image on the
currently logged disk is in a form that can be patched.  This is
necessary when operating in a nonstandard environment where the BIOS
must be altered for a particular peripheral device configuration, as
described in Section 6.

     The following are valid MOVCPM commands:


        MOVCPM  48     Constructs a 48K version of CP/M and starts
                       execution.

        MOVCPM  48 *   Constructs a 48K version of CP/M in
                       preparation for permanent recording; the
                       response is

                       READY FOR 'SYSGEN' OR
                        'SAVE 34 CPM48.COM'

        MOVCPM * *     Constructs a maximum memory version of CP/M
                       and starts execution.

     The newly created system is serialized with the number attached
to the original disk and is subject to the conditions of the Digital
Research Software Licensing Agreement.


1.7  BDOS Error Messages

     There are three error situations that the Basic Disk Operating
System intercepts during file processing.  When one of these
conditions is detected, the BDOS prints the message:

        BDOS ERR ON d: error






                               1-37





CP/M Operating System Manual             1.7  BDOS Error Messages


where d is the drive name and error is one of the three error
messages:

        BAD SECTOR
        SELECT
        READ ONLY

     The BAD SECTOR message indicates that the disk controller
electronics has detected an error condition in reading or writing
the disk.  This condition is generally caused by a malfunctioning
disk controller or an extremely worn disk.  If you find that CP/M
reports this error more than once a month, the state of the
controller electronics and the condition of the media should be
checked.

     You can also encounter this condition in reading files
generated by a controller produced by a different manufacturer.
Even though controllers claim to be IBM..-compatible, one often
finds small differences in recording formats.  The Model 800
controller, for example, requires two bytes of one's following the
data CRC byte, which is not required in the IBM format.  As a
result, disks generated by the Intel microcomputer development
system can be read by almost all other IBM-compatible system, while
disk files generated on other manufacturers' equipment produce the
BAD SECTOR message when read by the microcomputer development
system.  To recover from this condition, press a CTRL-C to reboot
(the safest course), or a return, which ignores the bad sector in
the file operation.

Note:  pressing a return might destroy disk integrity if the
operation is a directory write.  Be sure you have adequate back-ups
in this case.

     The SELECT error occurs when there is an attempt to address a
drive beyond the range supported by the BIOS.  In this case, the
value of d in the error message gives the selected drive.  The
system reboots following any input from the console.

     The READ ONLY message occurs when there is an attempt to write
to a disk or file that has been designated as Read-Only in a STAT
command or has been set to Read-Only by the BDOS.  Reboot CP/M by
using the warm start procedure, CTRL-C, or by performing a cold
start whenever the disks are changed.  If a changed disk is to be
read but not written, BDOS allows the disk to be changed without the
warm or cold start, but internally marks the drive as Read-Only.
The status of the drive is subsequently changed to Read-Write if a
warm or cold start occurs.  On issuing this message, CP/M waits for
input from the console.  An automatic warm start takes place
following any input.


1.8  CP/M Operation on the Model 800





                               1-38





CP/M Operating System Manual  1.8  Operation of CP/M on the Model 800


     This section gives operating procedures for using CP/M on the
Intel Model 800 microcomputer development system microcomputer
development system.  Basic knowledge of the microcomputer
development system hardware and software systems is assumed.

     CP/M is initiated in essentially the same manner as the Intel
ISIS operating system.  The disk drives are labeled 0 through 3 on
the microcomputer development system, corresponding to CP/M drives A
through D, respectively.  The CP/M system disk is inserted into
drive 0, and the BOOT and RESET switches are pressed in sequence.
The interrupt 2 light should go on at this point.  The space bar is
then pressed on the system console, and the light should go out.  If
it does not, the user should check connections and baud rates.  The
BOOT switch is turned off, and the CP/M sign-on message should
appear at the selected console device, followed by the A> system
prompt.  You can then issue the various resident and transient
commands.

     The CP/M system can be restarted (warm start) at any time by
pushing the INT 0 switch on the front panel.  The built-in Intel ROM
monitor can be initiated by pushing the INT 7 switch, which
generates an RST 7, except when operating under DDT, in which case
the DDT program gets control instead.

     Diskettes can be removed from the drives at any time, and the
system can be shut down during operation without affecting data
integrity.  Do not remove a disk and replace it with another without
rebooting the system (cold or warm start) unless the inserted disk
is Read-Only.

     As a result of hardware hang-ups or malfunctions, CP/M might
print the following message:

        BDOS ERR ON d: BAD SECTOR

where d is the drive that has a permanent error.  This error can
occur when drive doors are opened and closed randomly, followed by
disk operations, or can be caused by a disk, drive, or controller
failure.  You can optionally elect to ignore the error by pressing a
single return at the console.  The error might produce a bad data
record, requiring reinitialization of up to 128 bytes of data.  You
can reboot the CP/M system and try the operation again.

     Termination of a CP/M session requires no special action,
except that it is necessary to remove the disks before turning the
power off to avoid random transients that often make their way to
the drive electronics.

     You should use IBM-compatible disks rather than disks that have
previously been used with any ISIS version.  In particular, the ISIS
FORMAT operation produces nonstandard sector numbering throughout
the disk.  This nonstandard numbering seriously degrades the
performance of CP/M, and causes CP/M to operate noticeably slower
than the distribution version.  If it becomes necessary to reformat
a disk, which should not be the case for standard disks, a program


                               1-39





CP/M Operating System Manual  1.8  Operation of CP/M on the Model 800


can be written under CP/M that causes the Model 800 controller to
reformat with sequential sector numbering (1-26) on each track.

     Generally, IBM-compatible 8-inch disks do not need to be
formatted.  However, 5 1/4-inch disks need to be formatted.


End of Section 1

















































                               1-40








Section 2

The CP/M Editor



2.1  Introduction to Ed

     Ed is the context editor for CP/M, and is used to create and
alter CP/M source files.  To start ED, type a command of the
following form:

        ED filename
or
        ED filename.typ

Generally, ED reads segments of the source file given by filename or
filename.typ into the central memory, where you edit the file and it
is subsequently written back to disk after alterations.  If the
source file does not exist before editing, it is created by ED and
initialized to empty.  The overall operation of Ed is shown in
Figure 2-1.


2.1.1  ED Operation

     Ed operates upon the source file, shown in Figure 2-1 by x.y,
and passes all text through a memory buffer where the text can be
viewed or altered.  The number of lines that can be maintained in
the memory buffer varies with the line length, but has a total
capacity of about 5000 characters in a 20K CP/M system.

     Edited text material is written into a temporary work file
under your command.  Upon termination of the edit, the memory buffer
is written to the temporary file, followed by any remaining (unread)
text in the source file.  The name of the original file is changed
from x.y to x.BAK so that the most recent edited source file can be
reclaimed if necessary.  See the CP/M commands ERASE and RENAME.
The temporary file is then changed from x.$$$ to x.y, which becomes
the resulting edited file.

     The memory buffer is logically between the source file and
working file, as shown in Figure 2-2.














                               2-1





CP/M Operating System Manual              2.1  Introduction to ED





























Figure 2-1.  Overall ED Operation



       Source File         Memory Buffer       Temporary File

    1   First Line      1   First Line       1   First Line
    2    Appended       2    Buffered        2   Processed
    3     Lines         3      Text          3      Text



   SP                  MP                   TP



       Unprocessed  Next       Free     Next      Free File
         Source     Append    Memory    Write       Space
         Lines                Space



                        SP = Source Pointer
                        MP = Memory Pointer
                        TP = Temporary Pointer


Figure 2-2.  Memory Buffer Organization


                               2-2





CP/M Operating System Manual              2.1  Introduction to ED


2.1.2  Text Transfer Functions

     Given that n is an integer value in the range 0 through 65535,
several single-letter ED commands transfer lines of text from the
source file through the memory buffer to the temporary (and
eventually final) file.  Single letter commands are shown in upper-
case, but can be typed in either upper- or lower-case.


Table 2-1.  ED Text Transfer Commands

   Command                          Result

F
     nA        Appends the next n unprocessed source lines
               from the source file at SP to the end of the
               memory buffer at MP.  Increment SP and MP by n.
               If upper-case translation is set (see the U
               command) and the A command is typed in upper-
               case, all input lines will automatically be
               translated to upper-case.

     nW        Writes the first n lines of the memory buffer
               to the temporary file free space.  Shift the
               remaining lines n+1 through MP to the top of
               the memory buffer.  Increment TP by n.

     E         Ends the edit.  Copy all buffered text to
               temporary file and copy all unprocessed source
               lines to temporary file.  Rename files.

     H         Moves to head of new file by performing
               automatic E command.  The temporary file
               becomes the new source file, the memory buffer
               is emptied, and a new temporary file is
               created.  The effect is equivalent to issuing
               an E command, followed by a reinvocation of ED,
               using x.y as the file to edit.

     O         Returns to original file.  The memory buffer is
               emptied, the temporary file is deleted, and the
               SP is returned to position 1 of the source
               file.  The effects of the previous editing
               commands are thus nullified.

     Q         Quits edit with no file alterations, returns to
               CP/M.
K


     There are a number of special cases to consider.  If the
integer n is omitted in any ED command where an integer is allowed,
then 1 is assumed.  Thus, the commands A and W append one line and
write one line, respectively.  In addition, if a pound sign # is
given in the place of n, then the integer 65535 is assumed (the
largest value for n that is allowed).  Because most source files can
be contained entirely in the memory buffer, the command #A is often


                               2-3





CP/M Operating System Manual              2.1  Introduction to ED


issued at the beginning of the edit to read the entire source file
to memory.  Similarly, the command #W writes the entire buffer to
the temporary file.

     Two special forms of the A and W commands are provided as a
convenience.  The command 0A fills the current memory buffer at
least half full, while 0W writes lines until the buffer is at least
half empty.  An error is issued if the memory buffer size is
exceeded.  You can then enter any command, such as W, that does not
increase memory requirements.  The remainder of any partial line
read during the overflow will be brought into memory on the next
successful append.


2.1.3  Memory Buffer Organization

     The memory buffer can be considered a sequence of source lines
brought in with the A command from a source file.  The memory buffer
has an imaginary character pointer (CP) that moves throughout the
memory buffer under command of the operator.

     The memory buffer appears logically as shown in Figure 2-3,
where the dashes represent characters of the source line of
indefinite length, terminated by carriage return (<cr>) and line-
feed (<lf>) characters, and CP represents the imaginary character
pointer.  Note that the CP is always located ahead of the first
character of the first line, behind the last character of the last
line, or between two characters.  The current line CL is the source
line that contains the CP.



                          Memory Buffer


      first line        -----------------------<cr><lf>


                        -----------------------<cr><lf>


      current line CL   ---------------------------<cr><lf>


                                    CP

      last line         -----------------------<cr><lf>


        Figure 2-3.  Logical Organization of Memory Buffer







                               2-4





CP/M Operating System Manual              2.1  Introduction to ED


2.1.4  Line Numbers and ED Start-up

     ED produces absolute line number prefixes that are used to
reference a line or range of lines.  The absolute line number is
displayed at the beginning of each line when ED is in insert mode
(see the I command in Section 2.1.5). Each line number takes the
form

        nnnnn:

where nnnnn is an absolute line number in the range of 1 to 65535.
If the memory buffer is empty or if the current line is at the end
of the memory buffer, nnnnn appears as 5 blanks.

     You can reference an absolute line number by preceding any
command by a number followed by a colon, in the same format as the
line number display.  In this case, the ED program moves the current
line reference to the absolute line number, if the line exists in
the current memory buffer.  The line denoted by the absolute line
number must be in the memory buffer (see the A command).  Thus, the
command

        345:T

is interpreted as move to absolute 345, and type the line. 
Absolute line numbers are produced only during the editing process
and are not recorded with the file.  In particular, the line numbers
will change following a deleted or expanded section of text.

     You can also reference an absolute line number as a backward or
forward distance from the current line by preceding the absolute
number by a colon.  Thus, the command

        :400T

is interpreted as type from the current line number through the line
whose absolute number is 400.  Combining the two line reference
forms, the command

        345::400T

is interpreted as move to absolute line 345, then type through
absolute line 400.  Absolute line references of this sort can
precede any of the standard ED commands.

     Line numbering is controlled by the V (Verify Line Numbers)
command.  Line numbering can be turned off by typing the -V command.










                               2-5





CP/M Operating System Manual              2.1  Introduction to ED


If the file to edit does not exist, ED displays the following
message:

        NEW FILE

To move text into the memory buffer, you must enter an i command
before typing input lines and terminate each line with a carriage
return.  A single CTRL-Z character returns ED to command mode.


2.1.5  Memory Buffer Operation

     When ED begins, the memory buffer is empty.  You can either
append lines from the source file with the A command, or enter the
lines directly from the console with the insert command.  The insert
command takes the following form:

        I

ED then accepts any number of input lines.  You must terminate each
line with a <cr> (the <lf> is supplied automatically).  A single
CTRL-Z, denoted by a caret (^)Z, returns ED to command mode.  The CP
is positioned after the last character entered.  The following
sequence:

        I<cr>
        NOW IS THE<cr>
        TIME FOR<cr>
        ALL GOOD MEN<cr>
        ^Z

leaves the memory buffer as

        NOW IS THE<cr><lf>
        TIME FOR<cr><lf>
        ALL GOOD MEN<cr><lf>

     Generally, ED accepts command letters in upper- or lower-case.
If the command is upper-case, all input values associated with the
command are translated to upper-case.  If the I command is typed,
all input lines are automatically translated internally to upper-
case.  The lower-case form of the i command is most often used to
allow both upper- and lower-case letters to be entered.

     Various commands can be issued that control the CP or display
source text in the vicinity of the CP.  The commands shown below
with a preceding n indicate that an optional unsigned value can be
specified.  When preceded by +_, the command can be unsigned, or have
an optional preceding plus or minus sign.  As before, the pound sign
# is replaced by 65535.  If an integer n is optional, but not
supplied, then n=1 is assumed.  Finally, if a plus sign is optional,
but none is specified, then + is assumed.





                               2-6





CP/M Operating System Manual              2.1  Introduction to ED


Table 2-2.  Editing Commands

   Command                       Action

F
     +_B        Move CP to beginning of memory buffer if + and
               to bottom if -.

     +_nC       Move CP by +_n characters (moving ahead if +),
               counting the <cr><lf> as two characters.

     +_nD       Delete n characters ahead of CP if plus and
               behind CP if minus.

     +_nK       Kill (remove) +_n lines of source text using CP
               as the current reference.  If CP is not at the
               beginning of the current line when K is issued,
               the characters before CP remain if + is
               specified, while the characters after CP remain
               if - is given in the command.

     +_nL       If n = 0, move CP to the beginning of the
               current line, if it is not already there.  If n
               =/ 0, first move the CP to the beginning of the
               current line and then move it to the beginning
               of the line that is n lines down (if +) or up
               (if -).  The CP will stop at the top or bottom
               of the memory buffer if too large a value of n
               is specified.

     +_nT       If n = 0, type the contents of the current line
               up to CP.  If n = 1, type the contents of the
               current line from CP to the end of the line.
               If n>1, type the current line along with n - 1
               lines that follow, if + is specified.
               Similarly, if n>1 and - is given, type the
               previous n lines up to the CP.  Any key can be
               depressed to abort long type-outs.

     +_n        Equivalent to +_nLT, which moves up or down and
               types a single line.
K



2.1.6  Command Strings

     Any number of commands can be typed contiguously (up to the
capacity of the console buffer) and are executed only after you
press the <cr>.  Table 2-3 summarizes the CP/M console line-editing
commands used to control the input command line.








                               2-7





CP/M Operating System Manual              2.1  Introduction to ED


Table 2-3.  Line-editing Controls

     Command                      Result

F
     CTRL-C     Reboots the CP/M system when typed at the
                start of a line.

     CTRL-E     Physical end of line:  carriage is returned,
                but line is not sent until the carriage return
                key is depressed.

     CTRL-H     Backspaces one character position.

     CTRL-J     Terminates current input (line-feed).

     CTRL-M     Terminates current input (carriage return).

     CTRL-R     Retypes current command line:  types a clean
                line character deletion with rubouts.

     CTRL-U     Deletes the entire line typed at the console.

     CTRL-X     Same as CTRL-U.

     CTRL-Z     Ends input from the console (used in PIP and
                ED).

     rub/del    Deletes and echos the last character typed at
                the console.
K


     Suppose the memory buffer contains the characters shown in the
previous section, with the CP following the last character of the
buffer.  In the following example, the command strings on the left
produce the results shown to the right.  Use lower-case command
letters to avoid automatic translation of strings to upper-case.


  Command String                      Effect

F
     B2T<cr>        Move to beginning of the buffer and type
                    two lines:

                    NOW IS THE
                    TIME FOR
                    The result in the memory buffer is

                    NOW IS THE<cr><lf>
                    TIME FOR<cr><lf>
                    ALL GOOD MEN<cr><lf>







                               2-8





CP/M Operating System Manual              2.1  Introduction to ED


  Command String                      Effect

     5C0T<cr>       Move CP five characters and type the
                    beginning of the line NOW I.  The result
                    in the memory buffer is

                    NOW I  S THE<cr><lf>


     2L-T<cr>       Move two lines down and type the previous
                    line TIME FOR.  The result in the memory
                    buffer is

                    NOW IS THE<cr><lf>
                    TIME FOR<cr><lf>
                    ALL GOOD MEN<cr><lf>


     -L#K<cr>       Move up one line, delete 65535 lines that
                    follow.  The result in the memory buffer
                    is

                    NOW IS THE<cr><lf>


     I<cr>          Insert two  lines of text with  automatic
     TIME TO<cr>    translation to upper-case.  The result in
     INSERT<cr>     the memory buffer is
     ^Z

                    NOW IS THE<cr><lf>
                    TIME TO<cr><lf>
                    INSERT<cr><lf>


     -2L#T<cr>      Move up two lines and type 65535 lines
                    ahead of CP NOW IS THE.  The result in the
                    memory buffer is

                    NOW IS THE<cr><lf>
                    TIME TO<cr><lf>
                    INSERT<cr><lf>


     <cr>           Move down one line and type one line
                    INSERT.  The result in the memory buffer
                    is

                    NOW IS THE<cr><lf>
                    TIME TO<cr><lf>
                    INSERT<cr><lf>
K






                               2-9





CP/M Operating System Manual              2.1  Introduction to ED


2.1.7  Text Search and Alteration

     ED has a command that locates strings within the memory buffer.
The command takes the form

        nF s <cr>
or
        nF s ^Z

where s represents the string to match, followed by either a <cr> or
CTRL-Z, denoted by ^Z.  ED starts at the current position of CP and
attempts to match the string.  The match is attempted n times and,
if successful, the CP is moved directly after the string.  If the n
matches are not successful, the CP is not moved from its initial
position.  Search strings can include CTRL-L, which is replaced by
the pair of symbols <cr><lf>.

     The following commands illustrate the use of the F command:


  Command String                      Effect

F
     B#T<cr>        Move to the beginning and type the entire
                    buffer.  The result in the memory buffer
                    is

                    NOW IS THE <cr><lf>
                    TIME FOR<cr><lf>
                    ALL GOOD MEN<cr><lf>


     FS T<cr>       Find the end of the string S T.  The
                    result in the memory buffer is

                    NOW IS T  HE<cr><lf>


     FIs^Z0TT       Find the next I and type to the CP; then
                    type the remainder of the current line ME
                    FOR.  The result in the memory buffer is

                    NOW IS THE<cr><lf>
                    TI  ME FOR<cr><lf>

                    ALL GOOD MEN<cr><lf>
K


     An abbreviated form of the insert command is also allowed,
which is often used in conjunction with the F command to make simple
textual changes.  The form is

        | s ^Z
or
        | s<cr>



                               2-10





CP/M Operating System Manual              2.1  Introduction to ED


where s is the string to insert.  If the insertion string is
terminated by a CTRL-Z, the string is inserted directly following
the CP, and the CP is positioned directly after the string.  The
action is the same if the command is followed by a <cr> except that
a <cr><lf> is automatically inserted into the text following the
string.  The following command sequences are examples of the F and I
commands:


  Command String                      Effect
F

     BITHIS IS ^Z<cr>

                    Insert THIS IS at the beginning of the
                    text.  The result in the memory buffer is

                    THIS IS  NOW THE<cr><lf>

                    TIME FOR<cr><lf>
                    ALL GOOD MEN<cr><lf>


     FTIME^Z-4DIPLACE^Z<cr>

                    Find TIME and delete it; then insert
                    PLACE.  The result in the memory buffer is

                    THIS IS NOW THE<cr><lf>
                    PLACE    FOR<cr><lf>

                    ALL GOOD MEN<cr><lf>


     3FO^Z-3D5D1
     CHANGES^Z<cr>  Find  third  occurrence of O (that is, the
                    second O in GOOD), delete previous 3
                    characters and the subsequent 5
                    characters; then insert CHANGES.  The
                    result in the memory buffer is

                    THIS IS NOW THE<cr><lf>
                    PLACE FOR<cr><lf>
                    ALL CHANGES   <cr><lf>


     -8CISOURCE<cr>

                    Move back 8 characters and insert the line
                    SOURCE<cr><lf>.  The result in the memory
                    buffer is

                    THIS IS NOW THE<cr><lf>
                    PLACE FOR<cr><lf>
                    ALL SOURCE<cr><lf>
                       CHANGES<cr><lf>


                               2-11



K


CP/M Operating System Manual              2.1  Introduction to ED




     ED also provides a single command that combines the F and I
commands to perform simple string substitutions.  The command takes
the following form:

        nS  s1^Zs2 <cr>
or
        nS s1^Zs2  ^Z

and has exactly the same effect as applying the following command
string a total of n times:

        F s1^Z-kDIs2 <cr>
or
        F s1^Z-kDIs2 ^Z

where k is the length of the string.  ED searches the memory buffer
starting at the current position of CP and successively substitutes
the second string for the first string until the end of buffer, or
until the substitution has been performed n times.

     As a convenience, a command similar to F is provided by ED that
automatically appends and writes lines as the search proceeds.  The
form is

        n N s <cr>
or
        n N s ^Z

which searches the entire source file for the nth occurrence of the
strings (you should recall that F fails if the string cannot be
found in the current buffer).  The operation of the N command is
precisely the same as F except in the case that the string cannot be
found within the current memory buffer.  In this case, the entire
memory content is written (that is, an automatic #W is issued).
Input lines are then read until the buffer is at least half full, or
the entire source file is exhausted.  The search continues in this
manner until the string has been found n times, or until the source
file has been completely transferred to the temporary file.

     A final line editing function, called the juxtaposition
command, takes the form

        n J s1^Zs2^Zs3 <cr>
or
        n J s1^Zs2^Zs3 ^Z

with the following action applied n times to the memory buffer:
search from the current CP for the next occurrence of the string s1.
If found, insert the string s2, and move CP to follow s2.  Then
delete all characters following CP up to, but not including, the
string s3, leaving CP directly after s2.  If s3 cannot be found,
then no deletion is made.  If the current line is



                               2-12





CP/M Operating System Manual              2.1  Introduction to ED


        NOW IS THE TIME<cr><lf>

the command

        JW ^ZWHAT^Z^1<cr>

results in

        NOW WHAT <cr lf>

You should recall that ^1 (CTRL-L) represents the pair <cr><lf> in
search and substitute strings.

     The number of characters ED allows in the F, S, N, and J
commands is limited to 100 symbols.


2.1.8  Source Libraries

     ED also allows the inclusion of source libraries during the
editing process with the R command.  The form of this command is

        R filename ^Z
or
        R filename <cr>

where filename is the primary filename of a source file on the disk
with an assumed filetype of LIB.  ED reads the specified file, and
places the characters into the memory buffer after CP, in a manner
similar to the I command.  Thus, if the command

        RMACRO<cr>

is issued by the operator, ED reads from the file MACRO.LIB until
the end-of-file and automatically inserts the characters into the
memory buffer.

     ED also includes a block move facility implemented through the
X (Transfer) command.  The form

        nX

transfers the next n lines from the current line to a temporary file
called

        X$$$$$$.LIB

which is active only during the editing process.  You can reposition
the current line reference to any portion of the source file and
transfer lines to the temporary file.  The transferred lines
accumulate one after another in this file and can be retrieved by
simply typing

        R



                               2-13





CP/M Operating System Manual              2.1  Introduction to ED


which is the trivial case of the library read command.  In this
case, the entire transferred set of lines is read into the memory
buffer.  Note that the X command does not remove the transferred
lines from the memory buffer, although a K command can be used
directly after the X, and the R command does not empty the
transferred LIB file.  That is, given that a set of lines has been
transferred with the X command, they can be reread any number of
times back into the source file.  The command

        0X

is provided to empty the transferred line file.

     Note that upon normal completion of the ED program through Q or
E, the temporary LIB file is removed.  If ED is aborted with a CTRL-
C, the LIB file will exist if lines have been transferred, but will
generally be empty (a subsequent ED invocation will erase the
temporary file).


2.1.9  Repetitive Command Execution

     The macro command M allows you to group ED commands together
for repeated evaluation.  The M command takes the following form:

        n M CS <cr>
or
        n M CS ^Z

where CS represents a string of ED commands, not including another M
command.  ED executes the command string n times if n>1.  If n=0 or
1, the command string is executed repetitively until an error
condition is encountered (for example, the end of the memory buffer
is reached with an F command).

     As an example, the following macro changes all occurrences of
GAMMA to DELTA within the current buffer, and types each line that
is changed:

        MFGAMMA^Z-5DIDELTA^Z0TT<cr>

or equivalently

        MSGAMMA^ZDELTA^Z0TT<cr>


2.2  ED Error Conditions

     On error conditions, ED prints the message BREAK X AT C where X
is one of the error indicators shown in Table 2-4.







                               2-14





CP/M Operating System Manual             2.2  ED Error Conditions


Table 2-4.  Error Message Symbols

   Symbol                         Meaning

H
     ?         Unrecognized command.

     >         Memory buffer full (use one of the commands D, K,
               N, S, or W to remove characters); F, N, or S
               strings too long.

     #         Cannot apply command the number of times
               specified (for example, in F command).

     O         Cannot open LIB file in R command.
K


If there is a disk error, CP/M displays the following message:

        BDOS ERR on d: BAD SECTOR

You can choose to ignore the error by pressing RETURN at the console
(in this case, the memory buffer data should be examined to see if
they were incorrectly read), or you can reset the system with a
CTRL-C and reclaim the back-up file if it exists.  The file can be
reclaimed by first typing the contents of the BAK file to ensure
that it contains the proper information.  For example, type the
following:

        TYPE x.BAK

where x is the file being edited.  Then remove the primary file

        ERA x.y

and rename the BAK file

        REN x.y=x.BAK

The file can then be reedited, starting with the previous version.

     ED also takes file attributes into account.  If you attempt to
edit a Read-Only file, the message

        ** FILE IS READ/ONLY **

appears at the console.  The file can be loaded and examined, but
cannot be altered.  You must end the edit session and use STAT to
change the file attribute to R/W.  If the edited file has the system
attribute set, the following message:

        'SYSTEM' FILE NOT ACCESSIBLE

is displayed and the edit session is aborted.  Again, the STAT
program can be used to change the system attribute, if desired.



                               2-15





CP/M Operating System Manual 2.3  Control Characters and Commands


2.3  Control Characters and Commands

     Table 2-5 summarizes the control characters and commands
available in ED.


Table 2-5.  ED Control Characters

F
    Control                        Function
    Character

    CTRL-C          System reboot

    CTRL-E          Physical <cr><lf> (not actually entered in
                    command)

    CTRL-H          Backspace

    CTRL-J          Logical tab (cols 1, 9, 16, ...)

    CTRL-L          Logical <cr><lf> in search and substitute
                    strings

    CTRL-R          Repeat line

    CTRL-U          Line delete

    CTRL-X          Line delete

    CTRL-Z          String terminator

    rub/del         Character delete

K

     Table 2-6 summarizes the commands used in ED.


Table 2-6.  ED Commands

    Command                        Function
F

      nA            Append lines

      +_B            Begin or bottom of buffer

      +_nC           Move character positions

      +_nD           Delete characters

      E             End edit and close files (normal end)

      nF            Find string





                               2-16



K


CP/M Operating System Manual 2.3  Control Characters and Commands


Table 2-6.  (continued)

    Command                        Function
F

      H             End edit, close and reopen files

      I             Insert characters, use i if both upper and
                    lower-case characters are to be entered.

      nJ            Place strings in juxtaposition

      +_nK           Kill lines

      +_nL           Move down/up lines

      nM            Macro definition

      nN            Find next occurrence with autoscan

      O             Return to original file

      +_nP           Move and print pages

      Q             Quit with no file changes

      R             Read library file

      nS            Substitute strings

      +_nT           Type lines

      +_U            Translate lower- to upper-case if U, no
                    translation if -U

      +_V            Verify line numbers, or show remaining
                    free character space

      0V            A special case of the V command, OV,
                    prints the memory buffer statistics in the
                    form

                    free/total

                    where free is the number of free bytes in
                    the memory buffer (in decimal) and total
                    is the size of the memory buffer

      nW            Write lines

      nZ            Wait (sleep) for approximately n seconds

      +_n            Move and type (+_nLT).
K





                               2-17





CP/M Operating System Manual 2.3  Control Characters and Commands


     Because of common typographical errors, ED requires several
potentially disastrous commands to be typed as single letters,
rather than in composite commands.  The following commands:

   o E(end)
   o H(head)
   o O(original)
   o Q(quit)

must be typed as single letter commands.

     The commands I, J, M, N, R, and S should be typed as i, j, m,
n, r, and s if both upper- and lower-case characters are used in the
operation, otherwise all characters are converted to upper-case.
When a command is entered in upper-case, ED automatically converts
the associated string to upper-case, and vice versa.


End of Section 2






































                               2-18








Section 3

CP/M Assembler



3.1  Introduction

     The CP/M assembler reads assembly-language source files from
the disk and produces 8080 machine language in Intel hex format.  To
start the CP/M assembler, type a command in one of the following
forms:

        ASM filename
        ASM filename.parms

In both cases, the assembler assumes there is a file on the disk
with the name:

        filename.ASM

which contains an 8080 assembly-language source file.  The first and
second forms shown above differ only in that the second form allows
parameters to be passed to the assembler to control source file
access and hex and print file destinations.

     In either case, the CP/M assembler loads and prints the
message:

        CP/M ASSEMBLER VER n.n

where n.n is the current version number.  In the case of the first
command, the assembler reads the source file with assumed filetype
ASM and creates two output files

        filename.HEX
        filename.PRN

     The HEX file contains the machine code corresponding to the
original program in Intel hex format, and the PRN file contains an
annotated listing showing generated machine code, error flags, and
source lines.  If errors occur during translation, they are listed
in the PRN file and at the console.

     The form ASM filename parms is used to redirect input and
output files from their defaults.  In this case, the parms portion
of the command is a three-letter group that specifies the origin of
the source file, the destination of the hex file, and the
destination of the print file.  The form is








                               3-1





CP/M Operating System Manual                    3.1  Introduction


        filename.p1p2p3

where p1, p2, and p3 are single letters.  P1 can be

        A,B, ...,P

which designates the disk name that contains the source file.  P2
can be

        A,B, ...,P

which designates the disk name that will receive the hex file; or,
P2 can be

        Z

which skips the generation of the hex file.

     P3 can be

        A,B, ...,P

which designates the disk name that will receive the print file.  P3
can also be specified as

        X

which places the listing at the console; or

        Z

which skips generation of the print file.  Thus, the command

        ASM X.AAA

indicates that the source, X.HEX, and print, X.PRN, files are also
to be created on disk A.  This form of the command is implied if the
assembler is run from disk A.  Given that you are currently
addressing disk A, the above command is the same as

        ASM X

The command

        ASM X.ABX

indicates that the source file is to be taken from disk A, the hex
file is to be placed on disk B, and the listing file is to be sent
to the console.  The command

        ASM X.BZZ

takes the source file from disk B and skips the generation of the
hex and print files.  This command is useful for fast execution of
the assembler to check program syntax.


                               3-2





CP/M Operating System Manual                    3.1  Introduction



     The source program format is compatible with the Intel 8080
assembler.  Macros are not implemented in ASM; see the optional MAC
macro assembler.  There are certain extensions in the CP/M assembler
that make it somewhat easier to use.  These extensions are described
below.


3.2  Program Format

     An assembly-language program acceptable as input to the
assembler consists of a sequence of statements of the form

        line# label operation operand ;comment

where any or all of the fields may be present in a particular
instance.  Each assembly-language statement is terminated with a
carriage return and line-feed (the line-feed is inserted
automatically by the ED program), or with the character !, which is
treated as an end-of-line by the assembler.  Thus, multiple
assembly-language statements can be written on the same physical
line if separated by exclamation point symbols.

     The line# is an optional decimal integer value representing the
source program line number, and ASM ignores this field if present.

     The label field takes either of the following forms:

        identifier
        identifier:

The label field is optional, except where noted in particular
statement types.  The identifier is a sequence of alphanumeric
characters where the first character is alphabetic.  Identifiers can
be freely used by the programmer to label elements such as program
steps and assembler directives, but cannot exceed 16 characters in
length.  All characters are significant in an identifier, except for
the embedded dollar symbol $, which can be used to improve
readability of the name.  Further, all lower-case alphabetics are
treated as upper-case.  The following are all valid instances of
labels:


        x       xy      long$name

        x:      yxl:    longer$named$data:

        X1Y2    X1x2    x234$5678$9012$3456:


     The operation field contains either an assembler directive or
pseudo operation, or an 8080 machine operation code.  The pseudo
operations and machine operation codes are described in Section 3.3.




                               3-3





CP/M Operating System Manual                  3.2  Program Format


     Generally, the operand field of the statement contains an
expression formed out of constants and labels, along with arithmetic
and logical operations on these elements.  Again, the complete
details of properly formed expressions are given in Section 3.3.

     The comment field contains arbitrary characters following the
semicolon symbol until the next real or logical end-of-line.  These
characters are read, listed, and otherwise ignored by the assembler.
The CP/M assembler also treats statements that begin with an * in
column one as comment statements that are listed and ignored in the
assembly process.

     The assembly-language program is formulated as a sequence of
statements of the above form, terminated by an optional END
statement.  All statements following the END are ignored by the
assembler.


3.3  Forming the Operand

     To describe the operation codes and pseudo operations
completely, it is necessary first to present the form of the operand
field, since it is used in nearly all statements.  Expressions in
the operand field consist of simple operands, labels, constants, and
reserved words, combined in properly formed subexpressions by
arithmetic and logical operators.  The expression computation is
carried out by the assembler as the assembly proceeds.  Each
expression must produce a 16-bit value during the assembly.
Further, the number of significant digits in the result must not
exceed the intended use.  If an expression is to be used in a byte
move immediate instruction, the most significant 8 bits of the
expression must be zero.  The restriction on the expression
significance is given with the individual instructions.


3.3.1  Labels

     As discussed above, a label is an identifier that occurs on a
particular statement.  In general, the label is given a value
determined by the type of statement that it precedes.  If the label
occurs on a statement that generates machine code or reserves memory
space (for example, a MOV instruction or a DS pseudo operation), the
label is given the value of the program address that it labels.  If
the label precedes an EQU or SET, the label is given the value that
results from evaluating the operand field.  Except for the SET
statement, an identifier can label only one statement.

     When a label appears in the operand field, its value is
substituted by the assembler.  This value can then be combined with
other operands and operators to form the operand field for a
particular instruction.






                               3-4





CP/M Operating System Manual             3.3  Forming the Operand


3.3.2  Numeric Constants

     A numeric constant is a 16-bit value in one of several bases.
The base, called the radix of the constant, is denoted by a trailing
radix indicator.  The following are radix indicators:

   o B is a binary constant (base 2).
   o O is a octal constant (base 8).
   o Q is a octal constant (base 8).
   o D is a decimal constant (base 10).
   o H is a hexadecimal constant (base 16).

     Q is an alternate radix indicator for octal numbers because the
letter O is easily confused with the digit 0.  Any numeric constant
that does not terminate with a radix indicator is a decimal
constant.

     A constant is composed as a sequence of digits, followed by an
optional radix indicator, where the digits are in the appropriate
range for the radix.  Binary constants must be composed of 0 and 1
digits, octal constants can contain digits in the range 0-7, while
decimal constants contain decimal digits.  Hexadecimal constants
contain decimal digits as well as hexadecimal digits A(10D), B(11D),
C(12D), D(13D), E(14D), and F(15D).  Note that the leading digit of
a hexadecimal constant must be a decimal digit to avoid confusing a
hexadecimal constant with an identifier.  A leading 0 will always
suffice.  A constant composed in this manner must evaluate to a
binary number that can be contained within a 16-bit counter,
otherwise it is truncated on the right by the assembler.

     Similar to identifiers, embedded $ signs are allowed within
constants to improve their readability.  Finally, the radix
indicator is translated to upper-case if a lower-case letter is
encountered.  The following are all valid instances of numeric
constants:


        1234      1234D     1100B     1111$0000$1111$0000B

        1234H     OFFEH     3377O     33$77$22Q

        3377o     Ofe3h     1234d     Offffh


3.3.3  Reserved Words

     There are several reserved character sequences that have
predefined meanings in the operand field of a statement.  The names
of 8080 registers are given below.  When they are encountered, they
produce the values shown to the right.







                               3-5





CP/M Operating System Manual             3.3  Forming the Operand


                 Table 3-1.  Reserved Characters

                       Character     Value

                           A           7
                           B           0
                           C           1
                           D           2
                           E           3
                           H           4
                           L           5
                           M           6
                           SP          6
                           PSW         6


     Again, lower-case names have the same values as their upper-
case equivalents.  Machine instructions can also be used in the
operand field; they evaluate to their internal codes. In the case of
instructions that require operands, where the specific operand
becomes a part of the binary bit pattern of the instruction, for
example, MOV A,B, the value of the instruction, in this case MOV, is
the bit pattern of the instruction with zeros in the optional
fields, for example, MOV produces 40H.

     When the symbol $ occurs in the operand field, not embedded
within identifiers and numeric constants, its value becomes the
address of the next instruction to generate, not including the
instruction contained within the current logical line.


3.3.4  String Constants

     String constants represent sequences of ASCII characters and
are represented by enclosing the characters within apostrophe
symbols.  All strings must be fully contained within the current
physical line (thus allowing exclamation point symbols within
strings) and must not exceed 64 characters in length.  The
apostrophe character itself can be included within a string by
representing it as a double apostrophe (the two keystrokes ''),
which becomes a single apostrophe when read by the assembler.  In
most cases, the string length is restricted to either one or two
characters (the DB pseudo operation is an exception), in which case
the string becomes an 8- or 16-bit value, respectively.  Two-
character strings become a 16-bit constant, with the second
character as the low-order byte, and the first character as the
high-order byte.

     The value of a character is its corresponding ASCII code.
There is no case translation within strings; both upper- and lower-
case characters can be represented.  You should note that only
graphic printing ASCII characters are allowed within strings.





                               3-6





CP/M Operating System Manual             3.3  Forming the Operand


           Valid strings:          How assembler reads strings:

     'A' 'AB' 'ab' 'c'               A  AB  ab  c
     '' 'a''' '''' ''''                 a'  '   '
     'Walla Walla Wash.'             Walla Walla Wash.
     'She said ''Hello'' to me.'     She said ''Hello'' to me
     'I said ''Hello'' to her.'      I said ''Hello'' to her


3.3.5  Arithmetic and Logical Operators

     The operands described in Section 3.3 can be combined in normal
algebraic notation using any combination of properly formed
operands, operators, and parenthesized expressions.  The operators
recognized in the operand field are described in Table 3-2.


Table 3-2.  Arithmetic and Logical Operators
F

     Operators                         Meaning

      a + b        unsigned arithmetic sum of a and b

      a - b        unsigned arithmetic difference between a
                   and b

        + b        unary plus (produces b)

        - b        unary minus (identical to 0 - b)

      a * b        unsigned magnitude multiplication of a and
                   b

      a / b        unsigned magnitude division of a by b

      a MOD b      remainder after a / b.

      NOT b        logical inverse of b (all 0s become 1s, 1s
                   become 0s), where b is considered a 16-bit
                   value

      a AND b      bit-by-bit logical and of a and b

      a OR b       bit-by-bit logical or of a and b

      a XOR b      bit-by-bit logical exclusive or of a and b

      a SHL b      the value that results from shifting a to
                   the left by an amount b, with zero fill

      a SHR b      the value that results from shifting a to
                   the right by an amount b, with zero fill
K





                               3-7





CP/M Operating System Manual             3.3  Forming the Operand


     In each case, a and b represent simple operands (labels,
numeric constants, reserved words, and one- or two-character
strings) or fully enclosed parenthesized subexpressions, like those
shown in the following examples:


        10+20  10h+37Q  LI/3  (L2+4) SHR 3

        ('a' and 5fh) + '0' ('B'+B) OR (PSW+M)

        (1+(2+c)) shr (A-(B+1))


     Note that all computations are performed at assembly time as
16-bit unsigned operations.  Thus, -1 is computed as 0-1, which
results in the value 0ffffh (that is, all 1s).  The resulting
expression must fit the operation code in which it is used.  For
example, if the expression is used in an ADI (add immediate)
instruction, the high-order 8 bits of the expression must be zero.
As a result, the operation ADI-1 produces an error message (-1
becomes 0ffffh, which cannot be represented as an 8-bit value),
while ADI(-1) AND 0FFH is accepted by the assembler because the AND
operation zeros the high-order bits of the expression.


3.3.6  Precedence of Operators

     As a convenience to the programmer, ASM assumes that operators
have a relative precedence of application that allows the programmer
to write expressions without nested levels of parentheses.  The
resulting expression has assumed parentheses that are defined by the
relative precedence.  The order of application of operators in
unparenthesized expressions is listed below.  Operators listed first
have highest precedence (they are applied first in an
unparenthesized expression), while operators listed last have lowest
precedence.  Operators listed on the same line have equal
precedence, and are applied from left to right as they are
encountered in an expression.


        * / MOD SHL SHR

        - +

        NOT

        AND

        OR XOR


     Thus, the expressions shown to the left below are interpreted
by the assembler as the fully parenthesized expressions shown to the
right.



                               3-8





CP/M Operating System Manual             3.3  Forming the Operand


     a*b+c                       (a*b)+c

     a+b*c                       a+(b*c)

     a MOD b*c SHL d             ((a MOD b)*c) SHL d

     a OR b AND NOT c+d SHL e    a OR (b AND (NOT (c+(d SHL e))))


     Balanced, parenthesized subexpressions can always be used to
override the assumed parentheses; thus, the last expression above
could be rewritten to force application of operators in a different
order, as shown:

        (a OR b) AND (NOT c)+ d SHL e

This results in these assumed parentheses:

        (a OR b) AND ((NOT c) + (d SHL e))

     An unparenthesized expression is well-formed only if the
expression that results from inserting the assumed parentheses is
well-formed.


3.4  Assembler Directives

     Assembler directives are used to set labels to specific values
during the assembly, perform conditional assembly, define storage
areas, and specify starting addresses in the program.  Each
assembler directive is denoted by a pseudo operation that appears in
the operation field of the line.  The acceptable pseudo operations
are shown in Table 3-3.


                Table 3-3.  Assembler Directives

        Directive                 Meaning

          ORG       set the program or data origin

          END       end program, optional start address

          EQU       numeric equate

          SET       numeric set

          IF        begin conditional assembly

          ENDIF     end of conditional assembly

          DB        define data bytes

          DW        define data words

          DS        define data storage area

                               3-9





CP/M Operating System Guide             3.4  Assembler Directives


3.4.1  The ORG Directive

     The ORG statement takes the form:

        label  ORG  expression

where label is an optional program identifier and expression is a
16-bit expression, consisting of operands that are defined before
the ORG statement.  The assembler begins machine code generation at
the location specified in the expression.  There can be any number
of ORG statements within a particular program, and there are no
checks to ensure that the programmer is not defining overlapping
memory areas.  Note that most programs written for the CP/M system
begin with an ORG statement of the form:

        ORG  100H

which causes machine code generation to begin at the base of the
CP/M transient program area.  If a label is specified in the ORG
statement, the label is given the value of the expression.  This
label can then be used in the operand field of other statements to
represent this expression.


3.4.2  The END Directive

     The END statement is optional in an assembly-language program,
but if it is present it must be the last statement.  All subsequent
statements are ignored in the assembly.  The END statement takes the
following two forms:

        label END

        label END expression

where the label is again optional.  If the first form is used, the
assembly process stops, and the default starting address of the
program is taken as 0000.  Otherwise, the expression is evaluated,
and becomes the program starting address.  This starting address is
included in the last record of the Intel-formatted machine code hex
file that results from the assembly.  Thus, most CP/M assembly-
language programs end with the statement:

        END  100H

resulting in the default starting address of 100H (beginning of the
transient program area).










                               3-10





CP/M Operating System Guide             3.4  Assembler Directives


3.4.3  The EQU Directive

     The EQU (equate) statement is used to set up synonyms for
particular numeric values.  The EQU statement takes the form:

        label    EQU    expression

where the label must be present and must not label any other
statement.  The assembler evaluates the expression and assigns this
value to the identifier given in the label field.  The identifier is
usually a name that describes the value in a more human-oriented
manner.  Further, this name is used throughout the program to place
parameters on certain functions.  Suppose data received from a
teletype appears on a particular input port, and data is sent to the
teletype through the next output port in sequence.  For example, you
can use this series of equate statements to define these ports for a
particular hardware environment:


        TTYBASE      EQU 10H         ;BASE PORT NUMBER FOR TTY

        TTYIN        EQU TTYBASE     ;TTY DATA IN

        TTYOUT       EQU TTYBASE+1   ;TTY DATA OUT


     At a later point in the program, the statements that access the
teletype can appear as follows:


        IN     TTYIN     ;READ TTY DATA TO REG-A

        ...

        OUT    TTYOUT    ;WRITE DATA TO TTY FROM REG-A


making the program more readable than if the absolute I/O ports are
used.  Further, if the hardware environment is redefined to start
the teletype communications ports at 7FH instead of 10H, the first
statement need only be changed to

        TTYBASE    EQU    7FH    ;BASE PORT NUMBER FOR TTY

and the program can be reassembled without changing any other
statements.


3.4.4  The SET Directive

     The SET statement is similar to the EQU, taking the form:

        label    SET    expression

except that the label can occur on other SET statements within the
program.  The expression is evaluated and becomes the current value

                               3-11





CP/M Operating System Guide             3.4  Assembler Directives


associated with the label.  Thus, the EQU statement defines a label
with a single value, while the SET statement defines a value that is
valid from the current SET statement to the point where the label
occurs on the next SET statement.  The use of the SET is similar to
the EQU statement, but is used most often in controlling conditional
assembly.


3.4.5  The IF and ENDIF Directives

     The IF and ENDIF statements define a range of assembly-language
statements that are to be included or excluded during the assembly
process.  These statements take on the form:


        IF  expression

        statement#1

        statement#2

          ...

        statement#n

        ENDIF


     When encountering the IF statement, the assembler evaluates the
expression following the IF.  All operands in the expression must be
defined ahead of the IF statement.  If the expression evaluates to a
nonzero value, then statement#1 through statement#n are assembled.
If the expression evaluates to zero, the statements are listed but
not assembled.  Conditional assembly is often used to write a single
generic program that includes a number of possible run-time
environments, with only a few specific portions of the program
selected for any particular assembly.  The following program
segments, for example, might be part of a program that communicates
with either a teletype or a CRT console (but not both) by selecting
a particular value for TTY before the assembly begins.

















                               3-12





CP/M Operating System Guide             3.4  Assembler Directives


        TRUE     EQU            OFFFFH     ;DEFINE VALUE OF TRUE
        FALSE    EQU            NOT TRUE   ;DEFINE VALUE OF FALSE
        ;
        TTY      EQU            TRUE       ;TRUE IF TTY, FALSE IF CRT
        ;
        TTYBASE  EQU            10H        ;BASE OF TTY I/O PORTS
        CRTBASE  EQU            20H        ;BASE OF CRT I/O PORTS
                 IF             TTY        ;ASSEMBLE RELATIVE TO
                                           ;TTYBASE
        CONIN    EQU            TTYBASE    ;CONSOLE INPUT
        CONOUT   EQU            TTYBASE+1  ;CONSOLE OUTPUT
                 ENDIF

        ;        IF             NOT TTY    ;ASSEMBLE RELATIVE TO
                                           ;CRTBASE
        CONIN    EQU            CRTBASE    ;CONSOLE INPUT
        CONOUT   EQU            CRTBASE+1  ;CONSOLE OUTPUT

                 ENDIF
                 ...
                 IN             CONIN      ;READ CONSOLE DATA
                 ...
                 OUT            CONTOUT    ;WRITE CONSOLE DATA


In this case, the program assembles for an environment where a
teletype is connected, based at port 10H.  The statement defining
TTY can be changed to

        TTY      EQU         FALSE

and, in this case, the program assembles for a CRT based at port
20H.


3.4.6  The DB Directive

     The DB directive allows the programmer to define initialized
storage areas in single-precision byte format.  The DB statement
takes the form:

        label DB e#1, e#2, ..., e#n

where e#1 through e#n are either expressions that evaluate to 8-bit
values (the high-order bit must be zero) or are ASCII strings of
length no greater than 64 characters.  There is no practical
restriction on the number of expressions included on a single source
line.  The expressions are evaluated and placed sequentially into
the machine code file following the last program address generated
by the assembler.  String characters are similarly placed into
memory starting with the first character and ending with the last
character.  Strings of length greater than two characters cannot be
used as operands in more complicated expressions.




                               3-13





CP/M Operating System Guide             3.4  Assembler Directives


Note:  ASCII characters are always placed in memory with the parity
bit reset (0).  Also, there is no translation from lower- to upper-
case within strings.  The optional label can be used to reference
the data area throughout the remainder of the program.  The
following are examples of valid DB statements:


        data:        DB        0,1,2,3,4,5
                     DB        data and 0ffh,5,377Q,1+2+3+4

        sign-on:     DB        'please type your name',cr,lf,0
                     DB        'AB' SHR 8, 'C', 'DE' AND 7FH



3.4.7  The DW Directive

     The DW statement is similar to the DB statement except double-
precision two-byte words of storage are initialized.  The DW
statement takes the form:

        label        DW        e#1, e#2, ..., e#n

where e#1 through e#n are expressions that evaluate to 16-bit
results.  Note that ASCII strings of one or two characters are
allowed, but strings longer than two characters are disallowed.  In
all cases, the data storage is consistent with the 8080 processor;
the least significant byte of the expression is stored first in
memory, followed by the most significant byte.  The following are
examples of DW statements:


        doub:        DW        0ffefh,doub+4,signon-$,255+255
                     DW        'a', 5, 'ab', 'CD', 6 shl 8 or llb.



3.4.8  The DS Directive

     The DS statement is used to reserve an area of uninitialized
memory, and takes the form:

        label        DS        expression

where the label is optional.  The assembler begins subsequent code
generation after the area reserved by the DS.  Thus, the DS
statement given above has exactly the same effect as the following
statement:

       label:       EQU  $  ;LABEL VALUE IS CURRENT CODE LOCATION
                    ORG  $+expression  ;MOVE PAST RESERVED AREA






                               3-14





CP/M Operating System Manual                 3.5  Operation Codes


3.5  Operation Codes

     Assembly-language operation codes form the principal part of
assembly-language programs and form the operation field of the
instruction.  In general, ASM accepts all the standard mnemonics for
the Intel 8080 microcomputer, which are given in detail in the Intel
8080 Assembly Language Programming Manual.  Labels are optional on
each input line.  The individual operators are listed briefly in the
following sections for completeness, although the Intel manuals
should be referenced for exact operator details.  In Tables 3-4
through 3-8, bit values have the following meaning:


   o e3 represents a 3-bit value in the range 0-7 that can be one of
     the predefined registers A, B, C, D, E, H, L, M, SP, or PSW.

   o e8 represents an 8-bit value in the range 0-255.

   o e16 represents a 16-bit value in the range 0-65535.


     These expressions can be formed from an arbitrary combination
of operands and operators.  In some cases, the operands are
restricted to particular values within the allowable range, such as
the PUSH instruction.  These cases are noted as they are
encountered.

     In the sections that follow, each operation code is listed in
its most general form, along with a specific example, a short
explanation, and special restrictions.


3.5.1  Jumps, Calls, and Returns

     The Jump, Call, and Return instructions allow several different
forms that test the condition flags set in the 8080 microcomputer
CPU.  The forms are shown in Table 3-4.


Table 3-4.  Jumps, Calls, and Returns
I

  Form   Bit    Example                  Meaning
        Value

  JMP    e16    JMP L1      Jump unconditionally to label

  JNZ    e16    JNZ L2      Jump on nonzero condition to label

  JZ     e16    JZ 100H     Jump on zero condition to label

  JNC    e16    JNC L1+4    Jump no carry to label

  JC     e16    JC L3       Jump on carry to label

  JPO    e16    JPO $+8     Jump on parity odd to label


                               3-15



K


CP/M Operating System Manual                 3.5  Operation Codes


Table 3-4.  (continued)
I

  Form   Bit    Example                  Meaning
        Value

  JPE    e16    JPE L4      Jump on even parity to label

  JP     e16    JP GAMMA    Jump on positive result to label

  JM     e16    JM al       Jump on minus to label


  CALL   e16    CALL S1     Call subroutine unconditionally

  CNZ    e16    CNZ S2      Call subroutine on nonzero
                            condition

  CZ     e16    CZ 100H     Call subroutine on zero condition

  CNC    e16    CNC S1+4    Call subroutine if no carry set

  CC     e16    CC S3       Call subroutine if carry set

  CPO    e16    CPO $+8     Call subroutine if parity odd

  CPE    e16    CPE $4      Call subroutine if parity even

  CP     e16    CP GAMMA    Call subroutine if positive result

  CM     e16    CM b1$c2    Call subroutine if minus flag


  RST    e3     RST 0       Programmed restart, equivalent to
                            CALL 8*e3, except one byte call

  RET                       Return from subroutine

  RNZ                       Return if nonzero flag set

  RZ                        Return if zero flag set

  RNC                       Return if no carry

  RC                        Return if carry flag set

  RPO                       Return if parity is odd

  RPE                       Return if parity is even

  RP                        Return if positive result

  RM                        Return if minus flag is set
K





                               3-16





CP/M Operating System Manual                 3.5  Operation Codes


3.5.2  Immediate Operand Instructions

     Several instructions are available that load single- or double-
precision registers or single-precision memory cells with constant
values, along with instructions that perform immediate arithmetic or
logical operations on the accumulator (register A).  Table 3-5
describes the immediate operand instructions.


Table 3-5.  Immediate Operand Instructions

F
     Form with       Example                Meaning
     Bit Values

     MVI e3,e8    MVI B,255        Move immediate data to
                                   register A, B, C, D, E, H,
                                   L, or M (memory)

     ADI e8       ADI 1            Add immediate operand to A
                                   without carry

     ACI e8       ACI 0FFH         Add immediate operand to A
                                   with carry

     SUI e8       SUI L + 3        Subtract from A without
                                   borrow (carry)

     SBI e8       SBI L AND 11B    Subtract from A with borrow
                                   (carry)

     ANI e8       ANI $ AND 7FH    Logical and A with
                                   immediate data

     XRI e8       XRI 1111$0000B   Exclusive or A with
                                   immediate data

     ORI e8       ORI L AND 1+1    Logical or A with immediate
                                   data

     CPI e8       CPI 'a'          Compare A with immediate
                                   data, same as SUI except
                                   register A not changed.

     LXI e3,e16   LXI B,100H       Load extended immediate to
                                   register pair.  e3 must be
                                   equivalent to B, D, H, or
                                   SP.
K


3.5.3  Increment and Decrement Instructions

     The 8080 provides instructions for incrementing or decrementing
single- and double-precision registers.  The instructions are
described in Table 3-6.



                               3-17





CP/M Operating System Manual                 3.5  Operation Codes


Table 3-6.  Increment and Decrement Instructions
F

     Form with         Example              Meaning
     Bit Value

       INR e3          INR E       Single-precision increment
                                   register.  e3 produces one
                                   of A, B, C, D, E, H, L, M.

       DCR e3          DCR A       Single-precision decrement
                                   register.  e3 produces one
                                   of A, B, C, D, E, H, L, M.

       INX e3          INX SP      Double-precision increment
                                   register pair.  e3 must be
                                   equivalent to B, D, H, or
                                   SP.

       DCX e3          DCX B       Double-precision decrement
                                   register pair.  e3 must be
                                   equivalent to B, D, H, or
                                   SP.
K



3.5.4  Data Movement Instructions

     Instructions that move data from memory to the CPU and from CPU
to memory are given in the following table.


Table 3-7.  Data Movement Instructions
F

     Form with      Example                 Meaning
     Bit Value

     MOV e3,e3      MOV A,B        Move data to leftmost
                                   element from rightmost
                                   element.  e3 produces on
                                   of A, B, C, D, E, H, L, or
                                   M.  MOV M,M is disallowed.

     LDAX e3        LDAX B         Load register A from
                                   computed address.  e3 must
                                   produce either B or D.

     STAX e3        STAX D         Store register A to
                                   computed address.  e3 must
                                   produce either B or D.

     LHLD e16       LHLD L1        Load HL direct from
                                   location e16.  Double-
                                   precision load to H and L.




                               3-18



K


CP/M Operating System Manual                 3.5  Operation Codes


Table 3-7.  (continued)
F

     Form with      Example                 Meaning
     Bit Value

     SHLD e16       SHLD L5+x      Store  HL  direct  to
                                   location e16.  Double-
                                   precision store from H and
                                   L to memory.

     LDA e16        LDA Gamma      Load register A from
                                   address e16.

     STA e16        STA X3-5       Store register A into
                                   memory at e16.

     POP e3         POP PSW        Load register pair from
                                   stack, set SP.  e3 must
                                   produce one of B, D, H, or
                                   PSW.

     PUSH e3        PUSH B         Store register pair into
                                   stack, set SP.  e3 must
                                   produce on of B, D, H, or
                                   PSW.

     IN e8          IN 0           Load register A with data
                                   from port e8.

     OUT e8         OUT 255        Send data from register A
                                   to port e8.

     XTHL                          Exchange data from top of
                                   stack with HL.

     PCHL                          Fill program counter with
                                   data from HL.

     SPHL                          Fill stack pointer with
                                   data from HL.

     XCHG                          Exchange DE pair with HL
                                   pair.
K



3.5.5  Arithmetic Logic Unit Operations

     Instructions that act upon the single-precision accumulator to
perform arithmetic and logic operations are given in the following
table.






                               3-19





CP/M Operating System Manual                 3.5  Operation Codes


Table 3-8.  Arithmetic Logic Unit Operations
F

     Form with       Example                Meaning
     Bit Value

      ADD e3         ADD B         Add register given by e3 to
                                   accumulator without carry.
                                   e3 must produce one of A,
                                   B, C, D, E, H, or L.

      ADC e3         ADC L         Add register to A with
                                   carry, e3 as above.

      SUB e3         SUB H         Subtract reg e3 from A
                                   without carry, e3 is
                                   defined as above.

      SBB e3         SBB 2         Subtract register e3 from A
                                   with carry, e3 defined as
                                   above.

      ANA e3         ANA 1+1       Logical and reg with A, e3
                                   as above.

      XRA e3         XRA A         Exclusive or with A, e3 as
                                   above.

      ORA e3         ORA B         Logical or with A, e3
                                   defined as above.

      CMP e3         CMP H         Compare register with A, e3
                                   as above.

      DAA                          Decimal adjust register A
                                   based upon last arithmetic
                                   logic unit operation.

      CMA                          Complement the bits in
                                   register A.

      STC                          Set the carry flag to 1.

      CMC                          Complement the carry flag.

      RLC                          Rotate bits left, (re)set
                                   carry as a side effect.
                                   High-order A bit becomes
                                   carry.

      RRC                          Rotate bits right, (re)set
                                   carry as side effect.
                                   Low-order A bit becomes
                                   carry.




                               3-20



K


CP/M Operating System Manual                 3.5  Operation Codes


Table 3-8.  (continued)
F

     Form with       Example                Meaning
     Bit Value

      RAL                          Rotate carry/A register to
                                   left.  Carry is involved
                                   in the rotate.

      RAR                          Rotate carry/A register to
                                   right.  Carry is involved
                                   in the rotate.

      DAD e3         DAD B         Double-precision add
                                   register pair e3 to HL.
                                   e3 must produce B, D, H,
                                   or SP.
K


3.5.6  Control Instructions

     The four remaining instructions, categorized as control
instructions, are the following:

   o HLT halts the 8080 processor.
   o DI disables the interrupt system.
   o EI enables the interrupt system.
   o NOP means no operation.


3.6  Error Messages

     When errors occur within the assembly-language program, they
are listed as single-character flags in the leftmost position of the
source listing.  The line in error is also echoed at the console so
that the source listing need not be examined to determine if errors
are present.  The error codes are listed in the following table.


Table 3-9.  Error Codes

F
   Error Code                       Meaning

   D            Data error:  element in data statement cannot
                be placed in the specified data area.

   E            Expression error:  expression is ill-formed
                and cannot be computed at assembly time.

   L            Label error:  label cannot appear in this
                context; might be duplicate label.

   N            Not implemented:  features that will appear in
                future ASM versions.  For example, macros are
                recognized, but flagged in this version.


                               3-21



K


CP/M Operating System Manual                  3.6  Error Messages


Table 3-9.  (continued)

F
   Error Code                       Meaning

   O            Overflow:  expression is too complicated (too
                many pending operators) to be computed and
                should be simplified.

   P            Phase error:  label does not have the same
                value on two subsequent passes through the
                program.

   R            Register error:  the value specified as a
                register is not compatible with the operation
                code.

   S            Syntax error:  statement is not properly
                formed.

   V            Value error:  operand encountered in
                expression is improperly formed.
K


     Table 3-10 lists the error messages that are due to terminal
error conditions.


Table 3-10.  Error Messages

F
     Message       Meaning

     NO SOURCE FILE PRESENT

                   The file specified in the ASM command does
                   not exist on disk.


     NO DIRECTORY SPACE

                   The disk directory is full; erase files
                   that are not needed and retry.


     SOURCE FILE NAME ERROR

                   Improperly formed ASM filename, for
                   example, it is specified with ? fields.


     SOURCE FILE READ ERROR

                   Source file cannot be read properly by the
                   assembler; execute a TYPE to determine the
                   point of error.



                               3-22



K


CP/M Operating System Manual                  3.6  Error Messages


Table 3-10.  (continued)

F
     Message       Meaning

     OUTPUT FILE WRITE ERROR

                   Output files cannot be written properly;
                   most likely cause is a full disk, erase and
                   retry.


     CANNOT CLOSE FILE

                   Output file cannot be closed; check to see
                   if disk is write protected.
K



3.7  A Sample Session

     The following sample session shows interaction with the
assembler and debugger in the development of a simple assembly-
language program.  The arrow represents a carriage return keystroke.


d
A>ASM SORT      Assemble SORT.ASM

CP/M ASSEMBLER - VER 1.0

0015C    Next free address
003H USE FACTOR    Percent of table used 00 to ff (hexadecimal)
END OF ASSEMBLY

A>DIR SORT.*

SORT  ASM    Source file
SORT  BAK    Back-up from last edit
SORT  PRN    Print file (contains tab characters)
SORT  HEX    Machine code file

A>TYPE SORT.PRN
                    Source line

            ;       SORT PROGRAM IN CP/M ASSEMBLY LANGUAGE
            ;       START AT THE BEGINNING OF THE TRANSIENT
                    PROGRAM AREA

Machine code location
0100                ORG               100H

Generated machine code
0100 214601 SORT:   LXI H,SW  ;ADDRESS SWITCH TOGGLE
0103 3601           MVI M,1   ;SET TO 1 FOR FIRST ITERATION
0105 214701         LXI H,I   ;ADDRESS INDEX
0108 3600           MVI M,0   ;I=0


                               3-23





CP/M Operating System Manual                3.7  A Sample Session


            ;
            ;       COMPARE I WITH ARRAY SIZE
010A 7E     COMPL:  MOV A,M   ;A REGISTER = I
010B FE09           CPI N-1   ;CY SET IF I<(N-1)
010D D21901         JNC CONT  ;CONTINUE IF I<=(N-2)
            ;
            ;       END OF ONE PASS THROUGH DATA
0110 214601         LXI H,SW  ;CHECK FOR ZERO SWITCHES
0113 7EB7C200001    MOV A, M! ORA A! JNZ SORT ;END OF SORT IF SW=0
            ;
0118 FF             RST 7     ;GO TO THE DEBUGGER INSTEAD OF REB
            ;
            ;       CONTINUE THIS PASS
Truncated   ;       ADDRESSING I, SO LOAD AV(I) INTO REGISTERS
0119
 5F16002148CONT:    MOV E, A! MVI D, 0! LXI H, AV! DAD D! DAD D
0121 4E792346       MOV C, M! MOV A, C! INX H! MOV B, M
            ;       LOW ORDER BYTE IN A AND C, HIGH ORDER BYTE IN B
            ;
            ;       MOV H AND L TO ADDRESS AV(I+1)
0125 23             INX H
            ;
            ;       COMPARE VALUE WITH REGS CONTAINING AV (I)
0126 965778239E     SUB M! MOV D, A! MOV A, B! INX H! SBB M  ;SUBTRACT
            ;
            ;       BORROW SET IF AV(I+1)>AV(I)
012B DA3F01         JC  INCI  ;SKIP IF IN PROPER ORDER
            ;
            ;       CHECK FOR EQUAL VALUES
012E B2CA3F01       ORA D! JZ INCI ;SKIP IF AV(I) = AV(I+1)
0132 56702B5E       MOV D, M! MOV M, B! DCX H! MOV E, M
0136 712B722B73     MOV M, C! DCX H! MOV M, D! DCX H! MOV M, E
            ;
            ;       INCREMENT SWITCH COUNT
013B 21460134       LXI H,SW! INR M
            ;
            ;       INCREMENT I
013F 21470134C3INCI:LXI H,I! INR M! JMP COMP
            ;
            ;       DATA DEFINITION SECTION
0146 00     SW:     DB 0      ;RESERVE SPACE FOR SWITCH COUNT
0147        I:      DS 1      ;SPACE FOR INDEX
0148 050064001EAV:  DW 5, 100, 30, 50, 20, 7, 1000, 300, 100, -32767
000A =      N       EQU($-AV)/2    ;COMPUTE N INSTEAD OF PRE
015C                END
A>TYPE SORT.HEX     Equate value

:10010000214601360121470136007EFE09D2190140
:100110002146017EB7C20001FF5F16002148011988    Machine code in
:10012000194E79234623965778239EDA3F01B2CAA7    HEX format

:100130003F0156702B5E712B722B732146013421C7
:07014000470134C30A01006E                      Machine code in
:10014800050064001E00320014000700E8032C01BB    HEX format
:0401580064000180BE
:0000000000

                               3-24





CP/M Operating System Manual                3.7  A Sample Session


A>DDT SORT.HEX        Start debug run

16K DDT VER 1.0
NEXT PC
015C 0000     Default address (no address on END statement)
-XP

P=0000 100    Change PC to 100

-UFFFF    Untrace for 65535 steps
                                           Abort with rubout
C0Z0M0E0I0 A=00 B=0000 D=0000 H=0000 S=0100 P=0100 LXI H,0146*0100
-T10    Trace 1016 steps

C0Z0M0E0I0 A=01 B=0000 D=0000 H=0146 S=0100 P=0100 LXI H, 0146
C0Z0M0E0I0 A=01 B=0000 D=0000 H=0146 S=0100 P=0103 MVI M, 01
C0Z0M0E0I0 A=01 B=0000 D=0000 H=0146 S=0100 P=0105 LXI H, 0147
C0Z0M0E0I0 A=01 B=0000 D=0000 H=0147 S=0100 P=0108 MVI M, 00
C0Z0M0E0I0 A=01 B=0000 D=0000 H=0147 S=0100 P=010A MOV A, M
C0Z0M0E0I0 A=00 B=0000 D=0000 H=0147 S=0100 P=010B CPI 09
C1Z0M1E0I0 A=00 B=0000 D=0000 H=0147 S=0100 P=010D JNC 0119
C1Z0M1E0I0 A=00 B=0000 D=0000 H=0147 S=0100 P=0110 LXI H, 0146
C1Z0M1E0I0 A=00 B=0000 D=0000 H=0146 S=0100 P=0113 MOV A, M
C1Z0M1E0I0 A=01 B=0000 D=0000 H=0146 S=0100 P=0114 ORA A
C0Z0M0E0I0 A=01 B=0000 D=0000 H=0146 S=0100 P=0115 JNZ 0100
C0Z0M0E0I0 A=01 B=0000 D=0000 H=0146 S=0100 P=0100 LXI H, 0146
C0Z0M0E0I0 A=01 B=0000 D=0000 H=0146 S=0100 P=0103 MVI M, 01
C0Z0M0E0I0 A=01 B=0000 D=0000 H=0146 S=0100 P=0105 LXI H, 0147
C0Z0M0E0I0 A=01 B=0000 D=0000 H=0147 S=0100 P=0108 MVI M, 00
C0Z0M0E0I0 A=01 B=0000 D=0000 H=0147 S=0100 P=010A MOV A, M*010B
-A10D                                       Stopped at 10BH

010D JC 119   Change to a jump on carry
0110

-XP

P=010B 100   Reset program counter back to beginning of program

-T10    Trace execution for 10H steps

                                              Altered instruction
C0Z0M0E0I0 A=00 B=0000 D=0000 H=0147 S=0100 P=0100 LXI H,0146
C0Z0M0E0I0 A=00 B=0000 D=0000 H=0146 S=0100 P=0103 MVI M,01
C0Z0M0E0I0 A=00 B=0000 D=0000 H=0146 S=0100 P=0105 LXI H,0147
C0Z0M0E0I0 A=00 B=0000 D=0000 H=0147 S=0100 P=0108 MVI M,00
C0Z0M0E0I0 A=00 B=0000 D=0000 H=0147 S=0100 P=010A MOV A,M
C0Z0M0E0I0 A=00 B=0000 D=0000 H=0147 S=0100 P=010B CPI 09
C1Z0M1E0I0 A=00 B=0000 D=0000 H=0147 S=0100 P=010D JC 0119
C1Z0M1E0I0 A=00 B=0000 D=0000 H=0147 S=0100 P=0119 MOV E,A
C1Z0M1E0I0 A=00 B=0000 D=0000 H=0147 S=0100 P=011A MVI D,00
C1Z0M1E0I0 A=00 B=0000 D=0000 H=0147 S=0100 P=011C LXI H,0148
C1Z0M1E0I0 A=00 B=0000 D=0000 H=0148 S=0100 P=011F DAD D
C0Z0M1E0I0 A=00 B=0000 D=0000 H=0148 S=0100 P=0120 DAD D
C0Z0M1E0I0 A=00 B=0000 D=0000 H=0148 S=0100 P=0121 MOV C,M


                               3-25





CP/M Operating System Manual                3.7  A Sample Session


C0Z0M1E0I0 A=00 B=0005 D=0000 H=0148 S=0100 P=0122 MOV A,C
C0Z0M1E0I0 A=05 B=0005 D=0000 H=0148 S=0100 P=0123 INX H
C0Z0M1E0I0 A=05 B=0005 D=0000 H=0149 S=0100 P=0124 MOV B,M*0125
-L100                               Automatic breakpoint

 0100   LXI H,0146
 0103   MVI M,01
 0105   LXI H,0147
 0108   MVI M,00
 010A   MOV A,M        List some code
 010B   CPI 09         from 100H
 010D   JC  0119
 0110   LXI H,0146
 0113   MOV A,M
 0114   ORA A
 0115   JNZ 0100
 -L

 0118   RST 07
 0119   MOV E,A        List more
 011A   MVI D,00
 011C   LXI H,0148
-Abort list with rubout
-G,11B    Start program from current PC (0125H)
          and run in real time to 11BH



*0127   Stopped with an external interrupt 7 from front panel
-T4                        (program was looping indefinitely)
      Look at looping program in trace mode

C0Z0M0E0I0 A=38 B=0064 D=0006 H=0156 S=0100 P=0127 MOV D,A
C0Z0M0E0I0 A=38 B=0064 D=3806 H=0156 S=0100 P=0128 MOV A,B
C0Z0M0E0I0 A=00 B=0064 D=3806 H=0156 S=0100 P=0129 INX H
C0Z0M0E0I0 A=00 B=0064 D=3806 H=0157 S=0100 P=012A SBB M*012B
-D148
                        Data are sorted, but program does not stop.
0148 05 00 07 00 14 00 1E 00........
0150 32 00 64 00 64 00 2C 01 E8 03 01 80 00 00 00 00 2.D.D.,........

0160 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00................

-G0    Return to CP/M

A>DDT SORT.HEX    Reload the memory image

16K DDT VER 1.0
NEXT PC
015C 0000
-XP

P=0000 100    Set PC to beginning of program

-L10D   List bad OPCODE


                               3-26





CP/M Operating System Manual                3.7  A Sample Session



 010D   JNC 0119
 0110   LXI H,0146
-Abort list with rubout
-A10D    Assemble new OPCODE

010D JC 119

0110

-L100   List starting section of program

 0100   LXI H,0146
 0103   MVI M,01
 0105   LXI H,0147
 0108   MVI M,00
-Abort list with rubout
-A103    Change switch initialization to 00

0103 MVI M,0

0105

-^C  Return to CP/M with CTRL-C (G0 works as well)

SAVE 1 SORT.COM     Save 1 page (256 bytes, from 100H to 1ffH) on
                    disk in case there is need to reload later
A>DDT SORT.COM      Restart DDT with saved memory image

16K DDT VER 1.0
NEXT PC
0200 0100    COM file always starts with address 100H
-G     Run the program from PC=100H

*0118    Programmed stop (RST 7) encountered
-D148

                              Data properly sorted
0148 05 00 07 00 14 00 1E 00........
0150 32 00 64 00 64 00 2C 01 E8 03 01 80 00 00 00 00 2.D.D.........

0160 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00................
0170 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00................

-G0   Return to CP/M

A>ED SORT.ASM     Make changes to original program

*N,0^Z0TT     Find next ,0
     MVI        M,0        ;I = 0

*-   Up one line in text
     LXI            H,I    ;ADDRESS INDEX




                               3-27





CP/M Operating System Manual                3.7  A Sample Session


*-   Up another line
     MVI            M,1    ;SET TO 1 FOR FIRST ITERATION

*KT  Kill line and type next line
     LXI            H,I    ;ADDRESS INDEX

*I   Insert new line
     MVI            M,0    ;ZERO SW

*T
     LXI            H,I    ;ADDRESS INDEX

*NJNC^Z0T
    JNC*T
    CONT            ;CONTINUE IF I<=(N-2)

*-2DIC^Z0LT
    JC              CONT   ;CONTINUE IF I<=(N-2)

*E                    Source from disk A
                      HEX to disk A
A>ASM SORT.AAZ        Skip PRN file

CP/M ASSEMBLER - VER 1.0

015C    Next address to assemble
003H USE FACTOR
END OF ASSEMBLY

A>DDT SORT.HEX        Test program changes

16K DDT VER 1.0
NEXT PC
015C 0000
-G100

*0118
-D148
                          Data sorted
0148 05 00 07 00 14 00 1E 00........
0150 32 00 64 00 64 00 2C 01 E8 03 01 80 00 00 00 00 2.D.D..........
0160 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00................

-Abort with rubout

-G0    Return to CP/M--program checks OK.
K


End of Section 3








                               3-28








                            Section 4

                   CP/M Dynamic Debugging Tool



4.1  Introduction

     The DDT program allows dynamic interactive testing and
debugging of programs generated in the CP/M environment.  Invoke the
debugger with a command of one of the following forms:

        DDT
        DDT filename.HEX
        DDT filename.COM

where filename is the name of the program to be loaded and tested.
In both cases, the DDT program is brought into main memory in place
of the Console Command Processor (CCP) and resides directly below
the Basic Disk Operating System (BDOS) portion of CP/M.  Refer to
Section 5 for standard memory organization.  The BDOS starting
address, located in the address field of the JMP instruction at
location 5H, is altered to reflect the reduced Transient Program
Area (TPA) size.

     The second and third forms of the DDT command perform the same
actions as the first, except there is a subsequent automatic load of
the specified HEX or COM file.  The action is identical to the
following sequence of commands:

        DDT
        Ifilename.HEX or Ifilename.COM
        R

where the I and R commands set up and read the specified program to
test.  See the explanation of the I and R commands below for exact
details.

     Upon initiation, DDT prints a sign-on message in the form:

        DDT VER m.m

where m.m is the revision number.

     Following the sign-on message, DDT prompts you with the hyphen
character, -, and waits for input commands from the console.  You
can type any of several single-character commands, followed by a
carriage return to execute the command.  Each line of input can be
line-edited using the following standard CP/M controls:








                               4-1





CP/M Operating System Manual                    4.1  Introduction


Table 4-1.  Line-editing Controls
F

     Control                       Result

     rubout      removes the last character typed

     CTRL-U      removes the entire line, ready for retyping

     CTRL-C      reboots system
K


     Any command can be up to 32 characters in length.  An automatic
carriage return is inserted as character 33, where the first
character determines the command type.  Table 4-2 describes DDT
commands.


                    Table 4-2.  DDT Commands

    Command                    Result
   Character

C
       A        enters assembly-language mnemonics with
                operands.

       D        displays memory in hexadecimal and ASCII.

       F        fills memory with constant data.

       G        begins execution with optional breakpoints.

       I        sets up a standard input File Control
                Block.

       L        lists memory using assembler mnemonics.

       M        moves a memory segment from source to
                destination.

       R        reads a program for subsequent testing.

       S        substitutes memory values.

       T        traces program execution.

       U        untraced program monitoring.

       X        examines and optionally alters the CPU
                state.
K


The command character, in some cases, is followed by zero, one, two,
or three hexadecimal values, which are separated by commas or single
blank characters.  All DDT numeric output is in hexadecimal form.
The commands are not execution until the carriage return is typed at
the end of the command.


                               4-2




CP/M Operating System Manual                    4.1  Introduction


     At any point in the debug run, you can stop execution of DDT by
using either a CTRL-C or G0 (jump to location 0000H) and save the
current memory image by using a SAVE command of the form:

        SAVE n filename. COM

where n is the number of pages (256 byte blocks) to be saved on
disk.  The number of blocks is determined by taking the high-order
byte of the address in the TPA and converting this number to
decimal.  For example, if the highest address in the TPA is 134H,
the number of pages is 12H or 18 in decimal.  You could type a CTRL-
C during the debug run, returning to the CCP level, followed by

        SAVE 18 X.COM

The memory image is saved as X.COM on the disk and can be directly
executed by typing the name X.  If further testing is required, the
memory image can be recalled by typing

        DDT X.COM

which reloads the previously saved program from location 100H
through page 18, 23FFH.  The CPU state is not a part of the COM
file; thus, the program must be restarted from the beginning to test
it properly.


4.2  DDT Commands

     The individual commands are detailed below.  In each case, the
operator must wait for the hyphen prompt character before entering
the command.  If control is passed to a program under test, and the
program has not reached a breakpoint, control can be returned to DDT
by executing a RST 7 from the front panel.  In the explanation of
each command, the command letter is shown in some cases with numbers
separated by commas, the the numbers are represented by lower-case
letters.  These numbers are always assumed to be in a hexadecimal
radix and from one to four digits in length.  Longer numbers are
automatically truncated on the right.

     Many of the commands operate upon a CPU state that corresponds
to the program under test.  The CPU state holds the registers of the
program being debugged and initially contains zeros for all
registers and flags except for the program counter, P, and stack
pointer, S, which default to 100H.  The program counter is
subsequently set to the starting address given in the last record of
a HEX file if a file of this form is loaded, see the I and R
commands.


4.2.1  The A (Assembly) Command

     DDT allows in-line assembly language to be inserted into the
current memory image using the A command, which takes the form:



                               4-3





CP/M Operating System Manual                    4.2  DDT Commands


        As

where s is the hexadecimal starting address for the in-line
assembly.  DDT prompts the console with the address of the next
instruction to fill and reads the console, looking for assembly-
language mnemonics followed by register references and operands in
absolute hexadecimal form.  See the Intel 8080 Assembly Language
Reference Card for a list of mnemonics.  Each successive load
address is printed before reading the console.  The A command
terminates when the first empty line is input from the console.

     Upon completion of assembly language input, you can review the
memory segment using the DDT disassembler (see the L command).

     Note that the assembler/disassembler portion of DDT can be
overlaid by the transient program being tested, in which case the
DDT program responds with an error condition when the A and L
commands are used.


4.2.2  The D (Display) Command

     The D command allows you to view the contents of memory in
hexadecimal and ASCII formats.  The D command takes the forms:

        D
        Ds
        Ds,f

     In the first form, memory is displayed from the current display
address, initially 100H, and continues for 16 display lines.  Each
display line takes the followng form:

aaaa bb bb bb bb bb bb bb bb bb bb bb bb bb bb bb bb cccccccccccccccc

where aaaa is the display address in hexadecimal and bb represents
data present in memory starting at aaaa.  The ASCII characters
starting at aaaa are to the right (represented by the sequence of
character c) where nongraphic characters are printed as a period.
You should note that both upper- and lower-case alphabetics are
displayed, and will appear as upper-case symbols on a console device
that supports only upper-case.  Each display line gives the values
of 16 bytes of data, with the first line truncated so that the next
line begins at an address that is a multiple of 16.

     The second form of the D command is similar to the first,
except that the display address is first set to address s.

     The third form causes the display to continue from address s
through address f.  In all cases, the display address is set to the
first address not displayed in this command, so that a continuing
display can be accomplished by issuing successive D commands with no
explicit addresses.




                               4-4





CP/M Operating System Manual                    4.2  DDT Commands


     Excessively long displays can be aborted by pressing the return
key.


4.2.3  The F (Fill) Command

     The F command takes the form:

        Fs,f,c,

where s is the starting address, f is the final address, and c is a
hexadecimal byte constant.  DDT stores the constant c at address s,
increments the value of s and test against f.  If s exceeds f, the
operation terminates, otherwise the operation is repeated.  Thus,
the fill command can be used to set a memory block to a specific
constant value.


4.2.4  The G (Go) Command

     A program is executed using the G command, with up to two
optional breakpoint addresses.  The G command takes the forms:


        G
        Gs
        Gs,b
        Gs,b,c
        G,b
        G,b,c


     The first form executes the program at the current value of the
program counter in the current machine state, with no breakpoints
set.  The only way to regain control in DDT is through a RST 7
execution.  The current program counter can be viewed by typing an X
or XP command.

     The second form is similar to the first, except that the
program counter in the current machine state is set to address s
before execution begins.

     The third form is the same as the second, except that program
execution stops when address b is encountered (b must be in the area
of the program under test).  The instruction at location b is not
executed when the breakpoint is encountered.

     The fourth form is identical to the third, except that two
breakpoints are specified, one at b and the other at c.
Encountering either breakpoint causes execution to stop, and both
breakpoints are cleared.  The last two forms take the program
counter from the current machine state and set one and two
breakpoints, respectively.




                               4-5





CP/M Operating System Manual                    4.2  DDT Commands


     Execution continues from the starting address in real-time to
the next breakpoint.  There is no intervention between the starting
address and the break address by DDT.  If the program under test
does not reach a breakpoint, control cannot return to DDT without
executing a RST 7 instruction.  Upon encountering a breakpoint, DDT
stops execution and types

        *d

where d is the stop address.  The machine state can be examined at
this point using the X (Examine) command.  You must specify
breakpoints that differ from the program counter address at the
beginning of the G command.  Thus, if the current program counter is
1234H, then the following commands:

        G,1234
        G400,400

both produce an immediate breakpoint without executing any
instructions.


4.2.5  The I (Input) Command

     The I command allows you to insert a filename into the default
File Control Block (FCB) at 5CH.  The FCB created by CP/M for
transient programs is placed at this location (see Section 5).  The
default FCB can be used by the program under test as if it had been
passed by the CP/M Console Processor.  Note that this filename is
also used by DDT for reading additional HEX and COM files.  The I
command takes the forms:

        Ifilename
        Ifilename.typ

     If the second form is used and the filetype is either HEX or
COM, subsequent R commands can be used to read the pure binary or
hex format machine code.  Section 4.2.8 gives further details.


4.2.6  The L (List) Command

     The L command is used to list assembly-language mnemonics in a
particular program region.  The L command takes the forms:

        L
        Ls
        Ls,f

     The first form lists twelve lines of disassembled machine code
from the current list address.  The second form sets the list
address to s and then lists twelve lines of code.  The last form
lists disassembled code from s through address f.  In all three
cases, the list address is set to the next unlisted location in
preparation for a subsequent L command.  Upon encountering an


                               4-6





CP/M Operating System Manual                    4.2  DDT Commands


execution breakpoint, the list address is set to the current value
of the program counter (G and T commands).  Again, long typeouts can
be aborted by pressing RETURN during the list process.


4.2.7  The M (Move) Command

     The M command allows block movement of program or data areas
from one location to another in memory.  The M command takes the
form:

        Ms,f,d

where s is the start address of the move, f is the final address,
and d is the destination address.  Data is first removed from s to
d, and both addresses are incremented.  If s exceeds f, the move
operation stops; otherwise, the move operation is repeated.


4.2.8  The R (Read) Command

     The R command is used in conjunction with the I command to read
COM and HEX files from the disk into the transient program area in
preparation for the debug run.  The R command takes the forms:

        R
        RB

where b is an optional bias address that is added to each program or
data address as it is loaded.  The load operation must not overwrite
any of the system parameters from 000H through 0FFH (that is, the
first page of memory).  If b is omitted, then b=0000 is assumed.
The R command requires a previous I command, specifying the name of
a HEX or COM file.  The load address for each record is obtained
from each individual HEX record, while an assumed load address of
100H is used for COM files.  Note that any number of R commands can
be issued following the I command to reread the program under test,
assuming the tested program does not destroy the default area at
5CH.  Any file specified with the filetype COM is assumed to contain
machine code in pure binary form (created with the LOAD or SAVE
command), and all others are assumed to contain machine code in
Intel hex format (produced, for example, with the ASM command).

     Recall that the command,

        DDT filename.filetype

which initiates the DDT program, equals to the following commands:

        DDT
        -Ifilename.filetype
        -R





                               4-7





CP/M Operating System Manual                    4.2  DDT Commands



     Whenever the R command is issued, DDT responds with either the
error indicator ? (file cannot be opened, or a checksum error
occurred in a HEX file) or with a load message.  The load message
takes the form:

        NEXT PC
        nnnn pppp

where nnnn is the next address following the loaded program and pppp
is the assumed program counter (100H for COM files, or taken from
the last record if a HEX file is specified).


4.2.9  The S (Set) Command

     The S command allows memory locations to be examined and
optionally altered.  The S command takes the form:

        Ss

where s is the hexadecimal starting address for examination and
alteration of memory.  DDT responds with a numeric prompt, giving
the memory location, along with the data currently held in memory.
If you type a carriage return, the data is not altered.  If a byte
value is typed, the value is stored at the prompted address.  In
either case, DDT continues to prompt with successive addresses and
values until you type either a period or an invalid input value is
detected.


4.2.10  The T (Trace) Command

     The T command allows selective tracing of program execution for
1 to 65535 program steps.  The T command takes the forms:

        T
        Tn

     In the first form, the CPU state is displayed and the next
program step is executed.  The program terminates immediately, with
the termination address displayed as

        *hhhh

where hhhh is the next address to execute.  The display address
(used in the D command) is set to the value of H and L, and the list
address (used in the L command) is set to hhhh.  The CPU state at
program termination can then be examined using the X command.

     The second form of the T command is similar to the first,
except that execution is traced for n steps (n is a hexadecimal
value) before a program breakpoint occurs.  A breakpoint can be
forced in the trace mode by typing a rubout character.  The CPU
state is displayed before each program step is taken in trace mode.
The format of the display is the same as described in the X command.


                               4-8




CP/M Operating System Manual                    4.2  DDT Commands


     You should note that program tracing is discontinued at the
CP/M interface and resumes after return from CP/M to the program
under test.  Thus, CP/M functions that access I/O devices, such as
the disk drive, run in real-time, avoiding I/O timing problems.
Programs running in trace mode execute approximately 500 times
slower than real-time because DDT gets control after each user
instruction is executed.  Interrupt processing routines can be
traced, but commands that use the breakpoint facility (G, T, and U)
accomplish the break using an RST 7 instruction, which means that
the tested program cannot use this interrupt location.  Further, the
trace mode always runs the tested program with interrupts enabled,
which may cause problems if asynchronous interrupts are received
during tracing.

     To get control back to DDT during trace, press RETURN rather
than executing an RST 7.  This ensures that the trace for current
instruction is completed before interruption.


4.2.11  The U (Untrace) Command

     The U command is identical to the T command, except that
intermediate program steps are not displayed.  The untrace mode
allows from 1 to 65535, (0FFFFH) steps to be executed in monitored
mode and is used principally to retain control of an executing
program while it reaches steady state conditions.  All conditions of
the T command apply to the U command.


4.2.12  The X (Examine) Command

     The X command allows selective display and alteration of the
current CPU state for the program under test.  The X command takes
the forms:

        X
        Xr

where r is one of the 8080 CPU registers listed in the following
table.


                    Table 4-3.  CPU Registers

            Register        Meaning           Value

               C        Carry flag            (0/1)
               Z        Zero flag             (0/1)
               M        Minus flag            (0/1)
               E        Even parity flag      (0/1)
               I        Interdigit carry      (0/1)
               A        Accumulator           (0-FF)
               B        BC register pair      (0-FFFF)
               D        DE register pair      (0-FFFF)



                               4-9





CP/M Operating System Manual                    4.2  DDT Commands


                     Table 4-3.  (continued)

            Register        Meaning           Value

               H        HL register pair      (0-FFFF)
               S        Stack pointer         (0-FFFF)
               P        Program counter       (0-FFFF)


In the first case, the CPU register state is displayed in the
format:

        CfZfMfEflf A=bb B=dddd D=dddd H=dddd S=dddd P=dddd inst

where f is a 0 or 1 flag value, bb is a byte value, and dddd is a
double-byte quantity corresponding to the register pair.  The inst
field contains the disassembled instruction, that occurs at the
location addressed by the CPU state's program counter.

     The second form allows display and optional alteration of
register values, where r is one of the registers given above (C, Z,
M, E, I, A, B, D, H, S, or P).  In each case, the flag or register
value is first displayed at the console.  The DDT program then
accepts input from the console.  If a carriage return is typed, the
flag or register value is not altered.  If a value in the proper
range is typed, the flag or register value is altered.  You should
note that BC, DE, and HL are displayed as register pairs.  Thus, you
must type the entire register pair when B, C, or the BC pair is
altered.


4.3  Implementation Notes

     The organization of DDT allows certain nonessential portions to
be overlaid to gain a larger transient program area for debugging
large programs.  The DDT program consists of two parts:  the DDT
nucleus and the assembler/disassembler module.  The DDT nucleus is
loaded over the CCP and, although loaded with the DDT nucleus, the
assembler/disassembler is overlayable unless used to assemble or
disassemble.

     In particular, the BDOS address at location 6H (address field
of the JMP instruction at location 5H) is modified by DDT to address
the base location of the DDT nucleus, which, in turn, contains a JMP
instruction to the BDOS.  Thus, programs that use this address field
to size memory see the logical end of memory at the base of the DDT
nucleus rather than the base of the BDOS.

     The assembler/disassembler module resides directly below the
DDT nucleus in the transient program area.  If the A, L, T, or X
commands are used during the debugging process, the DDT program
again alters the address field at 6H to include this module, further
reducing the logical end of memory.  If a program loads beyond the
beginning of the assembler/disassembler module, the A and L commands
are lost (their use produces a ? in response) and the trace and


                               4-10





CP/M Operating System Manual            4.3  Implementation Notes


display (T and X) commands list the inst field of the display in
hexadecimal, rather than as a decoded instruction.


4.4  A Sample Program

     The following example shows an edit, assemble, and debug for a
simple program that reads a set of data values and determines the
largest value in the set.  The largest value is taken from the
vector and stored into LARGE at the termination of the program.
U


A>ED SCAN.ASM                Create source program;
                             " " represents carriage return.
*I
                ORG          1-00H          ;START OF TRANSIENT
                                            ;AREA
                MVI          B, LEN         ;LENGTH OF VECTOR TO SCAN
                MVI          C, 0           ;LARGER_RST VALUE SO FAR
LOOP            LXI          H, VECT        ;BASE OF VECTOR
LOOP:           MOV          A, M           ;GET VALUE
                SUB          C              ;LARGER VALUE IN C?
                JNC          NFOUND         ;JUMP IF LARGER VALUE NOT
                                            ;FOUND
;               NEW LARGEST VALUE, STORE IT TO C
                MOV          C, A
NFOUND          INX          H              ;TO NEXT ELEMENT
                DCR          B              ;MORE TO SCAN?
                JNZ          LOOP           ;FOR ANOTHER
;
;               END OF SCAN, STORE C
                MOV          A, C           ;GET LARGEST VALUE
                STA          LARGE
                JMP          0              ;REBOOT
;
;               TEST DATA
VECT:           DB           2,0,4,3,5,6,1,5
LEN             EQU          $-VECT         ;LENGTH
LARGE:          DS           1              ;LARGEST VALUE ON EXIT
                END

















                               4-11





CP/M Operating System Manual                4.4  A Sample Program


^-Z
*B0P
                ORG          100H           ;START OF TRANSIENT AREA
                MVI          B,LEN          ;LENGTH OF VECTOR TO SCAN
                MVI          C,0            ;LARGEST VALUE SO FAR
                LXI          H,VECT         ;BASE OF VECTOR
LOOP:           MOV          A,M            ;GET VALUE
                SUB          C              ;LARGER VALUE IN C?
                JNC          NFOUND         ;JUMP IF LARGER VALUE NOT
                                            ;FOUND
;               NEW LARGEST VALUE, STORE IT TO C
                MOV          C,A
NFOUND:         INX          H              ;TO NEXT ELEMENT
                DCR          B              ;MORE TO SCAN?
                JNZ          LOOP           ;FOR ANOTHER
;               END OF SCAN, STORE C
                MOV          A,C            ;GET LARGEST VALUE
                STA          LARGE
                JMP          0              ;REBOOT
;
;               TEST DATA

VECT:           DB           2,0,4,3,5,6,1,5
LEN             EQU          $-VECT         ;LENGTH
LARGE:          DS           1              ;LARGEST VALUE ON EXIT
                END
*E <--End of edit

A>ASM SCAN     Start Assembler

CP/M ASSEMBLER - VER 1.0

0122
002H USE FACTOR
END OF ASSEMBLY     Assembly complete; lock at program listing

A>TYPE SCAN.PRN
 Code address   Source program
 0100                        ORG 100H       ;START OF TRANSIENT AREA
 0100    0608                MVI B,LEN      ;LENGTH OF VECTOR TO SCAN
 0102    0E00 Machine code   MVI C,0        ;LARGEST VALUE SO FAR
 0104    211901              LXI H,VECT.    ;BASE OF VECTOR
 0107    7E          LOOP:   MOV A,M        ;GET VALUE
 0108    91                  SUB C          ;LARGER VALUE IN C?
 0109    D20D01              JNC NFOUND     ;JUMP IF LARGER VALUE NOT
                                            ;FOUND
                     ;       NEW LARGEST VALUE, STORE IT TO C
 010C    4F                  MOV C,A









                               4-12





CP/M Operating System Manual                4.4  A Sample Program


 010D    23          NFOUND: INX H          ;TO NEXT ELEMENT
 010E    05                  DCR  B         ;MORE TO SCAN?
 010F    C20701              JNZ LOOP       ;FOR ANOTHER
                     ;
                     ;       END OF SCAN, STORE C
 0112    79                  MOV A,C        ;GET LARGEST VALUE
 0113    322101              STA LARGE

 0116    C30000              JMP 0          ;REBOOT
   Code--data listing;
   truncated         ;       TEST DATA
 0119    0200040305  VECT:   DB 2,0,4,3,5,6,1,5
 0008    = Value of  LEN     EQU $-VECT     ;LENGTH
 0121      equate    LARGE:  DS 1           ;LARGEST VALUE ON EXIT
 0122                        END


A>DDT SCAN.HEX      Start debugger using hex format machine code

DDT VER 1.0
NEXT PC                                              Next instruction
0121 0000                                            to execute at
-X     Last load address + 1                         PC=0

C0Z0M0E0I0 A=00 B=0000 D=0000 H=0000 S=0100 P=0000 OUT 7F
-XP                 Examine registers before debug run

P=0000 100    Change PC to 100

-X    Look at registers again

C0Z0M0E0I0 A=00 B=0000 D=0000 H=0000 S=0100 P=0100 MVI B,08
-L100
                              PC changed      Next instruction
                                              to execute at PC=100
 0100   MVI        B,08
 0102   MVI        C,00
 0104   LXI        H,0119
 0107   MOV        A,M
 0108   SUB        C          Disassembled machine
 0109   JNC        010D       code at 100H
 010C   MOV        C,A        (see source listing
 010D   INX        H          for comparison)
 010E   DCR        B
 010F   JNZ        0107
 0112   MOV        A,C
-L










                               4-13





CP/M Operating System Manual                4.4  A Sample Program


 0113   STA        0121
 0116   JMP        0000
 0119   STAX       B
 011A   NOP                   A little more machine
 011B   INR        B          code.  Note that pro-
 011C   INX        B          gram ends at location
 011D   DCR        B          116 with a JMP to
 011E   MVI        B,01       0000.  Remainder of
 0120   DCR        B          listing is assembly of
 0121   LXI        D,2200     data.
 0124   LXI        H,0200
-A116  Enter in-line assembly mode to change the JMP to 0000 into a RST 7,
       which will cause the program under test to return to DDT if 116H is
       ever executed.
0116 RST 7

0117   (Single carriage return stops assemble mode)

-L113   List code at 113H to check that RST 7 was properly inserted

 0113   STA        0121
 0116   RST        07    in place of JMP
 0117   NOP
 0118   NOP
 0119   STAX       B
 011A   NOP
 011B   INR        B
 011C   INX        B
-

-X    Look at registers

C0Z0M0E0I0 A=00 B=0000 D=0000 H=0000 S=0100 P=0100 MVI B,08
-T
   Execute Program for one stop. Initial CPU state, before   is executed

C0Z0M0E0I0 A=00 B=0000 D=0000 H=0000 S=0100 P=0100 MVI B,08*0102
                                       Automatic breakpoint

     Trace one step again (note O8H in B)
C0Z0M0E0I0 A=00 B=0800 D=0000 H=0000 S=0100 P=0102 MVI C,00*0104
-T
     Trace again (Register C is cleared)
C0Z0M0E0I0 A=00 B=0800 D=0000 H=0000 S=0100 P=0104 LXI H,0119*0107
-T3  Trace three steps
C0Z0M0E0I0 A=00 B=0800 D=0000 H=0119 S=0100 P=0107 MOV A,M
C0Z0M0E0I0 A=02 B=0800 D=0000 H=0119 S=0100 P=0108 SUB C
C0Z0M0E0I1 A=02 B=0800 D=0000 H=0119 S=0100 P=0109 JNC 010D*010D
-D119
       Display memory starting at 119H. Automatic breakpoint at 10DH

0119 02 00 04 03 05 06 01.Program data         Lower-case x
0120 05 11 00 22 21 00 02 7E EB 77 13 23 EB 0B 78 B1 ..."!.. . W .#..X.
0130 C2 27 01 C3 03 29 00 00 00 00 00 00 00 00 00 00 ...' ...).........
0140 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ..................


                               4-14





CP/M Operating System Manual                4.4  A Sample Program


0150 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ..................
0160 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 Data are displayed
0170 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 in ASCI with a "."
0180 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 in the position of
0190 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 nongraphic........
01A0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 characters........
01B0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ..................
01C0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ..................
-X
           Current CPU state
C0Z0M0E0I1 A=02 B=0800 D=0000 H=0119 S=0100 P=010D INX H
-T5
     Trace 5 steps from current CPU state
C0Z0M0E0I1 A=02 B=0800 D=0000 H=0119 S=0100 P=010D INX H
C0Z0M0E0I1 A=02 B=0800 D=0000 H=011A S=0100 P=010E DCR B
C0Z0M0E0I1 A=02 B=0700 D=0000 H=011A S=0100 P=010F JNZ 0107
C0Z0M0E0I1 A=02 B=0700 D=0000 H=011A S=0100 P=0107 MOV A,M
C0Z0M0E0I1 A=00 B=0700 D=0000 H=011A S=0100 P=0108 SUB C*0109

U5
                                   Automatic breakpoint
     Trace without listing intermediate states
C0Z1M0E1I1 A=00 B=0700 D=0000 H=011A S=0100 P=0109 JNC 010D*0108
-X
                       CPU state at end of U5
C0Z0M0E1I1 A=04 B=0600 D=0000 H=011B S=0100 P=0108 SUB C
-G   Run program from current PC until completion (in real-time)

*0116   breakpoint at 116H, caused by executing RST 7 in machine code.

-X
     CPU state at end of program
C0Z1M0E1I1 A=00 B=0000 D=0000 H=0121 S=0100 P=0116 RST 07
-XP
     Examine and change program counter

P=0116 100

-X

C0Z1M0E1I1 A=00 B=0000 D=0000 H=0121 S=0100 P=0100 MVI B,08
-T10

                            First data element
                                   Current largest value
                                          Subtract for comparison C
    Trace 10 (hexadecimal) steps
C0Z1M0E1I1 A=00 B=0800 D=0000 H=0121 S=0100 P=0100 MVI B,08
C0Z1M0E1I1 A=00 B=0000 D=0000 H=0121 S=0100 P=0102 MVI C,00
C0Z1M0E1I1 A=00 B=0800 D=0000 H=0121 S=0100 P=0104 LXI H,0119
C0Z1M0E1I1 A=00 B=0800 D=0000 H=0119 S=0100 P=0107 MOV A,M
C0Z1M0E1I1 A=02 B=0800 D=0000 H=0119 S=0100 P=0108 SUB C
C0Z0M0E0I1 A=02 B=0800 D=0000 H=0119 S=0100 P=0109 JNC 010D
C0Z0M0E0I1 A=02 B=0800 D=0000 H=0119 S=0100 P=010D INX H
C0Z0M0E0I1 A=02 B=0800 D=0000 H=011A S=0100 P=010E DCR B


                               4-15





CP/M Operating System Manual                4.4  A Sample Program


C0Z0M0E0I1 A=02 B=0700 D=0000 H=011A S=0100 P=010F JNZ 0107
C0Z0M0E0I1 A=02 B=0700 D=0000 H=011A S=0100 P=0107 MOV A,M
C0Z0M0E0I1 A=00 B=0700 D=0000 H=011A S=0100 P=0108 SUB C
C0Z1M0E1I1 A=00 B=0700 D=0000 H=011A S=0100 P=0109 JNC 010D
C0Z1M0E1I1 A=00 B=0700 D=0000 H=011A S=0100 P=010D INX H
C0Z1M0E1I1 A=00 B=0700 D=0000 H=011B S=0100 P=010E DCR B
C0Z0M0E1I1 A=00 B=0600 D=0000 H=011B S=0100 P=010F JNZ 0107
C0Z0M0E1I1 A=00 B=0600 D=0000 H=011B S=0100 P=0107 MOV A,M*0108
-A109
             Insert a "hot patch" into    Program should have moved the
             the machine code             value from A into C since A>C.
0109 JC 10D  to change the                Since this code was not executed,
             JNC to JC                    it appears that the JNC should
010C                                      have been a JC instruction

       Stop DDT so that a version of
-G0    the patched program can be saved

A>SAVE 1 SCAN.COM  Program resides on first
                   page, so save 1 page.
A>DDT SCAN.COM
                   Restart DDT with the save memory
DDT VER 1.0        image to continue testing
NEXT PC
0200 0100

-L100    List some code

 0100    MVI B,08
 0102    MVI C,00
 0104    LXI H,0119
 0107    MOV A,M
 0108    SUB C
 0109    JC  010D    Previous patch is present in X.COM
 010C    MOV C,A
 010D    INX H
 010E    DCR B
 010F    JNZ 0107
 0112    MOV A,C
 -XP

P=0100

-T10
     Trace to see how patched version operates    Data is moved from A to C
C0Z0M0E0I0 A=00 B=0000 D=0000 H=0000 S=0100 P=0100 MVI B,08
C0Z0M0E0I0 A=00 B=0800 D=0000 H=0000 S=0100 P=0102 MVI C,00
C0Z0M0E0I0 A=00 B=0800 D=0000 H=0000 S=0100 P=0104 LXI H,0119
C0Z0M0E0I0 A=00 B=0800 D=0000 H=0119 S=0100 P=0107 MOV A,M
C0Z0M0E0I0 A=02 B=0800 D=0000 H=0119 S=0100 P=0108 SUB C
C0Z0M0E0I1 A=02 B=0800 D=0000 H=0119 S=0100 P=0109 JC  010D
C0Z0M0E0I1 A=02 B=0800 D=0000 H=0119 S=0100 P=010C MOV C,A
C0Z0M0E0I1 A=02 B=0802 D=0000 H=0119 S=0100 P=010D INX H
C0Z0M0E0I1 A=02 B=0802 D=0000 H=011A S=0100 P=010E DCR B
C0Z0M0E0I1 A=02 B=0702 D=0000 H=011A S=0100 P=010F JNZ 0107


                               4-16





CP/M Operating System Manual                4.4  A Sample Program


C0Z0M0E0I1 A=02 B=0702 D=0000 H=011A S=0100 P=0107 MOV A,M
C0Z0M0E0I1 A=00 B=0702 D=0000 H=011A S=0100 P=0108 SUB C
C1Z0M1E0I0 A=FE B=0702 D=0000 H=011A S=0100 P=0109 JC  010D
C1Z0M1E0I0 A=FE B=0702 D=0000 H=011A S=0100 P=010D INX H
C1Z0M1E0I0 A=FE B=0702 D=0000 H=011B S=0100 P=010E DCR B
C1Z0M0E1I1 A=FE B=0602 D=0000 H=011B S=0100 P=010F JNZ 0107*0107
-X                                  Breakpoint after 16 steps

C1Z0M0E1I1 A=FE B=0602 D=0000 H=011B S=0100 P=0107 MOV A,M
-G,108   Run from current PC and breakpoint at 108H

*0108
-X
                Next data item
C1Z0M0E1I1 A=04 B=0602 D=0000 H=011B S=0100 P=0108 SUB C
-T
    Single step for a few cycles
C1Z0M0E1I1 A=04 B=0602 D=0000 H=011B S=0100 P=0108 SUB C*0109
-T

C0Z0M0E0I1 A=02 B=0602 D=0000 H=011B S=0100 P=0109 JC 010D*010C
-X

C0Z0M0E0I1 A=02 B=0602 D=0000 H=011B S=0100 P=010C MOV C,A
-G   Run to completion

*0116
-X

C0Z1M0E1I1 A=03 B=0003 D=0000 H=0121 S=0100 P=0116 RST 07
-S121   Look at the value of "LARGE"

 0121   03   Wrong value!

 0122   00

 0123   22

 0124   21

 0125   00

 0126   02

 0127   7E  _.    End of the S command

-L100

 0100   MVI        B,08
 0102   MVI        C,00
 0104   LXI        H,0119
 0107   MOV        A,M
 0108   SUB        C
 0109   JC         010D
 010C   MOV        C,A


                               4-17





CP/M Operating System Manual                4.4  A Sample Program


 010D   INX        H
 010E   DCR        B
 010F   JNZ        0107
 0112   MOV        A,C
-L                            Review the code

 0113   STA        0121
 0116   RST        07
 0117   NOP
 0118   NOP
 0119   STAX       B
 011A   NOP
 011B   INR        B
 011C   INX        B
 011D   DCR        B
 011E   MVI        B,01
 0120   DCR        B
-XP

P=0116 100   Reset the PC

-T
    Single step, and watch data values
C0Z1M0E1I1 A=03 B=0003 D=0000 H=0121 S=0100 P=0100 MVI B,08*0102
-T

C0Z1M0E1I1 A=03 B=0803 D=0000 H=0121 S=0100 P=0102 MVI C,00*0104
-T
         Count set     Largest set
C0Z1M0E1I1 A=03 B=0800 D=0000 H=0121 S=0100 P=0104 LXI H,0119*0107
-T
                                    Base address of data set
C0Z1M0E1I1 A=03 B=0800 D=0000 H=0119 S=0100 P=0107 MOV A,M*0108
-T
                 First data item brought to A
C0Z1M0E1I1 A=02 B=0800 D=0000 H=0119 S=0100 P=0108 SUB C*0109
-T

C0Z0M0E0I1 A=02 B=0800 D=0000 H=0119 S=0100 P=0109 JC 010D*010C
-T

C0Z0M0E0I1 A=02 B=0800 D=0000 H=0119 S=0100 P=010C MOV C,A*010D
-T
                       First data item moved to C correctly
C0Z0M0E0I1 A=02 B=0802 D=0000 H=0119 S=0100 P=010D INX H*010E
-T

C0Z0M0E0I1 A=02 B=0802 D=0000 H=011A S=0100 P=010E DCR B*010F
-T

C0Z0M0E0I1 A=02 B=0702 D=0000 H=011A S=0100 P=010F JNZ 0107*0107
-T

C0Z0M0E0I1 A=02 B=0702 D=0000 H=011A S=0100 P=0107 MOV A,M*0108
-T


                               4-18





CP/M Operating System Manual                4.4  A Sample Program


                 Second data item brought to A
C0Z0M0E0I1 A=00 B=0702 D=0000 H=011A S=0100 P=0108 SUB C*0109
-T
                 Subtract destroys data value that was loaded!
C1Z0M1E0I0 A=FE B=0702 D=0000 H=011A S=0100 P=0109 JC 010D*010D
-T

C1Z0M1E0I0 A=FE B=0702 D=0000 H=011A S=0100 P=010D INX H*010E
-L100

 0100   MVI        B,08
 0102   MVI        C,00
 0104   LXI        H,0119
 0107   MOV        A,M
 0108   SUB        C       This should have been a CMP so that register A
 0109   JC         010D    would not be destroyed.
 010C   MOV        C,A
 010D   INX        H
 010E   DCR        B
 010F   JNZ        0107
 0112   MOV        A,C
 -A108

0108 CMP C    Hot patch at 108H changes SUB to CMP

0109

-G0   Stop DDT for SAVE

A>SAVE 1 SCAN.COM    Save memory image

A>DDT SCAN.COM    Restart DDT

DDT VER 1.0
NEXT PC
0200 0100
-XP

P=0100

-L116

 0116   RST        07
 0117   NOP
 0118   NOP               Look at code to see if it was properly loaded
 0119   STAX       B      (long typeout aborted with rubout)
 011A   NOP
 -

-G,116    Run from 100H to completion

*0116
-XC     Look at carry (accidental typo)
C1
-X   Look at CPU state


                               4-19





CP/M Operating System Manual                4.4  A Sample Program


C1Z1M0E1I1 A=06 B=0006 D=0000 H=0121 S=0100 P=0116 RST 07
-S121   Look at "large"--it appears to be correct.

0121 06

0122 00

0123 22

-G0    Stop DDT

A>ED SCAN.ASM    Re-edit the source program, and make both changes

*NSUB
*0LT
     CTRL-Z        SUB     C           ;LARGER VALUE IN C?
*SSUB^|ZCMP^|Z0LT
                   CMP     D           ;LARGER VALUE IN C?
*
                   JNC     NFOUND      ;JUMP IF LARGER VALUE NOT FOUND
*SNC^|ZC^|Z0LT
                   JC      NFOUND      ;JUMP IF LARGER VALUE NOT FOUND
*E
                      Reassemble, selecting source from disk A
A>ASM SCAN.AAZ   <--- Hex to disk A
                      Print to Z (selects no print file)
CP/M ASSEMBLER    VER 1.0

0122
002H USE FACTOR
END OF ASSEMBLY

A>DDT SCAN.HEX    Rerun debugger to check changes

DDT VER 1.0
NEXT PC
0121 0000
-L116

 0116   JMP        0000     Check to ensure end is still at 116H

 0119   STAX       B

 011A   NOP
 011B   INR        B

 -(rubout)

-G100,116    Go from beginning with breakpoint at end

*0116    Breakpoint reached
-D121    Look at "LARGE"
                      Correct value computed
0121 06 00 22 21 00 02 7E EB 77 13 23 EB 0B 78 B1 .. '!... W .#..X.
0130 C2 27 01 C3 03 29 00 00 00 00 00 00 00 00 00 00 .'...)........


                               4-20





CP/M Operating System Manual                4.4  A Sample Program


0140 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ..............

-(rubout) Aborts long typeout

G0    Stop DDT, debug session complete.
K


End of Section 4

















































                               4-21








Section 5

CP/M 2 System Interface


5.1  Introduction

     This chapter describes CP/M (release 2) system organization including the
structure of memory and system entry points.  This section provides
the information you need to write programs that operate under CP/M and
that use the peripheral and disk I/O facilities of the system.

     CP/M is logically divided into four parts, called the Basic Input/Output
System (BIOS), the Basic Disk Operating System (BDOS), the Console Command
Processor (CCP), and the Transient Program Area (TPA).  The BIOS is a
hardware-dependent module that defines the exact low level interface with a
particular computer system that is necessary for peripheral device I/O.
Although a standard BIOS is supplied by Digital Research, explicit
instructions are provided for field reconfiguration of the BIOS to match
nearly any hardware environment, see Section 6.

     The BIOS and BDOS are
logically combined into a single module with a common entry point and
referred to as the FDOS.  The CCP is a distinct program that uses the FDOS to
provide a human-oriented interface with the information that is cataloged on
the back-up storage device.  The TPA is an area of memory,
not used by the FDOS and CCP, where various nonresident operating
system commands and user programs are executed.  The lower portion of memory
is reserved for system information and is detailed in later sections.  Memory
organization of the CP/M system is shown in Figure 5-1.



                  High
                  Memory     FDOS (BDOS+BIOS)
                  FBASE:

                                   CCP
                  CBASE:

                                   TPA
                  TBASE:

                             System Parameters
                  BOOT:


Figure 5-1.  CP/M Memory Organization



     The exact memory addresses corresponding to BOOT, TBASE, CBASE,
and FBASE vary from version to version and are described fully in
Section 6.  All standard CP/M versions assume BOOT=0000H, which is
the base of random access memory.  The machine code found at


                               5-1





CP/M Operating System Manual                    5.1  Introduction


location BOOT performs a system warm start, which loads and
initializes the programs and variables necessary to return control
to the CCP.  Thus, transient programs need only jump to location
BOOT to return control to CP/M at the command level.  Further, the
standard versions assume TBASE=BOOT+0100H, which is normally
location 0100H.  The principal entry point to the FDOS is at
location BOOT+0005H (normally 0005H) where a jump to FBASE is found.
The address field at BOOT+0006H (normally 0006H) contains the value
of FBASE and can be used to determine the size of available memory,
assuming that the CCP is being overlaid by a transient program.

     Transient programs are loaded into the TPA and executed as
follows.  The operator communicates with the CCP by typing command
lines following each prompt.  Each command line takes one of the
following forms:

        command
        command file1
        command file1 file2

where command is either a built-in function, such as DIR or TYPE, or
the name of a transient command or program.  If the command is a
built-in function of CP/M, it is executed immediately.  Otherwise,
the CCP searches the currently addressed disk for a file by the name

        command.COM

     If the file is found, it is assumed to be a memory image of a
program that executes in the TPA and thus implicity originates at
TBASE in memory.  The CCP loads the COM file from the disk into
memory starting at TBASE and can extend up to CBASE.

     If the command is followed by one or two file specifications,
the CCP prepares one or two File Control Block (FCB) names in the
system parameter area.  These optional FCBs are in the form
necessary to access files through the FDOS and are described in
Section 5.2.

     The transient program receives control from the CCP and begins
execution, using the I/O facilities of the FDOS.  The transient
program is called from the CCP.  Thus, it can simply return to the
CCP upon completion of its processing, or can jump to BOOT to pass
control back to CP/M.  In the first case, the transient program must
not use memory above CBASE, while in the latter case, memory up
through FBASE-1 can be used.

     The transient program can use the CP/M I/O facilities to
communicate with the operator's console and peripheral devices,
including the disk subsystem.  The I/O system is accessed by passing
a function number and an information address to CP/M through the
FDOS entry point at BOOT+0005H.  In the case of a disk read, for
example, the transient program sends the number corresponding to a
disk read, along with the address of an FCB to the CP/M FDOS.  The
FDOS, in turn, performs the operation and returns with either a disk
read completion indication or an error number indicating that the


                               5-2





CP/M Operating System Manual                    5.1  Introduction


disk read was unsuccessful.


5.2  Operating System Call Conventions

     This section provides detailed information for performing
direct operating system calls from user programs.  Many of the
functions listed below, however, are accessed more simply through
the I/O macro library provided with the MAC macro assembler and
listed in the Digital Research manual entitled, Programmer's
Utilities Guide for the CP/M Family of Operating Systems.

     CP/M facilities that are available for access by transient
programs fall into two general categories:  simple device I/O and
disk file I/O.  The simple device operations are

   o read a console character
   o write a console character
   o read a sequential character
   o write a sequential character
   o get or set I/O status
   o print console buffer
   o interrogate console ready

     The following FDOS operations perform disk I/O:

   o disk system reset
   o drive selection
   o file creation
   o file close
   o directory search
   o file delete
   o file rename
   o random or sequential read
   o random or sequential write
   o interrogate available disks
   o interrogate selected disk
   o set DMA address
   o set/reset file indicators.

     As mentioned above, access to the FDOS functions is
accomplished by passing a function number and information address
through the primary point at location BOOT+0005H.  In general, the
function number is passed in register C with the information address
in the double byte pair DE.  Single byte values are returned in
register A, with double byte values returned in HL, a zero value is
returned when the function number is out of range.  For reasons of
compatibility, register A = L and register B = H upon return in all
cases.  Note that the register passing conventions of CP/M agree
with those of the Intel PL/M systems programming language.  CP/M
functions and their numbers are listed below.






                               5-3





CP/M Operating System Manual                5.2  Call Conventions


      O  System Reset             19  Delete File
      1  Console Input            20  Read Sequential
      2  Console Output           21  Write Sequential
      3  Reader Input             22  Make File
      4  Punch Output             23  Rename File
      5  List Output              24  Return Login Vector
      6  Direct Console I/O       25  Return Current Disk
      7  Get I/O Byte             26  Set DMA Address
      8  Set I/O Byte             27  Get Addr(Alloc)
      9  Print String             28  Write Protect Disk
     10  Read Console Buffer      29  Get R/0 Vector
     11  Get Console Status       30  Set File Attributes
     12  Return Version Number    31  Get Addr(Disk Parms)
     13  Reset Disk System        32  Set/Get User Code
     14  Select Disk              33  Read Random
     15  Open File                34  Write Random
     16  Close File               35  Compute File Size
     17  Search for First         36  Set Random Record
     18  Search for Next          37  Reset Drive
                                  40  Write Random with Zero Fill


     Functions 28 and 32 should be avoided in application programs
to maintain upward compatibility with CP/M.

     Upon entry to a transient program, the CCP leaves the stack
pointer set to an eight-level stack area with the CCP return address
pushed onto the stack, leaving seven levels before overflow occurs.
Although this stack is usually not used by a transient program (most
transients return to the CCP through a jump to location 0000H) it is
large enough to make CP/M system calls because the FDOS switches to
a local stack at system entry.  For example, the assembly-language
program segment below reads characters continuously until an
asterisk is encountered, at which time control returns to the CCP,
assuming a standard CP/M system with BOOT = 0000H.


        BDOS      EQU        0005H      ;STANDARD CP/M ENTRY
        CONIN     EQU        1          ;CONSOLE INPUT FUNCTION
        ;
                  ORG        0100H      ;BASE OF TPA
        NEXTC:    MVI        C,CONIN    ;READ NEXT CHARACTER
                  CALL       BDOS       ;RETURN CHARACTER IN <A>
                  CPI        '*'        ;END OF PROCESSING?
                  JNZ        NEXTC      ;LOOP IF NOT
                  RET                   ;RETURN TO CCP
                  END


     CP/M implements a named file structure on each disk, providing
a logical organization that allows any particular file to contain
any number of records from completely empty to the full capacity of
the drive.  Each drive is logically distinct with a disk directory
and file data area.  The disk filenames are in three parts: the
drive select code, the filename (consisting of one to eight nonblank


                               5-4





CP/M Operating System Manual                5.2  Call Conventions


characters), and the filetype (consisting of zero to three nonblank
characters).  The filetype names the generic category of a
particular file, while the filename distinguishes individual files
in each category.  The filetypes listed in Table 5-1 name a few
generic categories that have been established, although they are
somewhat arbitrary.


                   Table 5-1.  CP/M Filetypes

                Filetype           Meaning

                   ASM        Assembler Source
                   PRN        Printer Listing
                   HEX        Hex Machine Code
                   BAS        Basic Source File
                   INT        Intermediate Code
                   COM        Command File
                   PLI        PL/I Source File
                   REL        Relocatable Module
                   TEX        TEX Formatter Source
                   BAK        ED Source Backup
                   SYM        SID Symbol File
                   $$$        Temporary File


     Source files are treated as a sequence of ASCII characters,
where each line of the source file is followed by a carriage return,
and line-feed sequence (0DH followed by 0AH).  Thus, one 128-byte
CP/M record can contain several lines of source text.  The end of an
ASCII file is denoted by a CTRL-Z character (1AH) or a real end-of-
file returned by the CP/M read operation.  CTRL-Z characters
embedded within machine code files (for example, COM files) are
ignored and the end-of-file condition returned by CP/M is used to
terminate read operations.

     Files in CP/M can be thought of as a sequence of up to 65536
records of 128 bytes each, numbered from 0 through 65535, thus
allowing a maximum of 8 megabytes per file.  Note, however, that
although the records may be considered logically contiguous, they
may not be physically contiguous in the disk data area.  Internally,
all files are divided into 16K byte segments called logical extents,
so that counters are easily maintained as 8-bit values.  The
division into extents is discussed in the paragraphs that follow:
however, they are not particularly significant for the programmer,
because each extent is automatically accessed in both sequential and
random access modes.

     In the file operations starting with Function 15, DE usually
addresses a FCB.  Transient programs often use the default FCB area
reserved by CP/M at location BOOT+005CH (normally 005CH) for simple
file operations.  The basic unit of file information is a 128-byte
record used for all file operations.  Thus, a default location for
disk I/O is provided by CP/M at location BOOT+0080H (normally 0080H)
which is the initial default DMA address.  See Function 26.


                               5-5





CP/M Operating System Manual                5.2  Call Conventions



     All directory operations take place in a reserved area that
does not affect write buffers as was the case in release 1, with the
exception of Search First and Search Next, where compatibility is
required.

     The FCB data area consists of a sequence of 33 bytes for
sequential access and a series of 36 bytes in the case when the file
is accessed randomly.  The default FCB, normally located at 005CH,
can be used for random access files, because the three bytes
starting at BOOT+007DH are available for this purpose.  Figure 5-2
shows the FCB format with the following fields.



    dr f1 f2 / / f8 t1 t2 t3 ex s1 s2 rc d0 / / dn cr r0 r1 r2
    00 01 02 ... 08 09 10 11 12 13 14 15 16 ... 31 32 33 34 35


             Figure 5-2.  File Control Block Format



The following table lists and describes each of the fields in the
File Control Block figure.


              Table 5-2.  File Control Block Fields

       Field                        Definition

     dr                   drive code (0-16)
                          0 = use default drive for file
                          1 = auto disk select drive A,
                          2 = auto disk select drive B,
                          .
                          .
                          .
                          16= auto disk select drive P.

     f1...f8              contain the filename in ASCII
                          upper-case, with high bit = 0

     t1, t2, t3           contain the filetype in ASCII
                          upper-case, with high bit = 0
                          t1', t2', and t3' denote the
                          bit of these positions,
                          t1' = 1 =>Read-Only file,
                          t2' = 1 =>SYS file, no DIR list

     ex                   contains the current extent
                          number, normally set to 00 by
                          the user, but in range 0-31
                          during file I/O



                               5-6





CP/M Operating System Manual                5.2  Call Conventions


                     Table 5-2.  (continued)

       Field                        Definition

     s1                   reserved for internal system use

     s2                   reserved for internal system use,
                          set to zero on call to OPEN, MAKE,
                          SEARCH

     rc                   record count for extent ex;
                          takes on values from 0-127

     d0...dn              filled in by CP/M; reserved for
                          system use

     cr                   current record to read or write in
                          a sequential file operation;
                          normally set to zero by user

     r0, r1, r2           optional random record number in
                          the range 0-65535, with overflow
                          to r2, r0, r1 constitute a 16-bit
                          value with low byte r0, and high
                          byte r1


     Each file being accessed through CP/M must have a corresponding
FCB, which provides the name and allocation information for all
subsequent file operations.  When accessing files, it is the
programmer's responsibility to fill the lower 16 bytes of the FCB
and initialize the cr field.  Normally, bytes 1 through 11 are set
to the ASCII character values for the filename and filetype, while
all other fields are zero.

     FCBs are stored in a directory area of the disk, and are
brought into central memory before the programmer proceeds with file
operations (see the OPEN and MAKE functions).  The memory copy of
the FCB is updated as file operations take place and later recorded
permanently on disk at the termination of the file operation, (see
the CLOSE command).

     The CCP constructs the first 16 bytes of two optional FCBs for
a transient by scanning the remainder of the line following the
transient name, denoted by file1 and file2 in the prototype command
line described above, with unspecified fields set to ASCII blanks.
The first FCB is constructed at location BOOT+005CH and can be used
as is for subsequent file operations.  The second FCB occupies the
d0...dn portion of the first FCB and must be moved to another area
of memory before use.  If, for example, the following command line
is typed:

        PROGNAME B:X.ZOT Y.ZAP




                               5-7





CP/M Operating System Manual                5.2  Call Conventions


the file PROGNAME.COM is loaded into the TPA, and the default FCB at
BOOT+005CH is initialized to drive code 2, filename X, and filetype
ZOT.  The second drive code takes the default value 0, which is
placed at BOOT-006CH, with the filename Y placed into location
BOOT+006DH and filetype ZAP located 8 bytes later at BOOT+0075H.
All remaining fields through cr are set to zero.  Note again that it
is the programmer's responsibility to move this second filename and
filetype to another area, usually a separate file control block,
before opening the file that begins at BOOT+005CH, because the open
operation overwrites the second name and type.

     If no filenames are specified in the original command, the
fields beginning at BOOT+005DH and BOOT+006DH contain blanks.  In
all cases, the CCP translates lower-case alphabetics to upper-case
to be consistent with the CP/M file naming conventions.

     As an added convenience, the default buffer area at location
BOOT+0080H is initialized to the command line tail typed by the
operator following the program name.  The first position contains
the number of characters, with the characters themselves following
the character count.  Given the above command line, the area
beginning at BOOT+0080H is initialized as follows:


     BOOT+0080H:

     +00 +01 +02 +03 +04 +05 +06 +07 +08 +09 +A  +B  +C  +D  +E
     E   ''  'B' ':' 'X' '.' 'Z' 'O' 'T' ''  'Y' '.' 'Z' 'A' 'P'


where the characters are translated to upper-case ASCII with
uninitialized memory following the last valid character.  Again, it
is the responsibility of the programmer to extract the information
from this buffer before any file operations are performed, unless
the default DMA address is explicitly changed.

     Individual functions are described in detail in the pages that
follow.



















                               5-8





CP/M Operating System Manual                5.2  Call Conventions






                    FUNCTION 0:  SYSTEM RESET

                    Entry Parameters:
                           Register C:  00H



     The System Reset function returns control to the CP/M operating
system at the CCP level.  The CCP reinitializes the disk subsystem
by selecting and logging-in disk drive A.  This function has exactly
the same effect as a jump to location BOOT.






                   FUNCTION 1:  CONSOLE INPUT

                Entry Parameters:
                      Register C:  01H

                Returned Value:
                      Register A:  ASCII Character



     The Console Input function reads the next console character to
register A.  Graphic characters, along with carriage return, line-
feed, and back space (CTRL-H) are echoed to the console.  Tab
characters, CTRL-I, move the cursor to the next tab stop.  A check
is made for start/stop scroll, CTRL-S, and start/stop printer echo,
CTRL-P.  The FDOS does not return to the calling program until a
character has been typed, thus suspending execution if a character
is not ready.


















                               5-9





CP/M Operating System Manual                5.2  Call Conventions






                   FUNCTION 2:  CONSOLE OUTPUT

                Entry Parameters
                      Register C:  02H
                      Register E:  ASCII Character



     The ASCII character from register E is sent to the console
device.  As in Function 1, tabs are expanded and checks are made for
start/stop scroll and printer echo.






                    FUNCTION 3:  READER INPUT

                Entry Parameters:
                      Register C:  03H

                Returned Value:
                      Register A:  ASCII Character



     The Reader Input function reads the next character from the
logical reader into register A.  See the IOBYTE definition in
Chapter 6.  Control does not return until the character has been
read.






















                               5-10





CP/M Operating System Manual                5.2  Call Conventions






                    FUNCTION 4:  PUNCH OUTPUT

                 Entry Parameters:
                       Register C:  04H
                       register E:  ASCII Character



     The Punch Output function sends the character from register E
to the logical punch device.






                    FUNCTION 5:  LIST OUTPUT

                Entry Parameters:
                      Register C:  05H
                      Register E:  ASCII Character



     The List Output function sends the ASCII character in register
E to the logical listing device.



























                               5-11





CP/M Operating System Manual                5.2  Call Conventions






                 FUNCTION 6:  DIRECT CONSOLE I/O

                Entry Parameters:
                      Register C:  06H
                      Register E:  0FFH (input) or
                                   char (output)

                Returned Value:
                      Register A:  char or status



     Direct Console I/O is supported under CP/M for those
specialized applications where basic console input and output are
required.  Use of this function should, in general, be avoided since
it bypasses all of the CP/M normal control character functions (for
example, CTRL-S and CTRL-P).  Programs that perform direct I/O
through the BIOS under previous releases of CP/M, however, should be
changed to use direct I/O under BDOS so that they can be fully
supported under future releases of MP/M  and CP/M.

     Upon entry to Function 6, register E either contains
hexadecimal FF, denoting a console input request, or an ASCII
character.  If the input value is FF, Function 6 returns A = 00 if
no character is ready, otherwise A contains the next console input
character.

     If the input value in E is not FF, Function 6 assumes that E
contains a valid ASCII character that is sent to the console.

     Function 6 must not be used in conjunction with other console
I/O functions.






                    FUNCTION 7:  GET I/O BYTE

                Entry Parameters:
                      Register C:  07H

                Returned Value:
                      Register A:  I/O Byte Value



     The Get I/O Byte function returns the current value of IOBYTE
in register A.  See Chapter 6 for IOBYTE definition.



                               5-12





CP/M Operating System Manual                5.2  Call Conventions






                    FUNCTION 8:  SET I/O BYTE

                Entry Parameters:
                      Register C:  08H
                      Register E:  I/O Byte Value



     The SET I/O Byte function changes the IOBYTE value to that
given in register E.






                    FUNCTION 9:  PRINT STRING

               Entry Parameters:
                     Register C:  09H
                   Registers DE:  String Address



     The Print String function sends the character string stored in
memory at the location given by DE to the console device, until a $
is encountered in the string.  Tabs are expanded as in Function 2,
and checks are made for start/stop scroll and printer echo.

























                               5-13





CP/M Operating System Manual                5.2  Call Conventions






                FUNCTION 10:  READ CONSOLE BUFFER

                Entry Parameters:
                      Register C:  0AH
                    Registers DE:  Buffer Address

                Returned Value:
                     Console Characters in Buffer



     The Read Buffer functions reads a line of edited console input
into a buffer addressed by registers DE.  Console input is
terminated when either input buffer overflows or a carriage return
or line-feed is typed.  The Read Buffer takes the form:

        DE:+0 +1 +2 +3 +4 +5 +6 +7 +8 . . .+n

        mx nc c1 c2 c3 c4 c5 c6 c7  ... ??

where mx is the maximum number of characters that the buffer will
hold, 1 to 255, and nc is the number of characters read (set by FDOS
upon return) followed by the characters read from the console.  If
nc < mx, then uninitialized positions follow the last character,
denoted by ?? in the above figure.  A number of control functions,
summarized in Table 5-3, are recognized during line editing.


               Table 5-3.  Edit Control Characters

       Character             Edit Control Function

        rub/del     removes and echoes the last character

        CTRL-C      reboots when at the beginning of line

        CTRL-E      causes physical end of line

        CTRL-H      backspaces one character position

        CTRL-J      (line feed) terminates input line

        CTRL-M      (return) terminates input line

        CTRL-R      retypes the current line after new line

        CTRL-U      removes current line

        CTRL-X      same as CTRL-U




                               5-14





CP/M Operating System Manual                5.2  Call Conventions


The user should also note that certain functions that return the
carriage to the leftmost position (for example, CTRL-X) do so only
to the column position where the prompt ended.  In earlier releases,
the carriage returned to the extreme left margin.  This convention
makes operator data input and line correction more legible.




















































                               5-15





CP/M Operating System Manual                5.2  Call Conventions






                FUNCTION 11:  GET CONSOLE STATUS

                Entry Parameters:
                      Register C:  0BH

                Returned Value:
                      Register A:  Console Status



     The Console Status function checks to see if a character has
been typed at the console.  If a character is ready, the value 0FFH
is returned in register A.  Otherwise a 00H value is returned.






               FUNCTION 12:  RETURN VERSION NUMBER

               Entry Parameters:
                     Register C:  0CH

               Returned Value:
                   Registers HL:  Version Number



     Function 12 provides information that allows version
independent programming.  A two-byte value is returned, with H = 00
designating the CP/M release (H = 01 for MP/M) and L = 00 for all
releases previous to 2.0.  CP/M 2.0 returns a hexadecimal 20 in
register L, with subsequent version 2 releases in the hexadecimal
range 21,22, through 2F.  Using Function 12, for example, the user
can write application programs that provide both sequential and
random access functions.
















                               5-16





CP/M Operating System Manual                5.2  Call Conventions






                 FUNCTION 13:  RESET DISK SYSTEM

                    Entry Parameters:
                          Register C:  0DH



     The Reset Disk function is used to programmatically restore the
file system to a reset state where all disks are set to Read-Write.
See functions 28 and 29, only disk drive A is selected, and the
default DMA address is reset to BOOT+0080H.  This function can be
used, for example, by an application program that requires a disk
change without a system reboot.






                    FUNCTION 14:  SELECT DISK

                 Entry Parameters:
                       Register C:  0EH
                       Register E:  Selected Disk



     The Select Disk function designates the disk drive named in
register E as the default disk for subsequent file operations, with
E = O for drive A, 1 for drive B, and so on through 15,
corresponding to drive P in a full 16 drive system.  The drive is
placed in an on-line status, which activates its directory until the
next cold start, warm start, or disk system reset operation.  If the
disk medium is changed while it is on-line, the drive automatically
goes to a Read-Only status in a standard CP/M environment, see
Function 28.  FCBs that specify drive code zero (dr = 00H)
automatically reference the currently selected default drive.  Drive
code values between 1 and 16 ignore the selected default drive and
directly reference drives A through P.














                               5-17





CP/M Operating System Manual                5.2  Call Conventions






                     FUNCTION 15:  OPEN FILE

                Entry Parameters:
                      Register C:  0FH
                    Registers DE:  FCB Address

                Returned Value:
                     Register  A:  Directory Code



     The Open File operation is used to activate a file that
currently exists in the disk directory for the currently active user
number.  The FDOS scans the referenced disk directory for a match in
positions 1 through 14 of the FCB referenced by DE (byte s1 is
automatically zeroed) where an ASCII question mark (3FH) matches any
directory character in any of these positions.  Normally, no
question marks are included, and bytes ex and s2 of the FCB are
zero.

     If a directory element is matched, the relevant directory
information is copied into bytes d0 through dn of FCB, thus allowing
access to the files through subsequent read and write operations.
The user should note that an existing file must not be accessed
until a successful open operation is completed.  Upon return, the
open function returns a directory code with the value 0 through 3 if
the open was successful or 0FFH (255 decimal) if the file cannot be
found.  If question marks occur in the FCB, the first matching FCB
is activated.  Note that the current record, (cr) must be zeroed by
the program if the file is to be accessed sequentially from the
first record.






















                               5-18





CP/M Operating System Manual                5.2  Call Conventions






                    FUNCTION 16:  CLOSE FILE

             Entry Parameters:
                   Register C:  10H
                 Registers DE:  FCB Address

             Returned Value:
                  Register  A:  Directory Code



     The Close File function performs the inverse of the Open File
function.  Given that the FCB addressed by DE has been previously
activated through an open or make function,  the close function
permanently records the new FCB in the reference disk directory see
functions 15 and 22.  The FCB matching process for the close is
identical to the open function.  The directory code returned for a
successful close operation is 0, 1, 2, or 3, while a 0FFH (255
decimal) is returned if the filename cannot be found in the
directory.  A file need not be closed if only read operations have
taken place.  If write operations have occurred, the close operation
is necessary to record the new directory information permanently.































                               5-19





CP/M Operating System Manual                5.2  Call Conventions






                    FUNCTION 17:  SEARCH FOR FIRST

               Entry Parameters:
                     Register C:  11H
                   Registers DE:  FCB Address

               Returned Value:
                    Register  A:  Directory Code



     Search First scans the directory for a match with the file
given by the FCB addressed by DE.  The value 255 (hexadecimal FF) is
returned if the file is not found; otherwise, 0, 1, 2, or 3 is
returned indicating the file is present.  When the file is found,
the current DMA address is filled with the record containing the
directory entry, and the relative starting position is A *32 (that
is, rotate the A register left 5 bits, or ADD A five times).
Although not normally required for application programs, the
directory information can be extracted from the buffer at this
position.

     An ASCII question mark (63 decimal, 3F hexadecimal) in any
position from f1 through ex matches the corresponding field of any
directory entry on the default or auto-selected disk drive.  If the
dr field contains an ASCII question mark, the auto disk select
function is disabled and the default disk is searched, with the
search function returning any matched entry, allocated or free,
belonging to any user number.  This latter function is not normally
used by application programs, but it allows complete flexibility to
scan all current directory values.  If the dr field is not a
question mark, the s2 byte is automatically zeroed.





















                               5-20





CP/M Operating System Manual                5.2  Call Conventions






                  FUNCTION 18:  SEARCH FOR NEXT

                 Entry Parameters:
                       Register C:  12H

                   Returned Value:
                      Register  A:  Directory Code



     The Search Next function is similar to the Search First
function, except that the directory scan continues from the last
matched entry.  Similar to Function 17, Function 18 returns the
decimal value 255 in A when no more directory items match.






                    FUNCTION 19:  DELETE FILE

                Entry Parameters:
                      Register C:  13H
                    Registers DE:  FCB Address

                Returned Value:
                     Register  A:  Directory Code



     The Delete File function removes files that match the FCB
addressed by DE.  The filename and type may contain ambiguous
references (that is, question marks in various positions), but the
drive select code cannot be ambiguous, as in the Search and Search
Next functions.

     Function 19 returns a decimal 255 if the referenced file or
files cannot be found; otherwise, a value in the range 0 to 3
returned.













                               5-21





CP/M Operating System Manual                5.2  Call Conventions






                  FUNCTION 20:  READ SEQUENTIAL

               Entry Parameters:
                     Register C:  14H
                   Registers DE:  FCB Address

               Returned Value:
                    Register  A:  Directory Code



     Given that the FCB addressed by DE has been activated through
an Open or Make function, the Read Sequential function reads the
next 128-byte record from the file into memory at the current DMA
address.  The record is read from position cr of the extent, and the
cr field is automatically incremented to the next record position.
If the cr field overflows, the next logical extent is automatically
opened and the cr field is reset to zero in preparation for the next
read operation.  The value 00H is returned in the A register if the
read operation was successful, while a nonzero value is returned if
no data exist at the next record position (for example, end-of-file
occurs).






                 FUNCTION 21:  WRITE SEQUENTAIL

               Entry Parameters:
                     Register C:  15H
                   Registers DE:  FCB Address

               Returned Value:
                    Register  A:  Directory Code



     Given that the FCB addressed by DE has been activated through
an Open or Make function, the Write Sequential function writes the
128-byte data record at the current DMA address to the file named by
the FCB.  The record is placed at position cr of the file, and the
cr field is automatically incremented to the next record position.
If the cr field overflows, the next logical extent is automatically
opened and the cr field is reset to zero in preparation for the next
write operation.  Write operations can take place into an existing
file, in which case, newly written records overlay those that
already exist in the file.  Register A = 00H upon return from a
successful write operation, while a nonzero value indicates an
unsuccessful write caused by a full disk.


                               5-22





CP/M Operating System Manual                5.2  Call Conventions






                     FUNCTION 22:  MAKE FILE

                 Entry Parameters:
                       Register C:  16H
                     Registers DE:  FCB Address

                 Returned Value:
                      Register  A:  Directory Code



     The Make File operation is similar to the Open File operation
except that the FCB must name a file that does not exist in the
currently referenced disk directory (that is, the one named
explicitly by a nonzero dr code or the default disk if dr is zero).
The FDOS creates the file and initializes both the directory and
main memory value to an empty file.  The programmer must ensure that
no duplicate filenames occur, and a preceding delete operation is
sufficient if there is any possibility of duplication.  Upon return,
register A = 0, 1, 2, or 3 if the operation was successful and 0FFH
(255 decimal) if no more directory space is available.  The Make
function has the side effect of activating the FCB and thus a
subsequent open is not necessary.






                    FUNCTION 23:  RENAME FILE

                Entry Parameters:
                      Register C:  17H
                    Registers DE:  FCB Address

                Returned Value:
                     Register  A:  Directory Code



     The Rename function uses the FCB addressed by DE to change all
occurrences of the file named in the first 16 bytes to the file
named in the second 16 bytes.  The drive code dr at postion 0 is
used to select the drive, while the drive code for the new filename
at position 16 of the FCB is assumed to be zero.  Upon return,
register A is set to a value between 0 and 3 if the rename was
successful and 0FFH (255 decimal) if the first filename could not be
found in the directory scan.





                               5-23





CP/M Operating System Manual                5.2  Call Conventions






               FUNCTION 24:  RETURN LOG-IN VECTOR

               Entry Parameters:
                     Register C:  18H

               Returned Value:
                   Registers HL:  Log-in Vector



     The log-in vector value returned by CP/M is a 16-bit value in
HL, where the least significant bit of L corresponds to the first
drive A and the high-order bit of H corresponds to the sixteenth
drive, labeled P.  A 0 bit indicates that the drive is not on-line,
while a 1 bit marks a drive that is actively on-line as a result of
an explicit disk drive selection or an implicit drive select caused
by a file operation that specified a nonzero dr field.  The user
should note that compatibility is maintained with earlier releases,
because registers A and L contain the same values upon return.






                FUNCTION 25:  RETURN CURRENT DISK

                Entry Parameters:
                      Register C:  19H

                Returned Value:
                     Register  A:  Current Disk



     Function 25 returns the currently selected default disk number
in register A.  The disk numbers range from 0 through 15
corresponding to drives A through P.















                               5-24





CP/M Operating System Manual                5.2  Call Conventions






                  FUNCTION 26:  SET DMA ADDRESS

                Entry Parameters:
                      Register C:  1AH
                    Registers DE:  DMA Address



     DMA is an acronym for Direct Memory Address, which is often
used in connection with disk controllers that directly access the
memory of the mainframe computer to transfer data to and from the
disk subsystem.  Although many computer systems use non-DMA access
(that is, the data is transferred through programmed I/O
operations), the DMA address has, in CP/M, come to mean the address
at which the 128-byte data record resides before a disk write and
after a disk read.  Upon cold start, warm start, or disk system
reset, the DMA address is automatically set to BOOT+0080H.  The Set
DMA function can be used to change this default value to address
another area of memory where the data records reside.  Thus, the DMA
address becomes the value specified by DE until it is changed by a
subsequent Set DMA function, cold start, warm start, or disk system
reset.






                 FUNCTION 27:  GET ADDR (ALLOC)

              Entry Parameters:
                    Register C:  1BH

              Returned Value:
                  Registers HL:  ALLOC Address



     An allocation vector is maintained in main memory for each on-
line disk drive.  Various system programs use the information
provided by the allocation vector to determine the amount of
remaining storage (see the STAT program).  Function 27 returns the
base address of the allocation vector for the currently selected
disk drive.  However, the allocation information might be invalid if
the selected disk has been marked Read-Only.  Although this function
is not normally used by application programs, additional details of
the allocation vector are found in Chapter 6.






                               5-25





CP/M Operating System Manual                5.2  Call Conventions






                FUNCTION 28:  WRITE PROTECT DISK

                    Entry Parameters:
                          Register C:  1CH



     The Write Protect Disk function provides temporary write
protection for the currently selected disk.  Any attempt to write to
the disk before the next cold or warm start operation produces the
message:

        BDOS ERR on d:R/O






               FUNCTION 29:  GET READ-ONLY VECTOR

             Entry Parameters:
                   Register C:  1DH

             Returned Value:
                 Registers HL:  R/O Vector Value



     Function 29 returns a bit vector in register pair HL, which
indicates drives that have the temporary Read-Only bit set.  As in
Function 24, the least significant bit corresponds to drive A, while
the most significant bit corresponds to drive P.  The R/O bit is set
either by an explicit call to Function 28 or by the automatic
software mechanisms within CP/M that detect changed disks.


















                               5-26





CP/M Operating System Manual                5.2  Call Conventions






                FUNCTION 30:  SET FILE ATTRIBUTES

             Entry Parameters:
                   Register C:  1EH
                 Registers DE:  FCB Address

             Returned Value:
                  Register  A:  Directory Code



     The Set File Attributes function allows programmatic
manipulation of permanent indicators attached to files.  In
particular, the R/O and System attributes (t1' and t2') can be set
or reset.  The DE pair addresses an unambiguous filename with the
appropriate attributes set or reset.  Function 30 searches for a
match and changes the matched directory entry to contain the
selected indicators.  Indicators f1' through f4' are not currently
used, but may be useful for applications programs, since they are
not involved in the matching process during file open and close
operations.  Indicators f5' through f8' and t3' are reserved for
future system expansion.






               FUNCTION 31:  GET ADDR (DISK PARMS)

                Entry Parameters:
                      Register C:  1FH

                Returned Value:
                    Registers HL:  DPB Address



     The address of the BIOS resident disk parameter block is
returned in HL as a result of this function call.  This address can
be used for either of two purposes.  First, the disk parameter
values can be extracted for display and space computation purposes,
or transient programs can dynamically change the values of current
disk parameters when the disk environment changes, if required.
Normally, application programs will not require this facility.








                               5-27





CP/M Operating System Manual                5.2  Call Conventions






                 FUNCTION 32:  SET/GET USER CODE

               Entry Parameters:
                     Register C:  20H
                     Register E:  OFFH (get) or
                                  User Code (set)

               Returned Value:
                    Register  A:  Current Code or
                                  (no value)



     An application program can change or interrogate the currently
active user number by calling Function 32.  If register E = 0FFH,
the value of the current user number is returned in register A,
where the value is in the range of 0 to 15.  If register E is not
0FFH, the current user number is changed to the value of E, modulo
16.


































                               5-28





CP/M Operating System Manual                5.2  Call Conventions






                    FUNCTION 33:  READ RANDOM

                 Entry Parameters:
                       Register C:  21H

                 Returned Value:
                      Register  A:  Return Code



     The Read Random function is similar to the sequential file read
operation of previous releases, except that the read operation takes
place at a particular record number, selected by the 24-bit value
constructed from the 3-byte field following the FCB (byte positions
r0 at 33, r1 at 34, and r2 at 35).  The user should note that the
sequence of 24 bits is stored with least significant byte first
(r0), middle byte next (r1), and high byte last (r2).  CP/M does not
reference byte r2, except in computing the size of a file (Function
35).  Byte r2 must be zero, however, since a nonzero value indicates
overflow past the end of file.

     Thus, the r0, r1 byte pair is treated as a double-byte, or word
value, that contains the record to read.  This value ranges from 0
to 65535, providing access to any particular record of the 8-
megabyte file.  To process a file using random access, the base
extent (extent 0) must first be opened.  Although the base extent
might or might not contain any allocated data, this ensures that the
file is properly recorded in the directory and is visible in DIR
requests.  The selected record number is then stored in the random
record field (r0, r1), and the BDOS is called to read the record.

     Upon return from the call, register A either contains an error
code, as listed below, or the value 00, indicating the operation was
successful.  In the latter case, the current DMA address contains
the randomly accessed record.  Note that contrary to the sequential
read operation, the record number is not advanced.  Thus, subsequent
random read operations continue to read the same record.

     Upon each random read operation, the logical extent and current
record values are automatically set.  Thus, the file can be
sequentially read or written, starting from the current randomly
accessed position.  However, note that, in this case, the last
randomly read record will be reread as one switches from random mode
to sequential read and the last record will be rewritten as one
switches to a sequential write operation.  The user can simply
advance the random record position following each random read or
write to obtain the effect of sequential I/O operation.






                               5-29





CP/M Operating System Manual                5.2  Call Conventions



     Error codes returned in register A following a random read are
listed below.


        01   reading unwritten data

        02   (not returned in random mode)

        03   cannot close current extent

        04   seek to unwritten extent

        05   (not returned in read mode)

        06   seek past physical end of disk


     Error codes 01 and 04 occur when a random read operation
accesses a data block that has not been previously written or an
extent that has not been created, which are equivalent conditions.
Error code 03 does not normally occur under proper system operation.
If it does, it can be cleared by simply rereading or reopening
extent zero as long as the disk is not physically write protected.
Error code 06 occurs whenever byte r2 is nonzero under the current
2.0 release.  Normally, nonzero return codes can be treated as
missing data, with zero return codes indicating operation complete.






























                               5-30





CP/M Operating System Manual                5.2  Call Conventions






                   FUNCTION 34:  WRITE RANDOM

                Entry Parameters:
                      Register C:  22H
                    Registers DE:  FCB Address

                Returned Value:
                     Register  A:  Return Code



     The Write Random operation is initiated similarly to the Read
Random call, except that data is written to the disk from the
current DMA address.  Further, if the disk extent or data block that
is the target of the write has not yet been allocated, the
allocation is performed before the write operation continues.  As in
the Read Random operation, the random record number is not changed
as a result of the write.  The logical extent number and current
record positions of the FCB are set to correspond to the random
record that is being written.  Again, sequential read or write
operations can begin following a random write, with the notation
that the currently addressed record is either read or rewritten
again as the sequential operation begins.  You can also simply
advance the random record position following each write to get the
effect of a sequential write operation.  Note that reading or
writing the last record of an extent in random mode does not cause
an automatic extent switch as it does in sequential mode.

     The error codes returned by a random write are identical to the
random read operation with the addition of error code 05, which
indicates that a new extent cannot be created as a result of
directory overflow.





















                               5-31





CP/M Operating System Manual                5.2  Call Conventions






                 FUNCTION 35:  COMPUTE FILE SIZE

                  Entry Parameters:
                        Register C:  23H
                      Registers DE:  FCB Address

                  Returned Value:
                      Random Record Field Set



     When computing the size of a file, the DE register pair
addresses an FCB in random mode format (bytes r0, r1, and r2 are
present).  The FCB contains an unambiguous filename that is used in
the directory scan.  Upon return, the random record bytes contain
the virtual file size, which is, in effect, the record address of
the record following the end of the file.  Following a call to
Function 35, if the high record byte r2 is 01, the file contains the
maximum record count 65536.  Otherwise, bytes r0 and r1 constitute a
16-bit value as before (r0 is the least significant byte), which is
the file size.

     Data can be appended to the end of an existing file by simply
calling Function 35 to set the random record position to the end of
file and then performing a sequence of random writes starting at the
preset record address.

     The virtual size of a file corresponds to the physical size
when the file is written sequentially.  If the file was created in
random mode and holes exist in the allocation, the file might
contain fewer records than the size indicates.  For example, if only
the last record of an 8-megabyte file is written in random mode
(that is, record number 65535), the virtual size is 65536 records,
although only one block of data is actually allocated.



















                               5-32





CP/M Operating System Manual                5.2  Call Conventions






                 FUNCTION 36:  SET RANDOM RECORD

                 Entry Parameters:
                       Register C:  24H
                     Registers DE:  FCB Address

                 Returned Value:
                        Random Record Field Set



     The Set Random Record function causes the BDOS automatically to
produce the random record position from a file that has been read or
written sequentially to a particular point.  The function can be
useful in two ways.

     First, it is often necessary initially to read and scan a
sequential file to extract the positions of various key fields.  As
each key is encountered, Function 36 is called to compute the random
record position for the data corresponding to this key.  If the data
unit size is 128 bytes, the resulting record position is placed into
a table with the key for later retrieval.  After scanning the entire
file and tabulating the keys and their record numbers, the user can
move instantly to a particular keyed record by performing a random
read, using the corresponding random record number that was saved
earlier.  The scheme is easily generalized for variable record
lengths, because the program need only store the buffer-relative
byte position along with the key and record number to find the exact
starting position of the keyed data at a later time.

     A second use of Function 36 occurs when switching from a
sequential read or write over to random read or write.  A file is
sequentially accessed to a particular point in the file, Function 36
is called, which sets the record number, and subsequent random read
and write operations continue from the selected point in the file.


















                               5-33





CP/M Operating System Manual                5.2  Call Conventions






                    FUNCTION 37:  RESET DRIVE

                 Entry Parameters:
                       Register C:  25H
                     Registers DE:  Drive Vector

                 Returned Value:
                      Register  A:  00H



     The Reset Drive function allows resetting of specified drives.
The passed parameter is a 16-bit vector of drives to be reset; the
least significant bit is drive A:.

     To maintain compatibility with MP/M, CP/M returns a zero value.






            FUNCTION 40:  WRITE RANDOM WITH ZERO FILL

                 Entry Parameters:
                       Register C:  28H
                     Registers DE:  FCB Address

                 Returned Value:
                      Register  A:  Return Code



     The Write With Zero Fill operation is similar to Function 34,
with the exception that a previously unallocated block is filled
with zeros before the data is written.

















                               5-34





CP/M Operating System Manual           5.3  A Sample Copy Program


5.3  A Sample File-to-File Copy Program

     The following program provides a relatively simple example of
file operations.  The program source file is created as COPY.ASM
using the CP/M ED program and then assembled using ASM or MAC,
resulting in a HEX file.  The LOAD program is used to produce a
COPY.COM file that executes directly under the CCP.  The program
begins by setting the stack pointer to a local area and proceeds to
move the second name from the default area at 006CH to a 33-byte
File Control Block called DFCB.  The DFCB is then prepared for file
operations by clearing the current record  field.  At this point,
the source and destination FCBs are ready for processing, because
the SFCB at 005CH is properly set up by the CCP upon entry to the
COPY program.  That is, the first name is placed into the default
FCB, with the proper fields zeroed, including the current record
field at 007CH.  The program continues by opening the source file,
deleting any existing destination file, and creating the destination
file.  If all this is successful, the program loops at the label
COPY until each record is read from the source file and placed into
the destination file.  Upon completion of the data transfer, the
destination file is closed and the program returns to the CCP
command level by jumping to BOOT.
U



                            ;        sample file-to-file copy program
                            ;
                            ;        at the ccp level, the command
                            ;
                            ;             copy a:x.y b:u.v
                            ;
                            ;        copies the file named x.y from drive
                            ;        a to a file named u.v. on drive b.
                            ;
0000 =                      boot     equ 0000h      ;system reboot
0005 =                      bdos     equ 0005h      ;bdos entry point
005c =                      fcbl     equ 005ch      ;first file name
005c =                      sfcb     equ fcbl       ;source fcb
006c =                      fcb2     equ 006ch      ;second file name
0080 =                      dbuff    equ 0080h      ;default buffer
0100 =                      tpa      equ 0100h      ;beginning of tpa
                            ;
0009 =                      printf   equ 9          ;print buffer func#
000f =                      openf    equ 15         ;open file func#
0010 =                      closef   equ 16         ;close file func#
0013 =                      deletef  equ 19         ;delete file func#
0014 =                      readf    equ 20         ;sequential read
0015 =                      writef   equ 21         ;sequential write
0016 =                      makef    equ 22         ;make file func#
                            ;
0100                                 org tpa        ;beginning of tpa
0100 311b02                          lxi sp,stack   ;local stack
                            ;
                            ;        move second file name to dfcb
0103 0e10                            mvi c,16       ;half an fcb


                               5-35





CP/M Operating System Manual           5.3  A Sample Copy Program


0105 116c00                          lxi d,fcb2     ;source of move
0108 21da01                          lxi h,dfcb     ;destination fcb
010b 1a                     mfcb:    Idax d         ;source fcb
010c 13                              inx  d         ;ready next
010d 77                              mov  m,a       ;dest fcb
010e 23                              inx  h         ;ready next
010f 0d                              dcr  c         ;count 16...0
0110 c10b01                          jnz  mfcb      ;loop 16 times
                            ;
                            ;        name has been removed, zero cr
0113 af                              xra  a         ;a = 00h
0114 32fa01                          sta  dfcbcr    ;current rec = 0
                            ;
                            ;        source and destination fcb's ready
                            ;
0117 115c00                          lxi  d,sfcb    ;source file
011a cd6901                          call open      ;error if 255
011d 118701                          lxi  d,nofile  ;ready message
0120 3c                              inr  a         ;255 becomes 0
0121 cc6101                          cz   finis     ;done if no file
                            ;
                            ;        source file open, prep destination
0124 11da01                          lxi  d,dfcb    ;destination
0127 cd7301                          call delete    ;remove if present
                            ;
012a 11da01                          lxi  d,dfcb    ;destination
012d cd8201                          call make      ;create the file
0130 119601                          lxi  d,nodir   ;ready message
0133 3c                              inr  a         ;255 becomes 0
0134 cc6101                          cz   finis     ;done if no dir space
                            ;
                            ;        source file open, dest file open
                            ;        copy until end of file on source
                            ;
0137 115c00                 copy:    lxi  d,sfcb    ;source
013a cd7801                          call read      ;read next record
013d b7                              ora  a         ;end of file?
013e c25101                          jnz  eofile    ;skip write if so
                            ;
                            ;        not end of file, write the record
0141 11da01                          lix  d,dfcb    ;destination
0144 cd7d01                          call write     ;write record
0147 11a901                          lxi  d,space   ;ready message
014a b7                              ora  a         ;00 if write ok
014b c46101                          cnz  finis     ;end if so
014e c33701                          jmp  copy      ;loop until eof
                            ;
                            eofile:  ;end of file, close destination
0151 11da01                          lxi  d,dfcb    ;destination
0154 cd6e01                          call close     ;255 if error
0157 21bb01                          lxi  h,wrprot  ;ready message
015a 3c                              inr  a         ;255 becomes 00
015b cc6101                          cz   finis     ;shouldn't happen
                            ;
                            ;        copy operation complete, end


                               5-36





CP/M Operating System Manual           5.3  A Sample Copy Program


015e 11cc01                          lxi  d,normal  ;ready message
                            ;
                            finis    ;write message given by de, reboot
0161 0e09                            mvi  c,printf
0163 cd0500                          call bdos      ;write message
0166 c30000                          jmp  boot      ;reboot system
                            ;
                            ;        system interface subroutines
                            ;        (all return directly from bdos)
                            ;
0169 0e0f                   open:    mvi  c,openf
016b c30500                          jmp  bdos
                            ;
016e 0e10                   close:   mvi  c,closef
0170 c30500                          jmp  bdos
                            ;
0173 0e13                   delete   mvi  c,deletef
0175 c30500                          jmp  bdos
                            ;
0178 0e14                   read:    mvi  c,readf
017a c30500                          jmp  bdos
                            ;
017d 0e15                   write:   mvi  c,writef
017f c30500                          jmp  bdos
                            ;
0182 0e16                   make:    mvi  c,makef
0184 c30500                          jmp  bdos
                            ;
                            ;        console messages
0187 6e6f20f                nofile:  db   'no source file$'
0196 6e6f209                nodir:   db   'no directory space$'
01a9 6f7574f                space:   db   'out of dat space$'
01bb 7772695                wrprot:  db   'write protected?$'
01cc 636f700                normal:  db   'copy complete$'
                            ;
                            ;        data areas
01da                        dfcb:    ds   33        ;destination fcb
01fa                        dfcbcr   equ  dfcb+32   ;current record
                            ;
01fb                                 ds   32        ;16 level stack
                            stack:
021b                                 end
K



     Note that there are several simplifications in this particular
program.  First, there are no checks for invalid filenames that
could contain ambiguous references.  This situation could be
detected by scanning the 32-byte default area starting at location
005CH for ASCII question marks.  A check should also be make to
ensure that the filenames have been included (check locations 005DH
and 006DH for nonblank ASCII characters).  Finally, a check should
be made to ensure that the source and destination filenames are
different.  An improvement in speed could be obtained by buffering
more data on each read operation.  One could, for example, determine


                               5-37





CP/M Operating System Manual           5.3  A Sample Copy Program


the size of memory by fetching FBASE from location 0006H and using
the entire remaining portion of memory for a data buffer.  In this
case, the programmer simply resets the DMA address to the next
successive 128-byte area before each read.  Upon writing to the
destination file, the DMA address is reset to the beginning of the
buffer and incremented by 128 bytes to the end as each record is
transferred to the destination file.


5.4  A Sample File Dump Utility

     The following file dump program is slightly more complex than
the simple copy program given in the previous section.  The dump
program reads an input file, specified in the CCP command line, and
displays the content of each record in hexadecimal format at the
console.  Note that the dump program saves the CCP's stack upon
entry, resets the stack to a local area, and restores the CCP's
stack before returning directly to the CCP.  Thus, the dump program
does not perform and warm start at the end of processing.
U



x.in 5
                            ;DUMP program reads input file and displays
                            hex data
                            ;
0100                                 org  100h
0005 =                      bdos     equ  0005h =   ;bdos entry point
0001 =                      cons     equ  1         ;read console
0002 =                      typef    equ  2         ;type function
0009 =                      printf   equ  9         ;buffer print entry
000b =                      brkf     equ  11        ;break key function
                                                    ;(true if char
000f =                      openf    equ  15        ;file open
0014 =                      readf    equ  20        ;read function
                            ;
005c =                      fcb      equ  5ch       ;file control block
                                                    ;address
0080 =                      buff     equ  80h       ;input disk buffer
                                                    ;address
                            ;
                            ;        non graphic characters
000d =                      cr       equ  0dh       ;carriage return
000a =                      If       equ  0ah       ;line feed
                            ;
                            ;        file control block definitions
005c =                      fcbdn    equ  fcb+0     ;disk name
005d =                      fcbfn    equ  fcb+1     ;file name
0065 =                      fcbft    equ  fcb+9     ;disk file type (3
                                                    ;characters)
0068 =                      fcbrl    equ  fcb+12    ;file's current reel
                                                    ;number
006b =                      fcbrc    equ  fcb+15    ;file's record count (0 to
                                                    ;128)128)
007c =                      fcbcr'   equ  fcb+32    ;current (next) record


                               5-38





CP/M Operating System Manual      5.4  A Sample File Dump Utility


                                                    ;number (0
007d =                      fcbin    equ  fcb+33    ;fcb length
                            ;
                            ;        set up stack
0100 210000                          lxi  h,0
0103 39                              dad  sp
                            ;        entry stack pointer in hl from the ccp
0104 221502                          shld oldsp
                            ;        set sp to local stack area (restored at
                            ;        finis)
0107 315702                          lxi  sp,stktop
                            ;        read and print successive buffers
010a cdc101                          call setup     ;set up input file
010d feff                            cpi  255       ;255 if file not present
010f c21b01                          jnz  openok    ;skip if open is ok
                            ;
                            ;        file not there, give error message and
                            ;        return
0112 11f301                          lxi  d,opnmsg
0115 cd9c01                          call err
0118 c35101                          jmp finis      ;to return
                            ;
                            openok:  ;open operation ok, set buffer index to
                                     ;end
011b 3e80                            mvi  a,80h
011d 321302                          sta  ibp       ;set buffer pointer to 80h
                            ;        hl contains next address to print
0120 210000                          lxi  h,0       ;start with 0000
                            ;
                            gloop:
0123 e5                              push h         ;save line position
0124 cda201                          call gnb
0127 e1                              pop  h         ;recall line position
0138 da5101                          jc   finis     ;carry set by gnb if end
                                                    ;file
012b 47                              mov  b,a
                            ;        print hex values
                            ;        check for line fold
012c 7d
                                     mov  a,l
012d e60f                            ani  0fh       ;check low 4 bits
012f c24401                          jnz nonum
                            ;        print line number
0132 cd7201                          call crlf
                            ;
                            ;        check for break key
0135 cd5901                          call break
                            ;        accum lsb = 1 if character ready
0138 0f                              rrc            ;into carry
0139 da5101                          jc   finis     ;don't print any more
                            ;
013c 7c                              mov  a,h
013d cd8f01                          call phex
0140 7d                              mov  a,l
0141 cd8f01                          call phex


                               5-39





CP/M Operating System Manual      5.4  A Sample File Dump Utility


                            nonum
0144 23                              inx  h         ;to next line number
0145 3e20                            mvi  a,''
0147 cd6501                          call pchar
014a 78                              mov  a,b
014b cd8f01                          call phex
014e c32301                          jmp  gloop
                            ;
                            finis
                            ;        end of dump, return to cco
                            ;        (note that a jmp to 0000h reboots)
0151 cd7201                          call crif
0154 2a1502                          lhld oldsp
0157 f9                              sphl
                            ;        stack pointer contains ccp's stack
                            ;        location
0158 c9                              ret            ;to the ccp
                            ;
                            ;
                            ;        subroutines
                            ;
                            break:   ;check break key (actually any key will
                                     ;do)
0159 e5d5c5                          push h! push d! push b; environment
                                     ;saved
015c 0e0b                            mvi  c,brkf
015e cd0500                          call bdos
0161 c1d1e1                          pop b! pop d! pop h; environment
                                     restored
0164 c9                              ret
                            ;
                            pchar:   ;print a character
0165 e5d5c5                          push h! push d! push b; saved
0168 0e02                            mvi  c, typef
016a 5f                              mov  e,a
016b cd0500                          call bdos
016e c1d1e1                          pop b! pop d! pop h; restored
0171 c9                              ret
                            ;
                            crlf
0172 3e0d                            mvi  a,cr
0174 cd6501                          call pchar
0177 3e0a                            mvi  a,lf
0179 cd6501                          call pchar
017c c9                              ret
                            ;
                            ;
                            pnib:    ;print nibble in reg a
017d e60f                            ani  ofh       ;low 4 bits
017f fe0a                            cpi  10
0181 d28901                          jnc  p10
                            ;        less than or equal to 9
0184 c630                            adi  '0'
0186 c38b01                          jmp  prn
                            ;


                               5-40





CP/M Operating System Manual      5.4  A Sample File Dump Utility


                            ;        greater or equal to 10
0189 c637                   p10:     adi  'a' - 10
018b cd6501                 prn:     call pchar
018e c9                              ret
                            ;
                            phex     ;print hex char in reg a
018f f5                              pushpsw
0190 0f                              rrc
0191 0f                              rrc
0192 0f                              rrc
0193 0f                              rrc
0194 cd7d01                          call pnib      ;print nibble
0197 f1                              pop  psw
0198 cd7d01                          call pnip
019b c9                              ret
                            ;
                            err:     ;print error message
                            ;        d,e addresses message ending with "$"
019c 0e09                            mvi  c,printf  ;print buffer
                                                    ;function
019e cd0500                          call bdos
01a1 c9                              ret
                            ;
                            ;
                            gnb:     ;get next byte
01a2 3a1302                          lda  ibp
01a5 fe80                            cpi  80h
01a7 c2b301                          jnz  g0
                            ;        read another buffer
                            ;
                            ;
 01aa cdce01                         call diskr
01ad b7                              ora  a         ;zero value if read ok
01ae cab301                          jz   g0        ;for another byte
                            ;        end of data, return with carry set for eof
01b1 37                              stc
01b2 c9                              ret
                            ;
                            g0:      ;read the byte at buff+reg a
01b3 5f                              mov  e,a       ;Is byte of buffer index
01b4 1600                            mvi  d,0       ;double precision
                                                    ;index to de
01b6 3c                              inr  a         ;index=index+1
01b7 321302                          sta  ibp       ;back to memory
                            ;        pointer is incremented
                            ;        save the current file address
01ba 218000                          lxi  h,buff
01bd 19                              dad  d
                            ;        absolute character address is in hl
01be 7e                              mov  a,m
                            ;        byte is in the accumulator
01bf b7                              ora  a         ;reset carry bit
01c0 c9                              ret
                            ;
                            setup:   ;set up file


                               5-41





CP/M Operating System Manual      5.4  A Sample File Dump Utility


                            ;        open the file for input
01c1 af                              xra  a         ;zero to accum
01c2 327c00                          sta  fcbcr     ;clear current record
                            ;
01c5 115c00                          lxi  d,fcb
01c8 0e0f                            mvi  c,openf
01ca cd0500                          call bdos
                            ;        255 in accum if open error
01cd c9                              ret
                            ;
                            diskr:   ;read disk file record
01ce e5d5c5                          push h! push d! push b
01d1 115c00                          lxi  d,fcb
01d4 0e14                            mvi  c,readf
01d6 cd0500                          call bdos
01d9 c1d1e1                          pop b! pop d! pop h
01dc c9                              ret
                            ;
                            ;        fixed message area
01dd 46494c0                signon:  db   'file dump version 2.0$'
01f3 0d0a4e0                opnmsg:  db   cr,lf,'no  input file present on
                                          disk$'

                            ;        variable area
0213                        ibp:     ds   2         ;input buffer pointer
0215                        oldsp:   ds   2         ;entry sp value from ccp
                            ;
                            ;        stack area
0217                        ;        ds   64        ;reserve 32 level stack
                            stktop:
                            ;
0257                                 end
K



5.5  A Sample Random Access Program

     This chapter concludes with an extensive example of random
access operation.  The program listed below performs the simple
function of reading or writing random records upon command from the
terminal.  When a program has been created, assembled, and placed
into a file labeled RANDOM.COM, the CCP level command

        RANDOM X.DAT

starts the test program.  The program looks for a file by the name
X.DAT and, if found, proceeds to prompt the console for input.  If
not found, the file is created before the prompt is given.  Each
prompt takes the form

        next command?

and is followed by operator input, followed by a carriage return.
The input commands take the form



                               5-42





CP/M Operating System Manual   5.5   Sample Random Access Program


        nW  nR  Q

where n is an integer value in the range 0 to 65535, and W, R, and Q
are simple command characters corresponding to random write, random
read, and quit processing, respectively.  If the W command is
issued, the RANDOM program issues the prompt

        type data:

The operator then responds by typing up to 127 characters, followed
by a carriage return.  RANDOM then writes the character string into
the X.DAT file at record n.  If the R command is issued, RANDOM
reads record number n and displays the string value at the console,
If the Q command is issued, the X.DAT file is closed, and the
program returns to the CCP.  In the interest of brevity, the only
error message is

        error, try again.

     The program begins with an initialization section where the
input file is opened or created, followed by a continuous loop at
the label ready where the individual commands are interpreted.  The
DFBC at 005CH and the default buffer at 0080H are used in all disk
operations.  The utility subroutines then follow, which contain the
principal input line processor, called readc.  This particular
program shows the elements of random access processing, and can be
used as the basis for further program development.
U



                            Sample Random Access Program for CP/M 2.0

0100                              org    100h      ;base of tpa
                         ;
0000 =                   reboot   equ    0000h     ;system reboot
0005 =                   bdos     equ    0005h     ;bdos entry point
                         ;
0001 =                   coninp   equ    1         ;console input function
0002 =                   conout   equ    2         ;console output function
0009 =                   pstring  equ    9         ;print string until '$'
000a =                   rstring  equ    10        ;read console buffer
000c =                   version  equ    12        ;return version number
000f =                   openf    equ    15        ;file open function
0010 =                   closef   equ    16        ;close function
0016 =                   makef    equ    22        ;make file function
0021 =                   readr    equ    33        ;read random
0022 =                   writer   equ    34        ;write random
                         ;
005c =                   fcb      equ    005ch     ;default file control
                                                   ;block
007d =                   ranrec   equ    fcb+33    ;random record position
007f =                   ranovf   equ    fcb+35    ;high order (overflow)
                                                   ;byte
0080 =                   buff     equ    0080h     ;buffer address
                         ;


                               5-43





CP/M Operating System Manual   5.5   Sample Random Access Program


000d =                   cr       equ    0dh       ;carriage return
000a =                   lf       equ    0ah       ;line feed
                         ;


                          Load SP, Set-Up File for Random Access

0100 31bc00                       lxi    sp,stack
                         ;
                         ;        version 2.0
0103 0e0c                         mvi    c,version
0105 cd0500                       call   bdos
0108 fe20                         cpi    20h       ;version 2.0 or better?
010a d21600                       jnc    versok
                         ;        bad version, message and go back
010d 111b00                       lxi    d,badver
0110 cdda00                       call   print
0113 c30000                       jmp    reboot
                         ;
                         versok:
                         ;        correct versionm for random access
0116 0e0f                         mvi    c,openf   ;open default fcb
0118 115c00                       lxi    d,fcb
011b cd 0500                      call   bdos
011e 3c                           inr    a         ;err 255 becomes zero
011f c23700                       jnz    ready
                         ;
                         ;        connot open file, so create it
0122 0e16                         mvi    c,makef
0124 115c00                       lxi    d,fcb
0127 cd0500                       call   bdos
012a 3c                           inr    a         ;err 255 becomes zero
012b c23700                       jnz    ready
                         ;
                         ;        cannot create file, directory full
012e 113a00                       lxi    d,nospace
0131 cdda00                       call   print
0134 c30000                       jmp    reboot    ;back to ccp


                          Loop Back to Ready After Each Command

                         ;
                         ready:
                         ;        file is ready for processing
                         ;
0137 cde500                       call   readcom   ;read next command
013a 227d00                       shld   ranrec    ;store input record#
013d 217f00                       lxi    h,ranovf
0140 3600                         mvi    m,0       ;clear high byte if set
0142 fe51                         cpi    'Q'       ;quit?
0144 c25600                       jnz    notq
                         ;
                         ;        quit processing, close file
0147 0e10                         mvi    c,closef


                               5-44





CP/M Operating System Manual   5.5   Sample Random Access Program


0149 115c00                       lxi    d,fcb
014c cd0500                       call   bdos
014f 3c                           inr    a         ;err 255 becomes 0
0150 cab900                       jz     error     ;error message, retry
0153 c30000                       jmp    reboot    ;back to ccp
                         ;


                          End of Quit Command, Process Write

                         notq:
                         ;        not the quit command, random write?
0156 fe57                         cpi    'W'
0158 c28900                       jnz    notw
                         ;
                         ;        this is a random write, fill buffer untill cr
015b 114d00                       lxi    d,datmsg
015e cdda00                       call   print     ;data prompt
0161 0e7f                         mvi    c,127     ;up to 127 characters
0163 218000                       lxi    h,buff    ;destination
                         rloop:   ;read next character to buff
0166 c5                           push   b         ;save counter
0167 e5                           push   h         ;next destination
0168 cdc200                       call   getchr    ;character to a
016b e1                           pop    h         ;restore counter
016c c1                           pop    b         ;restore next to fill
016d fe0d                         cpi    cr        ;end of line?
016f ca7800                       jz     erloop
                         ;        not end, store character
0172 77                           mov    m,a
0173 23                           inx    h         ;next to fill
0174 0d                           dcr    c         ;counter goes down
0175 c26600                       jnz    rloop     ;end of buffer?
                         erloop:
                         ;        end of read loop, store 00
0178 3600                         mvi    m,0
                         ;
                         ;        write the record to selected record number
017a 0e22                         mvi    c,writer
017c 115c00                       lxi    d,fcb
017c cd0500                       call   bdos
0182 b7                           ora    a         ;erro code zero?
0183 c2b900                       jnz    error     ;message if not
0186 c33700                       jmp    ready     ;for another record
                         ;


                          End of Write Command, Process Read

                         notw:
                         ;        not a write command, read record?
0189 fe52                         cpi    'R'
018b c2b900                       jnz    error     ;skip if not
                         ;
                         ;        read random record


                               5-45





CP/M Operating System Manual   5.5   Sample Random Access Program


018e 0e21                         mvi    c,readr
0190 115c00                       lxi    d,fcb
0193 cd0500                       call   bdos
0196 b7                           ora    a         ;return code 00?
0197 c2b900                       jnz    error
                         ;
                         ;        read was successful, write to console
019a cdcf00                       call   crlf      ;new line
019d 0e80                         mvi    c,128     ;max 128 characters
019f 218000                       lxi    h,buff    ;next to get
                         wloop:
01a2 7e                           mov    a,m       ;next character
01a3 23                           inx    h         ;next to get
01a4 e67f                         ani    7fh       ;mask parity
01a6 ca3700                       jz     ready     ;for another command
                                                   ;if 00
01a9 c5                           push   b         ;save counter
01aa e5                           push   h         ;save next to get
01ab fe20                         cpi    ''        ;graphic?
01ad d4c800                       cnc    putchr    ;skip output if not
01b0 e1                           pop    h
01b1 c1                           pop    b
01b2 0d                           dcr    c         ;count=count-1
01b3 c2a200                       jnz    wloop
01b6 c33700                       jmp    ready
































                               5-46





CP/M Operating System Manual   5.5   Sample Random Access Program


                          End of Read Command, All Errors End Up Here

                         ;
                         error:
01b9 115900                       lxi    d,errmsg
01bc cdda00                       call   print
01bf c33700                       jmp    ready
                         ;


                          Utility Subroutines for Console I/O

                         getchr:
                                  ;read next console character to a
01c2 0e01                         mvi    c,coninp
01c4 cd0500                       call   bdos
01c7 c9                           ret
                         ;
                         putchr:
                                  ;write character from a to console
01c8 0e02                         mvi    c,conout
01ca 5f                           mov    e,a       ;character to send
01cb cd0500                       call   bdos      ;send character
01ce c9                           ret
                         ;
                         crlf:
                                  ;send carriage return line feed
01cf 3e0d                         mvi    a,cr      ;carriage return
01d1 cdc800                       call   putchr
01d4 3e0a                         mvi    a,lf      ;line feed
01d6 cdc800                       call   putchr
01d9 c9                           ret
                         ;
                         print:
                                  ;print the buffer addressed by de untill $
01da d5                           push   d
01db cdcf00                       call   crlf
01de d1                           pop    d         ;new line
01df 0e09                         mvi    c,pstring
01e0 cd0500                       call   bdos      ;print the string
01e4 c9                           ret
                         ;
                         readcom:
                                  ;read the next command line to the conbuf
01e5 116b00                       lxi    d,prompt
01e8 cdda00                       call   print     ;command?
01eb 0e0a                         mvi    c,rstring
01ed 117a00                       lxi    d,conbuf
01f0 cd0500                       call   bdos      ;read command line
                         ;        command line is present, scan it
01f3 210000                       lxi    h,0       ;start with 0000
01f6 117c00                       lxi    d,conlin  ;command line
01f9 1a                  readc:   ldax   d         ;next command
                                                   ;character
01fa 13                           inx    d         ;to next command


                               5-47





CP/M Operating System Manual   5.5   Sample Random Access Program


                                                   ;position
01fb b7                           ora    a         ;cannot be end of
                                                   ;command
01fc c8                           rz
                         ;        not zero, numeric?
01fd d630                         sui    '0'
01ff fe0a                         cpi    10        ;carry if numeric
0201 d21300                       jnc    endrd
                         ;        add-in next digit
0204 29                           dad    h         ;*2
0205 4d                           mov    c,l
0206 44                           mov    b,h       ;bc = value * 2
0207 29                           dad    h         ;*4
0208 29                           dad    h         ;*8
0209 09                           dad    b         ;*2 + *8 = *10
020a 85                           add    l         ;*digit
020b 6f                           mov    l,a
020c d2f900                       jnc    readc     ;for another char
020f24                            inr    h         ;overflow
0210 c3f900                       jmp    readc     ;for another char
                         endrd:
                         ;        end of read, restore value in a
0213 c630                         adi    '0'       ;command
0215 fe61                         cpi    'a'       ;translate case?
0217 d8                           rc
                         ;        lower case, mask lower case bits
0218 e65f                         ani    101$1111b
021a c9                           ret
                         ;


                          String Data Area for Console Messages

                         badver:
021b 536f79                       db     'sorry, you need cp/m version 2$'
                         nospace:
023a 4e6f29                       db     'no directory space$'
                         datmsg:
024d 547970                       db     'type data: $'
                         errmsg:
0259 457272                       db     'error, try again.$'
                         prompt:
026b 4e6570                       db     'next command? $'
                         ;


                          Fixed and Variable Data Area

027a 21                  conbuf:  db     conlen     ;length of console buffer
027b                     consiz:  ds     1          ;resulting size after read
027c                     conlin:  ds     32         ;length 32 buffer
0021 =                   conlen   equ    $-consiz
                         ;
029c                              ds     32         ;16 level stack
                         stack:
02bc                              end

                               5-48



K


CP/M Operating System Manual   5.5   Sample Random Access Program



     Major improvements could be made to this particular program to
enhance its operation.  In fact, with some work, this program could
evolve into a simple data base management system.  One could, for
example, assume a standard record size of 128 bytes, consisting to
arbitrary fields within the record.  A program, called GETKEY, could
be developed that first reads a sequential file and extracts a
specific field defined by the operator.  For example, the command

        GETKEY NAMES.DAT LASTNAME 10 20

would cause GETKEY to read the data base file NAMES.DAT and extract
the LAST-NAME field from each record, starting in position 10 and
ending at character 20.  GETKEY builds a table in memory consisting
of each particular LASTNAME field, along with its 16-bit record
number location within the file.  The GETKEY program then sorts this
list and writes a new file, called LASTNAME.KEY, which is an
alphabetical list of LASTNAME fields with their corresponding record
numbers.  This list is called an inverted index in information
retrieval parlance.

     If the programmer were to rename the program shown above as
QUERY and modify it so that it reads a sorted key file into memory,
the command line might appear as

        QUERY NAMES.DAT LASTNAME.KEY

Instead of reading a number, the QUERY program reads an alphanumeric
string that is a particular key to find in the NAMES.DAT data base.
Because the LASTNAME.KEY list is sorted, one can find a particular
entry rapidly by performing a binary search, similar to looking up a
name in the telephone book.  Starting at both ends of the list, one
examines the entry halfway in between and, if not matched, splits
either the upper half or the lower half for the next search.  You
will quickly reach the item you are looking for and find the
corresponding record number.  You should fetch and display this
record at the console, just as was done in the program shown above.

     With some more work, you can allow a fixed grouping size that
differs from the 128-byte record shown above.  This is accomplished
by keeping track of the record number and the byte offset within the
record.  Knowing the group size, you randomly access the record
containing the proper group, offset to the beginning of the group
within the record read sequentially until the group size has been
exhausted.

     Finally, you can improve QUERY considerably by allowing boolean
expressions, which compute the set of records that satisfy several
relationships, such as a LASTNAME between HARDY and LAUREL and an
AGE lower than 45.  Display all the records that fit this
description.  Finally, if your lists are getting too big to fit into
memory, randomly access key files from the disk as well.





                               5-49





CP/M Operating System Manual         5.6  System Function Summary


5.6  System Function Summary

Function        Function                Input                Output
Number          Name

Decimal     Hex

 0           0   System Reset            C = 00H              none
 1           1   Console Input           C = 01H              A = ASCII char
 2           2   Console Output          E = char             none
 3           3   Reader Input                                 A = ASCII char
 4           4   Punch Output            E = char             none
 5           5   List Output             E = char             none
 6           6   Direct Console I/O      C = 06H              A = char or status

                                         E = 0FFH (input) or  (no value)
                                             0FEH (status) or
                                             char (output)
 7           7   Get I/O Byte            none                 A = I/O byte
                                                               Value
 8           8   Set I/O Byte            E = I/O Byte         none
 9           9   Print String            DE = Buffer Address  none
10           A   Read Console Buffer     DE = Buffer          Console
                                                               Characters
                                                               in Buffer
11           B   Get Console Status      none                 A = 00/non zero
12           C   Return Version Number   none                 HL: Version
                                                                 Number
13           D   Reset Disk System       none                   none
14           E   Select Disk             E = Disk Number        none
15           F   Open File               DE = FCB Address       FF if not found
16          10   Close File              DE = FCB Address       FF if not found
17          11   Search For First        DE = FCB Address       A = Directory
                                                                  Code
18          12   Search For Next         none                   A = Directory
                                                                  Code
19          13   Delete File             DE = FCB Address       A = none
20          14   Read Sequential         DE = FCB Address       A = Error Code
21          15   Write Sequential        DE = FCB Address       A = Error Code
22          16   Make File               DE = FCB Address       A = FF if no DIR
                                                                  Space
23          17   Rename File             DE = FCB Address       A = FF in not
                                                                  found
24          18   Return Login Vector     none                   HL = Login
                                                                   Vector*
25          19   Return Current Disk     none                   A = Current Disk
                                                                  Number
26          1A   Set DMA Address         DE = DMA Address       none
27          1B   Get ADDR (ALLOC)        none                   HL = ALLOC
                                                                   Address*
28          1C   Write Protect Disk      none                   none
29          1D   Get Read/only Vector    none                   HL = R/O
                                                                 Vector Value*
30          1E   Set File Attributes     DE = FCB Address       A = none
31          1F   Get ADDR (Disk Parms)   none                   HL = DPB


                               5-50





CP/M Operating System Manual         5.6  System Function Summary


                                                                 Address
32          20   Set/Get User Code       E = 0FFH for Get       User Number
                                         E = 00 to 0FH for Set
33          21   Read Random             DE = FCB Address       A = Error Code
34          22   Write Random            DE = FCB Address       A = Error Code
35          23   Compute File Size       DE = FCB Address       r0, r1, r2
36          24   Set Random Record       DE = FCB Address       r0, r1, r2
37          25   Reset Drive             DE = Drive Vector      A = 0
38          26   Access Drive            not supported
39          27   Free Drive              not supported
40          28   Write Random with Fill  DE = FCB               A = Error Code




*Note that A = L, and B = H upon return.


End of Section 5






































                               5-51








Section 6

CP/M 2 Alteration



6.1  Introduction

     The standard CP/M system assumes operation on an Intel Model
800 microcomputer development system , but is designed so you can
alter a specific set of subroutines that define the hardware
operating environment.

     Although standard CP/M 2 is configured for single-density
floppy disks, field-alteration features allow adaptation to a wide
variety of disk subsystems from single-drive minidisks to high-
capacity, hard disk systems.  To simplify the following adaptation
process, it is assumed that CP/M 2 is first configured for single-
density floppy disks where minimal editing and debugging tools are
available.  If an earlier version of CP/M is available, the
customizing process is eased considerably.  In this latter case, you
might want to review the system generation process and skip to later
sections that discuss system alteration for nonstandard disk
systems.

     To achieve device independence, CP/M is separated into three
distinct modules:

   o BIOS is the Basic I/O System, which is environment dependent.

   o BDOS is the Basic Disk Operating System, which is not dependent
     upon the hardware configuration.

   o CCP is the Console Command Processor, which uses the BDOS.

     Of these modules, only the BIOS is dependent upon the
particular hardware.  You can patch the distribution version of CP/M
to provide a new BIOS that provides a customized interface between
the remaining CP/M modules and the hardware system.  This document
provides a step-by-step procedure for patching a new BIOS into CP/M.

     All disk-dependent portions of CP/M 2 are placed into a BIOS, a
resident disk parameter block, which is either hand coded or
produced automatically using the disk definition macro library
provided with CP/M 2.  The end user need only specify the maximum
number of active disks, the starting and ending sector numbers, the
data allocation size, the maximum extent of the logical disk,
directory size information, and reserved track values.  The macros
use this information to generate the appropriate tables and table
references for use during CP/M 2 operation.  Deblocking information
is provided, which aids in assembly or disassembly of sector sizes
that are multiples of the fundamental 128-byte data unit, and the
system alteration manual includes general purpose subroutines that
use the deblocking information to take advantage of larger sector
sizes.  Use of these subroutines, together with the table-drive data
access algorithms, makes CP/M 2 a universal data management system.


                               6-1




CP/M Operating System Manual                    6.1  Introduction


     File expansion is achieved by providing up to 512 logical file
extents, where each logical extent contains 16K bytes of data.  CP/M
2 is structured, however, so that as much as 128K bytes of data are
addressed by a single physical extent, corresponding to a single
directory entry, maintaining compatibility with previous versions
while taking advantage of directory space.

     If CP/M is being tailored to a computer system for the first
time, the new BIOS requires some simple software development and
testing.  The standard BIOS is listed in Appendix A and can be used
as a model for the customized package.  A skeletal version of the
BIOS given in Appendix B can serve as the basis for a modified BIOS.

     In addition to the BIOS, you must write a simple memory loader,
called GETSYS, which brings the operating system into memory.  To
patch the new BIOS into CP/M, you must write the reverse of GETSYS,
called PUTSYS, which places an altered version of CP/M back onto the
disk.  PUTSYS can be derived from GETSYS by changing the disk read
commands into disk write commands.  Sample skeletal GETSYS and
PUTSYS programs are described in Section 6.4 and listed in Appendix
C.

     To make the CP/M system load automatically, you must also
supply a cold start loader, similar to the one provided with CP/M,
listed in Appendixes A and D.  A skeletal form of a cold start
loader is given in Appendix E, which serves as a model for the
loader.


6.2  First-level System Regeneration

     The procedure to patch the CP/M system is given below.  Address
references in each step are shown with H denoting the hexadecimal
radix, and are given for a 20K CP/M system.  For larger CP/M
systems, a bias is added to each address that is shown with a +b
following it, where b is equal to the memory size-20K.  Values for b
in various standard memory sizes are listed in Table 6-1.


             Table 6-1.  Standard Memory Size Values

          Memory Size                Value

             24K:         b = 24K - 20K =  4K = 1000H

             32K:         b = 32K - 20K = 12K = 3000H

             40K:         b = 40K - 20K = 20K = 5000H

             48K:         b = 48K - 20K = 28K = 7000H

             56K:         b = 56K - 20K = 36K = 9000H

             62K:         b = 62K - 20K = 42K = A800H

             64K:         b = 64K - 20K = 44K = B000H


                               6-2




CP/M Operating System Manual        6.2  First-level Regeneration


     Note that the standard distribution version of CP/M is set for
operation within a 20K CP/M system. Therefore, you must first bring
up the 20K CP/M system, then configure it for actual memory size
(see Section 6.3).

     Follow these steps to patch your CP/M system:


     1) Read Section 6.4 and write a GETSYS program that reads the
        first two tracks of a disk into memory.  The program from
        the disk must be loaded starting at location 3380H.  GETSYS
        is coded to start at location 100H (base of the TPA) as
        shown in Appendix C.

     2) Test the GETSYS program by reading a blank disk into memory,
        and check to see that the data has been read properly and
        that the disk has not been altered in any way by the GETSYS
        program.

     3) Run the GETSYS program using an initialized CP/M disk to see
        if GETSYS loads CP/M starting at 3380H (the operating
        system actually starts 128 bytes later at 3400H).

     4) Read Section 6.4 and write the PUTSYS program.  This writes
        memory starting at 3380H back onto the first two tracks of
        the disk.  The PUTSYS program should be located at 200H, as
        shown in Appendix C.

     5) Test the PUTSYS program using a blank, uninitialized disk by
        writing a portion of memory to the first two tracks; clear
        memory and read it back using GETSYS.  Test PUTSYS
        completely, because this program will be used to alter CP/M
        on disk.

     6) Study Sections 6.5, 6.6, and 6.7 along with the distribution
        version of the BIOS given in Appendix A and write a simple
        version that performs a similar function for the customized
        environment.  Use the program given in Appendix B as a
        model.  Call this new BIOS by name CBIOS (customized BIOS).
        Implement only the primitive disk operations on a single
        drive and simple console input/output functions in this
        phase.

     7) Test CBIOS completely to ensure that it properly performs
        console character I/O and disk reads and writes.  Be
        careful to ensure that no disk write operations occur
        during read operations and check that the proper track and
        sectors are addressed on all reads and writes.  Failure to
        make these checks might cause destruction of the
        initialized CP/M system after it is patched.

     8) Referring to Table 6-3 in Section 6.5, note that the BIOS is
        placed between locations 4A00H and 4FFFH.  Read the CP/M
        system using GETSYS and replace the BIOS segment by the
        CBIOS developed in step 6 and tested in step 7.  This
        replacement is done in memory.


                               6-3




CP/M Operating System Manual        6.2  First-level Regeneration


     9) Use PUTSYS to place the patched memory image of CP/M onto
        the first two tracks of a blank disk for testing.

    10) Use GETSYS to bring the copied memory image from the test
        disk back into memory at 3380H and check to ensure that it
        has loaded back properly (clear memory, if possible, before
        the load).  Upon successful load, branch to the cold start
        code at location 4A00H.  The cold start routine initializes
        page zero, then jumps to the CCP at location 3400H, which
        calls the BDOS, which calls the CBIOS.  The CCP asks the
        CBIOS to read sixteen sectors on track 2, and CP/M types
        A>, the system prompt.

        If difficulties are encountered, use whatever debug
        facilities are available to trace and breakpoint the CBIOS.

    11) Upon completion of step 10, CP/M has prompted the console
        for a command input.  To test the disk write operation,
        type

        SAVE 1 X.COM

        All commands must be followed by a carriage return.  CP/M
        responds with another prompt after several disk accesses:

        A>

        If it does not, debug the disk write functions and retry.

    12) Test the directory command by typing

        DIR

        CP/M responds with

        A:X     COM

    13) Test the erase command by typing

        ERA X.COM

        CP/M responds with the A prompt.  This is now an
        operational system that only requires a bootstrap loader to
        function completely.

    14) Write a bootstrap loader that is similar to GETSYS and place
        it on track 0, sector 1, using PUTSYS (again using the test
        disk, not the distribution disk).  See Sections 6.5 and 6.8
        for more information on the bootstrap operation.

    15) Retest the new test disk with the bootstrap loader installed
        by executing steps 11, 12, and 13.  Upon completion of
        these tests, type a CTRL-C.  The system executes a warm
        start, which reboots the system, and types the A prompt.



                               6-4





CP/M Operating System Manual        6.2  First-level Regeneration


    16) At this point, there is probably a good version of the
        customized CP/M system on the test disk.  Use GETSYS to
        load CP/M from the test disk.  Remove the test disk, place
        the distribution disk, or a legal copy, into the drive, and
        use PUTSYS to replace the distribution version with the
        customized version.  Do not make this replacement if you
        are unsure of the patch because this step destroys the
        system that was obtained from Digital Research.

    17) Load the modified CP/M system and test it by typing

        DIR

        CP/M responds with a list of files that are provided on the
        initialized disk.  The file DDT.COM is the memory image for
        the debugger.  Note that from now on, you must always
        reboot the CP/M system (CTRL-C is sufficient) when the disk
        is removed and replaced by another disk, unless the new
        disk is to be Read-Only.

    18) Load and test the debugger by typing

        DDT

        See Chapter 4 for operating procedures.

    19) Before making further CBIOS modifications, practice using
        the editor (see Chapter 2), and assembler (see Chapter 3).
        Recode and test the GETSYS, PUTSYS, and CBIOS programs
        using ED, ASM, and DDT.  Code and test a COPY program that
        does a sector-to-sector copy from one disk to another to
        obtain back-up copies of the original disk.  Read the CP/M
        Licensing Agreement specifying legal responsibilities when
        copying the CP/M system.  Place the following copyright
        notice:

        Copyright (c), 1983
         Digital Research

        on each copy that is made with the COPY program.

    20) Modify the CBIOS to include the extra functions for punches,
        readers, and sign-on messages, and add the facilities for
        additional disk drives, if desired.  These changes can be
        made with the GETSYS and PUTSYS programs or by referring to
        the regeneration process in Section 6.3.


     You should now have a good copy of the customized CP/M system.
Although the CBIOS portion of CP/M belongs to the user, the modified
version cannot be legally copied.

     It should be noted that the system remains file-compatible with
all other CP/M systems (assuming media compatibility) which allows
transfer of nonproprietary software between CP/M users.


                               6-5





CP/M Operating System Manual  6.3  Second-level System Generation


6.3  Second-level System Generation

     Once the system is running, the next step is to configure CP/M
for the desired memory size.  Usually, a memory image is first
produced with the MOVCPM program (system relocator) and then placed
into a named disk file.  The disk file can then be loaded, examined,
patched, and replaced using the debugger and the system generation
program (refer to Chapter 1).

     The CBIOS and BOOT are modified using ED and assembled using
ASM, producing files called CBIOS.HEX and BOOT.HEX, which contain
the code for CBIOS and BOOT in Intel hex format.

     To get the memory image of CP/M into the TPA configured for the
desired memory size, type the command:

        MOVCPM xx*

where xx is the memory size in decimal K bytes, for example, 32 for
32K.  The response is as follows:

        CONSTRUCTING xxK CP/M VERS 2.0

        READY FOR "SYSGEN" OR

        "SAVE 34 CPMxx.COM"

     An image of CP/M in the TPA is configured for the requested
memory size.  The memory image is at location 0900H through 227FH,
that is, the BOOT is at 0900H, the CCP is at 980H, the BDOS starts
at 1180H, and the BIOS is at 1F80H.  Note that the memory image has
the standard Model 800 BIOS and BOOT on it.  It is now necessary to
save the memory image in a file so that you can patch the CBIOS and
CBOOT into it:

        SAVE 34 CPMxx.COM

     The memory image created by the MOVCPM program is offset by a
negative bias so that it loads into the free area of the TPA, and
thus does not interfere with the operation of CP/M in higher memory.
This memory image can be subsequently loaded under DDT and examined
or changed in preparation for a new generation of the system.  DDT
is loaded with the memory image by typing:

        DDT CPMxx.COM       Loads DDT, then reads the CP/M image.

DDT should respond with the following:

        NEXT PC
        2300 0100
        -                                          The DDT prompt

You can then give the display and disassembly commands to examine
portions of the memory image between 900H and 227FH.  Note, however,
that to find any particular address within the memory image, you


                               6-6





CP/M Operating System Manual  6.3  Second-level System Generation


must apply the negative bias to the CP/M address to find the actual
address.  Track 00, sector 01, is loaded to location 900H (the user
should find the cold start loader at 900H to 97FH); track 00, sector
02, is loaded into 980H (this is the base of the CCP); and so on
through the entire CP/M system load.  In a 20K system, for example,
the CCP resides at the CP/M address 3400H, but is placed into memory
at 980H by the SYSGEN program.  Thus, the negative bias, denoted by
n, satisfies

        3400H + n = 980H, or n =980H - 3400H

Assuming two's complement arithmetic, n = D580H, which can be
checked by

        3400H + D580H = 10980H = 0980H (ignoring high-order
                                       overflow).

     Note that for larger systems, n satisfies

        (3400H+b) + n = 980H, or
        n = 980H - (3400H + b), or
        n = D580H - b

The value of n for common CP/M systems is given below.


           Table 6-2.  Common Values for CP/M Systems

         Memory Size      BIAS b      Negative Offset n

             20K          0000H     D580H - 0000H = D580H
             24K          1000H     D580H - 1000H = C580H
             32K          3000H     D580H - 3000H = A580H
             40K          5000H     D580H - 5000H = 8580H
             48K          7000H     D580H - 7000H = 6580H
             56K          9000H     D580H - 9000H = 4580H
             62K          A800H     D580H - A800H = 2D80H
             64K          B000H     D580H - B000H = 2580H


     If you want to locate the address x within the memory image
loaded under DDT in a 20K system, first type

        Hx,n            Hexadecimal sum and difference

and DDT responds with the value of x+n (sum) and x-n (difference).
The first number printed by DDT is the actual memory address in the
image where the data or code is located.  For example, the following
DDT command:

        H3400,D580

produces 980H as the sum, which is where the CCP is located in the
memory image under DDT.



                               6-7





CP/M Operating System Manual  6.3  Second-level System Generation


     Type the L command to disassemble portions of the BIOS located
at (4A00H+b)-n, which, when one uses the H command, produces an
actual address of 1F80H.  The disassembly command would thus be as
follows:

        L1F80

It is now necessary to patch in the CBOOT and CBIOS routines.  The
BOOT resides at location 0900H in the memory image.  If the actual
load address is n, then to calculate the bias (m), type the command:

        H900,n          Subtract load address from target address.

     The second number typed by DDT in response to the command is
the desired bias (m).  For example, if the BOOT executes at 0080H,
the command

        H900,80

produces

        0980 0880       Sum and difference in hex.

Therefore, the bias m would be 0880H.  To read-in the BOOT, give the
command:

        ICBOOT.HEX      Input file CBOOT.HEX

Then

        Rm              Read CBOOT with a bias of m (=900H-n).

Examine the CBOOT with

        L900

You are now ready to replace the CBIOS by examining the area at
1F80H, where the original version of the CBIOS resides, and then
typing

        ICBIOS.HEX      Ready the hex file for loading.

     Assume that the CBIOS is being integrated into a 20K CP/M
system and thus originates at location 4A00H.  To locate the CBIOS
properly in the memory image under DDT, you must apply the negative
bias n for a 20K system when loading the hex file.  This is
accomplished by typing

        RD580           Read the file with bias D580H.

Upon completion of the read, reexamine the area where the CBIOS has
been loaded (use an L1F80 command) to ensure that it is properly
loaded.  When you are satisfied that the change has been made,
return from DDT using a CTRL-C or, G0 command.



                               6-8





CP/M Operating System Manual  6.3  Second-level System Generation


     SYSGEN is used to replace the patched memory image back onto a
disk (you use a test disk until sure of the patch) as shown in the
following interaction:


        SYSGEN                    Start the SYSGEN program.

        SYSGEN VERSION 2.0        Sign-on message from SYSGEN.

        SOURCE DRIVE NAME         Respond with a carriage return
        (OR RETURN TO SKIP)       to skip the CP/M read operation
                                  because the system is already
                                  in memory.

        DESTINATION DRIVE NAME    Respond with B to write the new
        (OR RETURN TO REBOOT)     system to the disk in drive B.


        DESTINATION ON B,         Place a scratch disk in drive
        THEN TYPE RETURN          B, then press RETURN.

        FUNCTION COMPLETE
        DESTINATION DRIVE NAME
        (OR RETURN TO REBOOT)


     Place the scratch disk in drive A, then perform a cold start to
bring up the newly-configured CP/M system.

     The new CP/M system is then tested and the Digital Research
copyright notice is placed on the disk, as specified in the
Licensing Agreement:

        Copyright (c), 1979
         Digital Research


6.4  Sample GETSYS and PUTSYS Programs

     The following program provides a framework for the GETSYS and
PUTSYS programs referenced in Sections 6.1 and 6.2.  To read and
write the specific sectors, you must insert the READSEC and WRITESEC
subroutines.














                               6-9





CP/M Operating System Manual        6.4  Sample GETSYS and PUTSYS


;  GETSYS PROGRAM -- READ TRACKS 0 AND 1 TO MEMORY AT 3380H
;  REGISTER                    USE

;         A               (SCRATCH REGISTER)

;         B               TRACK COUNT (0, 1)

;         C               SECTOR COUNT (1,2,...,26)

;         DE              (SCRATCH REGISTER PAIR)

;         HL              LOAD ADDRESS

;         SP              SET TO STACK ADDRESS

;
START:    LXI  SP,3380H   ;SET STACK POINTER TO SCRATCH
                          ;AREA
          LXI  H,3380H    ;SET BASE LOAD ADDRESS
          MVI  B,0        ;START WITH TRACK 0
RDTRK:                    ;READ NEXT TRACK (INITIALLY 0)
          MVI  C,1        ;READ STARTING WITH SECTOR 1

RDSEC:                    ;READ NEXT SECTOR
          CALL READSEC    ;USER-SUPPLIED SUBROUTINE
          LXI  D,128      ;MOVE LOAD ADDRESS TO NEXT 1/2
                          ;PAGE
          DAD  D          ;HL = HL + 128
          INR  C          ;SECTOR = SECTOR + 1
          MOV  A,C        ;CHECK FOR END OF TRACK
          CPI  27
          JC   RDSEC      ;CARRY GENERATED IF SECTOR <27

;
;  ARRIVE HERE AT END OF TRACK, MOVE TO NEXT TRACK
          INR  B
          MOV  A,B        ;TEST FOR LAST TRACK
          CPI  2
          JC   RDTRK      ;CARRY GENERATED IF TRACK <2

;
;  USER-SUPPLIED SUBROUTINE TO READ THE DISK
READSEC:
;  ENTER WITH TRACK NUMBER IN REGISTER B,
          SECTOR NUMBER IN REGISTER C, AND

;         ADDRESS TO FILL IN HL

;
          PUSH B          ;SAVE B AND C REGISTERS
          PUSH H          ;SAVE HL REGISTERS


                  Listing 6-1.  GETSYS Program



                               6-10





CP/M Operating System Manual        6.4  Sample GETSYS and PUTSYS


          .................................................
          perform disk read at this point, branch to
          label START if an error occurs
          .................................................
          POP H           ;RECOVER HL
          POP B           ;RECOVER B AND C REGISTERS
          RET             ;BACK TO MAIN PROGRAM

          END START


                    Listing 6-1.  (continued)



     This program is assembled and listed in Appendix B for
reference purposes, with an assumed origin of 100H.  The hexadecimal
operation codes that are listed on the left might be useful if the
program has to be entered through the panel switches.

     The PUTSYS program can be constructed from GETSYS by changing
only a few operations in the GETSYS program given above, as shown in
Appendix C.  The register pair HL becomes the dump address, next
address to write, and operations on these registers do not change
within the program.  The READSEC subroutine is replaced by a
WRITESEC subroutine, which performs the opposite function; data from
address HL is written to the track given by register B and sector
given by register C.  It is often useful to combine GETSYS and
PUTSYS into a single program during the test and development phase,
as shown in Appendix C.


6.5  Disk Organization

     The sector allocation for the standard distribution version of
CP/M is given here for reference purposes.  The first sector
contains an optional software boot section (see the table on the
following page.   Disk controllers are often set up to bring track
0, sector 1, into memory at a specific location, often location
0000H.  The program in this sector, called BOOT, has the
responsibility of bringing the remaining sectors into memory
starting at location 3400H+b.  If the controller does not have a
built-in sector load, the program in track 0, sector 1 can be
ignored.  In this case, load the program from track 0, sector 2, to
location 3400H+b.

     As an example, the Intel Model 800 hardware cold start loader
brings track 0, sector 1, into absolute address 3000H.  Upon loading
this sector, control transfers to location 3000H, where the
bootstrap operation commences by loading the remainder of track 0
and all of track 1 into memory, starting at 3400H+b.  Note that this
bootstrap loader is of little use in a non-microcomputer development
system environment, although it is useful to examine it because some
of the boot actions will have to be duplicated in the user's cold
start loader.


                               6-11





CP/M Operating System Manual               6.5  Disk Organization


             Table 6-3.  CP/M Disk Sector Allocation

Track #    Sector   Page#   Memory Address    CP/M Module name

  00         01             (boot address)    Cold Start Loader
  00         02      00        3400H+b               CCP
  '          03      '         3480H+b                '
  '          04      01        3500H+b                '
  '          05      '         3580H+b                '
  '          06      02        3600H+b                '
  '          07      '         3680H+b                '
  '          08      03        3700H+b                '
  '          09      '         3780H+b                '
  '          10      04        3800H+b                '
  '          11      '         3880H+b                '
  '          12      05        3900H+b                '
  '          13      '         3980H+b                '
  '          14      06        3A00H+b                '
  '          15      '         3A80H+b                '
  '          16      07        3B00H+b                '
  00         17      '         3B80H+b               CCP
  00         18      08        3C00H+b              BDOS
  '          19      '         3C80H+b                '
  '          20      09        3D00H+b                '
  '          21      '         3D80H+b                '
  '          22      10        3E00H+b                '
  '          23      '         3E80H+b                '
  '          24      11        3F00H+b                '
  '          25      '         3F80H+b                '
  '          26      12        4000H+b                '
  01         01      '         4080H+b                '
  '          02      13        4100H+b                '
  '          03      '         4180H+B                '
  '          04      14        4200H+b                '
  '          05      '         4280H+b                '
  '          06      15        4300H+b                '
  '          07      '         4380H+b                '
  '          08      16        4400H+b                '
  '          09      '         4480H+b                '
  '          10      17        4500H+b                '
  '          11      '         4580H+b                '
  '          12      18        4600H+b                '
  '          13      '         4680H+b                '
  '          14      19        4700H+b                '
  '          15      '         4780H+b                '
  '          16      20        4800H+b                '
  '          17      '         4880H+b                '
  '          18      21        4900H+b                '
  01         19      '         4900H+b              BDOS
  07         20      22        4A00H+b              BIOS
  '          21      '         4A80H+b                '
  '          22      23        4B00H+b                '
  '          23      '         4B80H+b                '
  '          24      24        4C00H+b                '
  01         25      '         4C80H+b              BIOS
  01         26      25        4D00H+b              BIOS
02-76      01-26                            (directory and data)

                               6-12




CP/M Operating System Manual               6.6  BIOS Entry Points


6.6  The BIOS Entry Points

     The entry points into the BIOS from the cold start loader and
BDOS are detailed below.  Entry to the BIOS is through a jump vector
located at 4A00H+b, as shown below.  See Appendixes A and B.  The
jump vector is a sequence of 17 jump instructions that send program
control to the individual BIOS subroutines.  The BIOS subroutines
might be empty for certain functions (they might contain a single
RET operation) during reconfiguration of CP/M, but the entries must
be present in the jump vector.

     The jump vector at 4A00H+b takes the form shown below, where
the individual jump addresses are given to the left:


     4A00H+b      JMP BOOT       ;ARRIVE HERE FROM COLD
                                  START LOAD

     4A03H+b      JMP WBOOT      ;ARRIVE HERE FOR WARM START

     4A06H+b      JMP CONST      ;CHECK FOR CONSOLE CHAR
                                  READY

     4A09H+b      JMP CONIN      ;READ CONSOLE CHARACTER IN

     4A0CH+b      JMP CONOUT     ;WRITE CONSOLE CHARACTER
                                  OUT

     4A0FH+b      JMP LIST       ;WRITE LISTING CHARACTER OUT

     4A12H+b      JMP PUNCH      ;WRITE CHARACTER TO PUNCH
                                  DEVICE

     4A15H+b      JMP READER     ;READ READER DEVICE

     4A18H+b      JMP HOME       ;MOVE TO TRACK 00 ON
                                  SELECTED DISK

     4A1BH+b      JMP SELDSK     ;SELECT DISK DRIVE

     4A1EH+b      JMP SETTRK     ;SET TRACK NUMBER

     4A21H+b      JMP SETSEC     ;SET SECTOR NUMBER

     4A24H+b      JMP SETDMA     ;SET DMA ADDRESS

     4A27H+b      JMP READ       ;READ SELECTED SECTOR

     4A2AH+b      JMP WRITE      ;WRITE SELECTED SECTOR

     4A2DH+b      JMP LISTST     ;RETURN LIST STATUS

     4A30H+b      JMP SECTRAN    ;SECTOR TRANSLATE
                                  SUBROUTINE


                 Listing 6-2.  BIOS Entry Points

                               6-13




CP/M Operating System Manual               6.6  BIOS Entry Points


     Each jump address corresponds to a particular subroutine that
performs the specific function, as outlined below.  There are three
major divisions in the jump table:  the system reinitialization,
which results from calls on BOOT and WBOOT; simple character I/O,
performed by calls on CONST, CONIN, CONOUT, LIST, PUNCH, READER, and
LISTST; and disk I/O, performed by calls on HOME, SELDSK, SETTRK,
SETSEC, SETDMA, READ, WRITE, and SECTRAN.

     All simple character I/O operations are assumed to be performed
in ASCII, upper- and lower-case, with high-order (parity bit) set to
zero.  An end-of-file condition for an input device is given by an
ASCII CTRL-Z (1AH).  Peripheral devices are seen by CP/M as logical
devices and are assigned to physical devices within the BIOS.

     To operate, the BDOS needs only the CONST, CONIN, and CONOUT
subroutines.  LIST, PUNCH, and READER can be used by PIP, but not
the BDOS.  Further, the LISTST entry is currently used only by
DESPOOL, the print spooling utility.  Thus, the initial version of
CBIOS can have empty subroutines for the remaining ASCII devices.

     The following list describes the characteristics of each
device.


   o CONSOLE is the principal interactive console that communicates
     with the operator and it is accessed through CONST, CONIN, and
     CONOUT.  Typically, the CONSOLE is a device such as a CRT or
     teletype.

   o LIST is the principal listing device.  If it exists on the
     user's system, it is usually a hard-copy device, such as a
     printer or teletype.

   o PUNCH is the principal tape punching device.  If it exists, it
     is normally a high-speed paper tape punch or teletype.

   o READER is the principal tape reading device, such as a simple
     optical reader or teletype.


     A single peripheral can be assigned as the LIST, PUNCH, and
READER device simultaneously.  If no peripheral device is assigned
as the LIST, PUNCH, or READER device, the CBIOS gives an appropriate
error message so that the system does not hang if the device is
accessed by PIP or some other user program.  Alternately, the PUNCH
and LIST routines can just simply return, and the READER routine can
return with a 1AH (CTRL-Z) in register A to indicate immediate end-
of-file.

     For added flexibility, you can optionally implement the IOBYTE
function, which allows reassignment of physical devices.  The IOBYTE
function creates a mapping of logical-to-physical devices that can
be altered during CP/M processing, see the STAT command in Section
1.6.1.




                               6-14




CP/M Operating System Manual               6.6  BIOS Entry Points

     The definition of the IOBYTE function corresponds to the Intel
standard as follows:  a single location in memory, currently
location 0003H, is maintained, called IOBYTE, which defines the
logical-to-physical device mapping that is in effect at a particular
time.  The mapping is performed by splitting the IOBYTE into four
distinct fields of two bits each, called the CONSOLE, READER, PUNCH,
and LIST fields, as shown in the following figure.


                      most significant      least significant

    IOBYTE AT 003H    LIST       PUNCH      READER     CONSOLE

                      bits 6,7  bits 4,5  bits 2,3   bits 0,1


                   Figure 6-1.  IOBYTE Fields



     The value in each field can be in the range 0-3, defining the
assigned source or destination of each logical device.  Table 6-4
gives the values that can be assigned to each field.


                 Table 6-4. IOBYTE Field Values

        Value                   Meaning

                    CONSOLE field (bits 0,1)

         0     console is assigned to the console printer
               device (TTY:)
         1     console is assigned to the CRT device (CRT:)
         2     batch mode:  use the READER as the CONSOLE input,
               and the LIST device as the CONSOLE output (BAT:)
         3     user-defined console device (UC1:)

                     READER field (bits 2,3)

         0     READER is the teletype device (TTY:)
         1     READER is the high speed reader device (PTR:)
         2     user-defined reader #1 (UR1:)
         3     user-defined reader #2 (UR2:)

                     PUNCH field (bits 4,5)

         0     PUNCH is the teletype device (TTY:)
         1     PUNCH is the high speed punch device (PTP:)
         2     user-defined punch #1 (UP1:)
         3     user-defined punch #2 (UP2:)

                      LIST field (bits 6,7)

         0     LIST is the teletype device (TTY:)
         1     LIST is the CRT device (CRT:)
         2     LIST is the line printer device (LPT:)
         3     user-defined list device (UL1:)

                               6-15




CP/M Operating System Manual               6.6  BIOS Entry Points


     The implementation of the IOBYTE is optional and effects only
the organization of the CBIOS.  No CP/M systems use the IOBYTE
(although they tolerate the existence of the IOBYTE at location
0003H) except for PIP, which allows access to the physical devices,
and STAT, which allows logical-physical assignments to be make or
displayed.  For more information see Section 1.  In any case the
IOBYTE implementation should be omitted until the basic CBIOS is
fully implemented and tested; then you should add the IOBYTE to
increase the facilities.

     Disk I/O is always performed through a sequence of calls on the
various disk access subroutines that set up the disk number to
access, the track and sector on a particular disk, and the Direct
Memory Access (DMA) address involved in the I/O operation.  After
all these parameters have been set up, a call is made to the READ or
WRITE function to perform the actual I/O operation.

     There is often a single call to SELDSK to select a disk drive,
followed by a number of read or write operations to the selected
disk before selecting another drive for subsequent operations.
Similarly, there might be a single call to set the DMA address,
followed by several calls that read or write from the selected DMA
address before the DMA address is changed.  The track and sector
subroutines are always called before the READ or WRITE operations
are performed.

     The READ and WRITE routines should perform several retries (10
is standard) before reporting the error condition to the BDOS.  If
the error condition is returned to the BDOS, it reports the error to
the user.  The HOME subroutine might or might not actually perform
the track 00 seek, depending upon controller characteristics; the
important point is that track 00 has been selected for the next
operation and is often treated in exactly the same manner as SETTRK
with a parameter of 00.

     The following table describes the exact responsibilities of
each BIOS entry point subroutine.


                  Table 6-5.  BIOS Entry Points

   Entry Point                    Function

F
      BOOT     The BOOT entry point gets control from the cold
               start loader and is responsible for basic
               system initialization, including sending a
               sign-on message, which can be omitted in the
               first version.  If the IOBYTE function is
               implemented, it must be set at this point.  The
               various system parameters that are set by the
               WBOOT entry point must be initialized, and
               control is transferred to the CCP at 3400+b for
               further processing.  Note that register C must
               be set to zero to select drive A.



                               6-16





CP/M Operating System Manual               6.6  BIOS Entry Points


                     Table 6-5.  (continued)

   Entry Point                    Function

      WBOOT    The WBOOT entry point gets control when a warm
               start occurs.  A warm start is performed
               whenever a user program branches to location
               0000H, or when the CPU is reset from the front
               panel.  The CP/M system must be loaded from the
               first two tracks of drive A up to, but not
               including, the BIOS, or CBIOS, if the user has
               completed the patch.  System parameters must be
               initialized as follows:

               location 0,1,2   Set to JMP WBOOT for warm
                                starts (000H: JMP 4A03H+b)

               location 3       Set initial value of IOBYTE,
                                if implemented in the CBIOS

               location 4       High nibble = current user no;
                                low nibble = current drive

               location 5,6,7   Set to JMP BDOS, which is the
                                primary entry point to CP/M
                                for transient programs.
                                (0005H: JMP 3C06H+b)

               Refer to Section 6.9 for complete details of
               page zero use.  Upon completion of the
               initialization, the WBOOT program must branch
               to the CCP at 3400H+b to restart the system.
               Upon entry to the CCP, register C is set to the
               drive to select after system initialization.
               The WBOOT routine should read location 4 in
               memory, verify that is a legal drive, and pass
               it to the CCP in register C.

      CONST    You should sample the status of the currently
               assigned console device and return 0FFH in
               register A if a character is ready to read and
               00H in register A if no console characters are
               ready.

      CONIN    The next console character is read into
               register A, and the parity bit is set, high-
               order bit, to zero.  If no console character is
               ready, wait until a character is typed before
               returning.








                               6-17





CP/M Operating System Manual               6.6  BIOS Entry Points


                     Table 6-5.  (continued)

   Entry Point                    Function

      CONOUT   The character is sent from register C to the
               console output device.  The character is in
               ASCII, with high-order parity bit set to zero.
               You might want to include a time-out on a line-
               feed or carriage return, if the console device
               requires some time interval at the end of the
               line (such as a TI Silent 700 terminal).  You
               can filter out control characters that cause
               the console device to react in a strange way
               (CTRL-Z causes the Lear-Seigler terminal to
               clear the screen, for example).

      LIST     The character is sent from register C to the
               currently assigned listing device.  The
               character is in ASCII with zero parity bit.

      PUNCH    The character is sent from register C to the
               currently assigned punch device.  The character
               is in ASCII with zero parity.

      READER   The next character is read from the currently
               assigned reader device into register A with
               zero parity (high-order bit must be zero); an
               end-of-file condition is reported by returning
               an ASCII CTRL-Z(1AH).

      HOME     The disk head of the currently selected disk
               (initially disk A) is moved to the track 00
               position.  If the controller allows access to
               the track 0 flag from the drive, the head is
               stepped until the track 0 flag is detected.  If
               the controller does not support this feature,
               the HOME call is translated into a call to
               SETTRK with a parameter of 0.

      SELDSK   The disk drive given by register C is selected
               for further operations, where register C
               contains 0 for drive A, 1 for drive B, and so
               on up to 15 for drive P (the standard CP/M
               distribution version supports four drives).  On
               each disk select, SELDSK must return in HL the
               base address of a 16-byte area, called the Disk
               Parameter Header, described in Section 6.10.
               For standard floppy disk drives, the contents
               of the header and associated tables do not
               change; thus, the program segment included in
               the sample CBIOS performs this operation
               automatically.





                               6-18





CP/M Operating System Manual               6.6  BIOS Entry Points


                     Table 6-5.  (continued)

   Entry Point                    Function

               If there is an attempt to select a nonexistent
               drive, SELDSK returns HL=0000H as an error
               indicator.  Although SELDSK must return the
               header address on each call, it is advisable to
               postpone the physical disk select operation
               until an I/O function (seek, read, or write) is
               actually performed, because disk selects often
               occur without utimately performing any disk
               I/O, and many controllers unload the head of
               the current disk before selecting the new
               drive.  This causes an excessive amount of
               noise and disk wear.  The least significant bit
               of register E is zero if this is the first
               occurrence of the drive select since the last
               cold or warm start.

      SETTRK   Register BC contains the track number for
               subsequent disk accesses on the currently
               selected drive.  The sector number in BC is the
               same as the number returned from the SECTRAN
               entry point.  You can choose to seek the
               selected track at this time or delay the seek
               until the next read or write actually occurs.
               Register BC can take on values in the range 0-
               76 corresponding to valid track numbers for
               standard floppy disk drives and 0-65535 for
               nonstandard disk subsystems.

      SETSEC   Register BC contains the sector number, 1
               through 26, for subsequent disk accesses on the
               currently selected drive.  The sector number in
               BC is the same as the number returned from the
               SECTRAN entry point.  You can choose to send
               this information to the controller at this
               point or delay sector selection until a read or
               write operation occurs.

      SETDMA   Register BC contains the DMA (Disk Memory
               Access) address for subsequent read or write
               operations.  For example, if B = 00H and C =
               80H when SETDMA is called, all subsequent read
               operations read their data into 80H through
               0FFH and all subsequent write operations get
               their data from 80H through 0FFH, until the
               next call to SETDMA occurs.  The initial DMA
               address is assumed to be 80H.  The controller
               need not actually support Direct Memory Access.
               If, for example, all data transfers are through
               I/O ports, the CBIOS that is constructed uses
               the 128-byte area starting at the selected DMA
               address for the memory buffer during the
               subsequent read or write operations.


                               6-19




CP/M Operating System Manual               6.6  BIOS Entry Points


                     Table 6-5.  (continued)

   Entry Point                    Function

      READ     Assuming the drive has been selected, the track
               has been set, and the DMA address has been
               specified, the READ subroutine attempts to read
               one sector based upon these parameters and
               returns the following error codes in register
               A:

               0  no errors occurred

               1  nonrecoverable error condition occurred

               Currently, CP/M responds only to a zero or
               nonzero value as the return code.  That is, if
               the value in register A is 0, CP/M assumes that
               the disk operation was completed properly.  IF
               an error occurs the CBIOS should attempt at
               least 10 retries to see if the error is
               recoverable.  When an error is reported the
               BDOS prints the message BDOS ERR ONx:  BAD
               SECTOR.  The operator then has the option of
               pressing a carriage return to ignore the error,
               or CTRL-C to abort.

      WRITE    Data is written from the currently selected DMA
               address to the currently selected drive, track,
               and sector.  For floppy disks, the data should
               be marked as nondeleted data to maintain
               compatibility with other CP/M systems.  The
               error codes given in the READ command are
               returned in register A, with error recovery
               attempts as described above.

      LISTST   You return the ready status of the list device
               used by the DESPOOL program to improve console
               response during its operation.  The value 00 is
               returned in A if the list device is not ready
               to accept a character and 0FFH if a character
               can be sent to the printer.  A 00 value should
               be returned if LIST status is not implemented.














                               6-20





CP/M Operating System Manual               6.6  BIOS Entry Points


                     Table 6-5.  (continued)

   Entry Point                    Function

      SECTRAN  Logical-to-physical sector translation is
               performed to improve the overall response of
               CP/M.  Standard CP/M systems are shipped with a
               skew factor of 6, where six physical sectors
               are skipped between each logical read
               operation.  This skew factor allows enough time
               between sectors for most programs to load their
               buffers without missing the next sector.  In
               particular computer systems that use fast
               processors, memory, and disk subsystems, the
               skew factor might be changed to improve overall
               response.  However, the user should maintain a
               single-density IBM-compatible version of CP/M
               for information transfer into and out of the
               computer system, using a skew factor of 6.

               In general, SECTRAN receives a logical sector
               number relative to zero in BC and a translate
               table address in DE.  The sector number is used
               as an index into the translate table, with the
               resulting physical sector number in HL.  For
               standard systems, the table and indexing code
               is provided in the CBIOS and need not be
               changed.
K


6.7  A Sample BIOS

     The program shown in Appendix B can serve as a basis for your
first BIOS.  The simplest functions are assumed in this BIOS, so
that you can enter it through a front panel, if absolutely
necessary.  You must alter and insert code into the subroutines for
CONST, CONIN, CONOUT, READ, WRITE, and WAITIO subroutines.  Storage
is reserved for user-supplied code in these regions.  The scratch
area reserved in page zero (see Section 6.9) for the BIOS is used in
this program, so that it could be implemented in ROM, if desired.

     Once operational, this skeletal version can be enhanced to
print the initial sign-on message and perform better error recovery.
The subroutines for LIST, PUNCH, and READER can be filled out and
the IOBYTE function can be implemented.


6.8  A Sample Cold Start Loader

     The program shown in Appendix E can serve as a basis for a cold
start loader.  The disk read function must be supplied by the user,
and the program must be loaded somehow starting at location 0000.
Space is reserved for the patch code so that the total amount of
storage required for the cold start loader is 128 bytes.



                               6-21





CP/M Operating System Manual      6.8  A Sample Cold Start Loader


     Eventually, you might want to get this loader onto the first
disk sector (track 0, sector 1) and cause the controller to load it
into memory automatically upon system start up.  Alternatively, the
cold start loader can be placed into ROM, and above the CP/M system.
In this case, it is necessary to originate the program at a higher
address and key in a jump instruction at system start up that
branches to the loader.  Subsequent warm starts do not require this
key-in operation, because the entry point WBOOT gets control, thus
bringing the system in from disk automatically.  The skeletal cold
start loader has minimal error recovery, which might be enhanced in
later versions.


6.9  Reserved Locations in Page Zero

     Main memory page zero, between locations 00H and 0FFH, contains
several segments of code and data that are used during CP/M
processing.  The code and data areas are given in the following
table.


           Table 6-6.  Reserved Locations in Page Zero

     Locations                       Contents

F
     000H-0002H       Contains a jump instruction to the warm
                      start entry location 4A03H+b.  This
                      allows a simple programmed restart (JMP
                      0000H) or manual restart from the front
                      panel.

     0003H-0003H      Contains the Intel standard IOBYTE is
                      optionally included in the user's CBIOS
                      (refer to Section 6.6).

     0004H-0004H      Current default drive number
                      (0=A,...,15=P).

     0005H-0007H      Contains a jump instruction to the BDOS
                      and serves two purposes:  JMP 0005H
                      provides the primary entry point to the
                      BDOS, as described in Chapter 5, and
                      LHLD 0006H brings the address field of
                      the instruction to the HL register
                      pair.  This value is the lowest address
                      in memory used by CP/M, assuming the
                      CCP is being overlaid.  The DDT program
                      changes the address field to reflect
                      the reduced memory size in debug mode.

     0008H-0027H      Interrupt locations 1 through 5 not
                      used.

     0030H-0037H      Interrupt location 6 (not currently
                      used) is reserved.


                               6-22





CP/M Operating System Manual 6.9  Reserved Locations in Page Zero


                     Table 6-6.  (continued)

     Locations                       Contents

     0038H-003AH      Restart 7; contains a jump instruction
                      into the DDT or SID program when
                      running in debug mode for programmed
                      breakpoints, but is not otherwise used
                      by CP/M.

     003BH-003FH      Not currently used; reserved.

     0040H-004FH      A 16-byte area reserved for scratch by
                      CBIOS, but is not used for any purpose
                      in the distribution version of CP/M.

     0050H-005BH      Not currently used; reserved.

     005CH-007CH      Default File Control Block produced for
                      a transient program by the CCP.

     007DH-007FH      Optional default random record position.

     0080H-00FFH      Default 128-byte disk buffer, also
                      filled with the command line when a
                      transient is loaded under the CCP.
K


     This information is set up for normal operation under the CP/M
system, but can be overwritten by a transient program if the BDOS
facilities are not required by the transient.

     If, for example, a particular program performs only simple I/O
and must begin execution at location 0, it can first be loaded into
the TPA, using normal CP/M facilities, with a small memory move
program that gets control when loaded.  The memory move program must
get control from location 0100H, which is the assumed beginning of
all transient programs.  The move program can then proceed to the
entire memory image down to location 0 and pass control to the
starting address of the memory load.

     If the BIOS is overwritten or if location 0, containing the
warm start entry point, is overwritten, the operator must bring the
CP/M system back into memory with a cold start sequence.


6.10  Disk Parameter Tables

     Tables are included in the BIOS that describe the particular
characteristics of the disk subsystem used with CP/M.  These tables
can be either hand-coded, as shown in the sample CBIOS in Appendix
B, or automatically generated using the DISKDEF macro library, as
shown in Appendix F.  The purpose here is to describe the elements
of these tables.




                               6-23




CP/M Operating System Manual          6.10  Disk Parameter Tables



     In general, each disk drive has an associated (16-byte) disk
parameter header that contains information about the disk drive and
provides a scratch pad area for certain BDOS operations.  The format
of the disk parameter header for each drive is shown in Figure 6-2,
where each element is a word (16-bit) value.



XLT     0000     0000     0000     DIRBUF     DPB     CSV     ALV
16b     16b      16b      16b      16b        16b     16b     16b


            Figure 6-2.  Disk Parameter Header Format



     The meaning of each Disk Parameter Header (DPH) element is
detailed in Table 6-7.


               Table 6-7.  Disk Parameter Headers

  Disk Parameter                 Meaning
      Header
F

      XLT           Address of the logical-to-physical
                    translation vector, if used for this
                    particular drive, or the value 0000H if no
                    sector translation takes place (that is,
                    the physical and logical sector numbers
                    are the same).  Disk drives with identical
                    sector skew factors share the same
                    translate tables.

      0000          Scratch pad values for use within the
                    BDOS, initial value is unimportant.

      DIRBUF        Address of a 128-byte scratch pad area for
                    directory operations within BDOS.  All
                    DPHs address the same scratch pad area.

      DPB           Address of a disk parameter block for this
                    drive.  Drives with identical disk
                    characteristics address the same disk
                    parameter block.

      CSV           Address of a scratch pad area used for
                    software check for changed disks.  This
                    address is different for each DPH.

      ALV           Address of a scratch pad area used by the
                    BDOS to keep disk storage allocation
                    information.  This address is different
                    for each DPH.


                               6-24



K


CP/M Operating System Manual          6.10  Disk Parameter Tables



     Given n disk drives, the DPHs are arranged in a table whose
first row of 16 bytes corresponds to drive 0, with the last row
corresponding to drive n-1.  In the following figure the lable
DPBASE defines the base address of the DPH table.



   DPBASE:

      00  XLT 00  0000  0000  0000  DIRBUF DBP 00 CSV 00 ALV 00

      01  XLT 01  0000  0000  0000  DIRBUF DBP 01 CSV 01 ALV 01
                                    .
                                    .
                                    .
     n-1  XLTn-1  0000  0000  0000  DIRBUF DBTn-1 CSVn-1 ALVn-1


            Figure 6-3.  Disk Parameter Header Table



     A responsibility of the SELDSK subroutine is to return the base
address of the DPH for the selected drive.  The following sequence
of operations returns the table address, with a 0000H returned if
the selected drive does not exist.


        NDISKS      EQU     4         ;NUMBER OF DISK DRIVES
        .....
        SELDSK:     ;SELECT DISK GIVEN BY BC
                    LSI     H,0000H   ;ERROR CODE
                    MOV     A,C       ;DRIVE OK?
                    CPI     NDISKS    ;CY IF SO
                    RNC               ;RET IF ERROR
                    ;NO ERROR, CONTINUE
                    MOV     L,C       ;LOW(DISK)
                    MOV     H,B       ;HIGH(DISK)
                    DAD     H         ;*2
                    DAD     H         ;*4
                    DAD     H         ;*8
                    DAD     H         ;*16
                    LXI     D,DPBASE;FIRST DPH
                    DAD     D         ;DPH(DISK)
                    RET


     The translation vectors, XLT 00 through XLTn-1, are located
elsewhere in the BIOS, and simply correspond one-for-one with the
logical sector numbers zero through the sector count 1.  The Disk
Parameter Block (DPB) for each drive is more complex.  As shown in
Figure 6-4, particular DPB, that is addressed by one or more DPHs,
takes the general form:



                               6-25





CP/M Operating System Manual          6.10  Disk Parameter Tables


    SPT   BSH   BLM   EXM   DSM   DRM   AL0   AL1   CKS   0FF
    16b   8b    8b    8b    16b   16b   8b    8b    16b   16b


            Figure 6-4.  Disk Parameter Block Format



where each is a byte or word value, as shown by the 8b or 16b
indicator below the field.

     The following field abbreviations are used in Figure 6-4:


   o SPT is the total number of sectors per track.

   o BSH is the data allocation block shift factor, determined by
     the data block allocation size.

   o BLM is the data allocation block mask (2[BSH-1]).

   o EXM is the extent mask, determined by the data block allocation
     size and the number of disk blocks.

   o DSM determines the total storage capacity of the disk drive.

   o DRM determines the total number of directory entries that can
     be stored on this drive.  AL0, AL1 determine reserved directory
     blocks.

   o CKS is the size of the directory check vector.

   o 0FF is the number of reserved tracks at the beginning of the
     (logical) disk.

The values of BSH and BLM determine the data allocation size BLS,
which is not an entry in the DPB.  Given that the designer has
selected a value for BLS, the values of BSH and BLM are shown Table
6-8.


                 Table 6-8.  BSH and BLM Values

                    BLS         BSH         BLM

                    1024         3            7
                    2048         4           15
                    4096         5           31
                    8192         6           63
                  16,384         7          127


where all values are in decimal.  The value of EXM depends upon both
the BLS and whether the DSM value is less than 256 or greater than
255, as shown in Table 6-9.


                               6-26





CP/M Operating System Manual          6.10  Disk Parameter Tables


                     Table 6-9.  EXM Values

                    BLS             EXM values

                              DSM<256    DSM>255

                    1024         0         N/A
                    2048         1          0
                    4096         3          1
                    8192         7          3
                  16,384        15          7


     The value of DSM is the maximum data block number supported by
this particular drive, measured in BLS units.  The product (DSM+1)
is the total number of bytes held by the drive and must be within
the capacity of the physical disk, not counting the reserved
operating system tracks.

     The DRM entry is the one less than the total number of
directory entries that can take on a 16-bit value.  The values of
AL0 and AL1, however, are determined by DRM.  The values AL0 and AL1
can together be considered a string of 16-bits, as shown in Figure
6-5.



                AL0                            AL1

 00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15


                    Figure 6-5.  AL0 and AL1



     Position 00 corresponds to the high-order bit of the byte
labeled AL0 and 15 corresponds to the low-order bit of the byte
labeled AL1.  Each bit position reserves a data block for number of
directory entries, thus allowing a total of 16 data blocks to be
assigned for directory entries (bits are assigned starting at 00 and
filled to the right until position 15).  Each directory entry
occupies 32 bytes, resulting in the following tabulation:


                  Table 6-10.   BLS Tabulation

                   BLS         Directory Entries

                    1024         32 times # bits
                    2048         64 times # bits
                    4096        128 times # bits
                    8192        256 times # bits
                  16,384        512 times # bits



                               6-27





CP/M Operating System Manual          6.10  Disk Parameter Tables



     Thus, if DRM = 127 (128 directory entries) and BLS = 1024,
there are 32 directory entries per block, requiring 4 reserved
blocks.  In this case, the 4 high-order bits of AL0 are set,
resulting in the values AL0 = 0F0H and AL1 = 00H.

     The CKS value is determined as follows:  if the disk drive
media is removable, then CKS = (DRM+1)/4, where DRM is the last
directory entry number.  If the media are fixed, then set CKS = 0
(no directory records are checked in this case).

     Finally, the 0FF field determines the number of tracks that are
skipped at the beginning of the physical disk.  This value is
automatically added whenever SETTRK is called and can be used as a
mechanism for skipping reserved operating system tracks or for
partitioning a large disk into smaller segmented sections.

     To complete the discussion of the DPB, several DPHs can address
the same DPB if their drive characteristics are identical.  Further,
the DPB can be dynamically changed when a new drive is addressed by
simply changing the pointer in the DPH; because the BDOS copies the
DPB values to a local area whenever the SELDSK function is invoked.

     Returning back to DPH for a particular drive, the two address
values CSV and ALV remain.  Both addresses reference an area of
uninitialized memory following the BIOS.  The areas must be unique
for each drive, and the size of each area is determined by the
values in the DPB.

     The size of the area addressed by CSV is CKS bytes, which is
sufficient to hold the directory check information for this
particular drive,  If CKS = (DRM+1)/4, you must reserve (DRM+1)/4
bytes for directory check use.  If CKS = 0, no storage is reserved.

     The size of the area addressed by ALV is determined by the
maximum number of data blocks allowed for this particular disk and
is computed as (DSM/8)+1.

     The CBIOS shown in Appendix B demonstrates an instance of these
tables for standard 8-inch, single-density drives.  It might be
useful to examine this program and compare the tabular values with
the definitions given above.


6.11  The DISKDEF Macro Library

     A macro library called DISKDEF (shown in Appendix F), greatly
simplifies the table construction process.  You must have access to
the MAC macro assembler, of course, to use the DISKDEF facility,
while the macro library is included with all CP.M 2 distribution
disks.






                               6-28





CP/M Operating System Manual      6.11  The DISKDEF Macro Library



     A BIOS disk definition consists of the following sequence of
macro statements:

        MACLIB         DISKDEF
        .....
        DISKS          n
        DISKDEF        0,...
        DISKDEF        1,...
        .....
        DISKDEF        n-1
        .....
        ENDEF

where the MACLIB statement loads the DISKDEF.LIB file, on the same
disk as the BIOS, into MAC's internal tables.  The DISKS macro call
follows, which specifies the number of drives to be configured  with
the user's system, where n is an integer in the range 1 to 16.  A
series of DISKDEF macro calls then follow that define the
characteristics of each logical disk, 0 through n-1, corresponding
to logical drives A through P.  The DISKS and DISKDEF macros
generate the in-line fixed data tables described in the previous
section and thus must be placed in a nonexecutable portion of the
BIOS, typically directly following the BIOS jump vector.

     The remaining portion of the BIOS is defined following the
DISKDEF macros, with the ENDEF macro call immediately preceding the
END statement.  The ENDEF (End of Diskdef) macro generates the
necessary uninitialized RAM areas that are located in memory above
the BIOS.

     The DISKDEF macro call takes the form:

        DISKDEF  dn,fsc,lsc,[skf],bls dks,dir,cks,ofs,[0]

where

   o dn is the logical disk number, 0 to n-1.
   o fsc is the first physical sector number (0 or 1).
   o lsc is the last sector number.
   o skf is the optional sector skew factor.
   o bls is the data allocation block size.
   o dks is the number of blocks on the disk.
   o dir is the number of directory entries.
   o cks is the number of checked directory entries.
   o ofs is the track offset to logical track 00.
   o [0] is an optional 1.4 compatibility flag.


     The value dn is the drive number being defined with this
DISKDEF macro invocation.  The fsc parameter accounts for differing
sector numbering systems and is usually 0 to 1.  The lsc is the last
numbered sector on a track.  When present, the skf parameter defines
the sector skew factor, which is used to create a sector translation
table according to the skew.


                               6-29





CP/M Operating System Manual      6.11  The DISKDEF Macro Library



     If the number of sectors is less than 256, a single-byte table
is created, otherwise each translation table element occupies two
bytes.  No translation table is created if the skf parameter is
omitted, or equal to 0.

     The bls parameter specifies the number of bytes allocated to
each data block, and takes on the values 1024, 2048, 4096, 8192, or
16384.  Generally, performance increases with larger data block
sizes because there are fewer directory references, and logically
connected data records are physically close on the disk.  Further,
each directory entry addresses more data and the BIOS-resident RAM
space is reduced.

     The dks parameter specifies the total disk size in bls units.
That is, if the bls = 2048 and dks = 1000, the total disk capacity
is 2,048,000 bytes.  If dks is greater than 255, the block size
parameter bls must be greater than 1024.  The value of dir is the
total number of directory entries that might exceed 255, if desired.

     The cks parameter determines the number of directory items to
check on each directory scan and is used internally to detect
changed disks during system operation, where an intervening cold or
warm start has not occurred.  When this situation is detected, CP/M
automatically marks the disk Read-Only so that data is not
subsequently destroyed.

     As stated in the previous section, the value of cks = dir when
the medium is easily changed, as is the case with a floppy disk
subsystem.  If the disk is permanently mounted, the value of cks is
typically 0, because the probability of changing disks without a
restart is low.

     The ofs value determines the number of tracks to skip when this
particular drive is addressed, which can be used to reserve
additional operating system space or to simulate several logical
drives on a single large capacity physical drive.  Finally, the [0]
parameter is included when file compatibility is required with
versions of 1.4 that have been modified for higher density disks.
This parameter ensures that only 16K is allocated for each directory
record, as was the case for previous versions.  Normally, this
parameter is not included.

     For convenience and economy of table space, the special form:

        DISKDEF      i,j

gives disk i the same characteristics as a previously defined drive
j.  A standard four-drive, single-density system, which is
compatible with version 1.4, is defined using the following macro
invocations:

        DISKS        4
        DISKDEF      0,1,26,6,1024,243,64,2
        DISKDEF      1,0


                               6-30





CP/M Operating System Manual      6.11  The DISKDEF Macro Library


        DISKDEF      2,0
        DISKDEF      3,0
        ....
        ENDEF

with all disks having the same parameter values of 26 sectors per
track, numbered 1 through 26, with 6 sectors skipped between each
access, 1024 bytes per data block, 243 data blocks for a total of
243K-byte disk capacity, 64 checked directory entries, and two
operating system tracks.

     The DISKS macro generates n DPHs, starting at the DPH table
address DPBASE generated by the macro.  Each disk header block
contains sixteen bytes, as described above, and correspond one-for-
one to each of the defined drives.  In the four-drive standard
system, for example, the DISKS macro generates a table of the form:

     DPBASE     EQU$
     DPE0:      DW XLT0,0000H,0000H,0000H,DIRBUF,DPB0,CSV0,ALV0
     DPE1:      DW XLT0,0000H,0000H,0000H,DIRBUF,DPB0,CSV1,ALV1
     DPE2:      DW XLT0,0000H,0000H,0000H,DIRBUF,DPB0,CSV2,ALV2
     DPE3:      DW XLT0,0000H,0000H,0000H,DIRBUF,DPB0,CSV3,ALV3

where the DPH labels are included for reference purposes to show the
beginning table addresses for each drive 0 through 3.  The values
contained within the DPH are described in detail in the previous
section.  The check and allocation vector addresses are generated by
the ENDEF macro in the ram area following the BIOS code and tables.

     Note that if the skf (skew factor) parameter is omitted, or
equal to 0, the translation table is omitted and a 0000H value is
inserted in the XLT position of the DPH for the disk.  In a
subsequent call to perform the logical-to-physical translation,
SECTRAN receives a translation table address of DE = 0000H and
simply returns the original logical sector from BC in the HL
register pair.

     A translate table is constructed when the skf parameter is
present, and the (nonzero) table address is placed into the
corresponding DPHs.  The following for example, is constructed when
the standard skew factor skf = 6 is specified in the DISKDEF macro
call:

        XLT0:    DB    1,7,13,19,25,5,11,17,23,3,9,15,21
                 DB    2,8,14,20,26,6,12,18,24,4,10,16,22

     Following the ENDEF macro call, a number of uninitialized data
areas are defined.  These data areas need not be a part of the BIOS
that is loaded upon cold start, but must be available between the
BIOS and the end of memory.  The size of the uninitialized RAM area
is determined by EQU statements generated by the ENDEF macro.  For a
standard four-drive system, the ENDEF macro might produce the
following EQU statement:




                               6-31





CP/M Operating System Manual      6.11  The DISKDEF Macro Library


        4C72 =        BEGDAT EQU $
                      (data areas)

        4DB0 =        ENDDAT EQU $

        013C =        DATSIZ EQU $-BEGDAT

which indicates that uninitialized RAM begins at location 4C72H,
ends at 4DB0H-1, and occupies 013CH bytes.  You must ensure that
these addresses are free for use after the system is loaded.

     After modification, you can use the STAT program to check drive
characteristics, because STAT uses the disk parameter block to
decode the drive information.  A STAT command of the form:

        STAT d:DSK:

decodes the disk parameter block for drive d (d=A,...,P) and
displays the following values:


        r:  128-byte record capacity
        k:  kilobyte drive capacity
        d:  32-byte directory entries
        c:  checked directory entries
        e:  records/extent
        b:  records/block
        s:  sectors/track
        t:  reserved tracks


     Three examples of DISKDEF macro invocations are shown below
with corresponding STAT parameter values.  The last example produces
a full 8-megabyte system.

                   DISKDEF 0,1,58,,2048,256,128,128,2
        r=4096,    k=512, d=128, c=128, e=256, b=16, s=58, t=2

                   DISKDEF 0,1,58,,2048,1024,300,0,2
        r=16348,   k=2048, d=300, c=0, e=128, b=16, s=58, t=2

                   DISKDEF 0,1,58,,16348,512,128,128,2
        r=65536,   k=8192, d=128, c=128, e=1024, b=128, s=58, t=2


6.12  Sector Blocking and Deblocking

     Upon each call to BIOS WRITE entry point, the CP/M BDOS
includes information that allows effective sector blocking and
deblocking where the host disk subsystem has a sector size that is a
multiple of the basic 128-byte unit.  The purpose here is to present
a general-purpose algorithm that can be included within the BIOS and
that uses the BDOS information to perform the operations
automatically.



                               6-32





CP/M Operating System Manual        6.12  Blocking and Deblocking


     On each call to WRITE, the BDOS provides the following
information in register C:

        0   =   (normal sector write)
        1   =   (write to directory sector)
        2   =   (write to the first sector
                of a new data block)

     Condition 0 occurs whenever the next write operation is into a
previously written area, such as a random mode record update; when
the write is to other than the first sector of an unallocated block;
or when the write is not into the directory area.  Condition 1
occurs when a write into the directory area is performed.  Condition
2 occurs when the first record (only) of a newly allocated data
block is written.  In most cases, application programs read or write
multiple 128-byte sectors in sequence; thus, there is little
overhead involved in either operation when blocking and deblocking
records, because preread operations can be avoided when writing
records.

     Appendix G lists the blocking and deblocking algorithms in
skeletal form; this file is included on your CP/M disk.  Generally,
the algorithms map all CP/M sector read operations onto the host
disk through an intermediate buffer that is the size of the host
disk sector.  Throughout the program, values and variables that
relate to the CP/M sector involved in a seek operation are prefixed
by sek, while those related to the host disk system are prefixed by
hst.  The equate statements beginning on line 29 of Appendix G
define the mapping between CP/M and the host system, and must be
changed if other than the sample host system is involved.

     The entry points BOOT and WBOOT must contain the initialization
code starting on line 57, while the SELDSK entry point must be
augmented by the code starting on line 65.  Note that although the
SELDSK entry point computes and returns the Disk Parameter Header
address, it does not physically select the host disk at this point
(it is selected later at READHST or WRITEHST).  Further, SETTRK,
SETTRK, and SETMA simply store the values, but do not take any other
action at this point.  SECTRAN performs a trivial function of
returning the physical sector number.

     The principal entry points are READ and WRITE, starting on
lines 110 and 125, respectively.  These subroutines take the place
of your previous READ and WRITE operations.

     The actual physical read or write takes place at either
WRITEHST or READHST, where all values have been prepared:  hstdsk is
the host disk number, hsttrk is the host track number, and hstsec is
the host sector number, which may require translation to physical
sector number.  You must insert code at this point that performs the
full sector read or write into or out of the buffer at hstbuf of
length hstsiz.  All other mapping functions are performed by the
algorithms.




                               6-33





CP/M Operating System Manual        6.12  Blocking and Deblocking


     This particular algorithm was tested using an 80-megabyte hard
disk unit that was originally configured for 128-byte sectors,
producing approximately 35 megabytes of formatted storage.  When
configured for 512-byte host sectors, usable storage increased to 57
megabytes, with a corresponding 400% improvement in overall
response.  In this situation, there is no apparent overhead involved
in deblocking sectors, with the advantage that user programs still
maintain 128-byte sectors.  This is primarily because of the
information provided by the BDOS, which eliminates the necessity for
preread operations.


End of Section 6












































                               6-34


