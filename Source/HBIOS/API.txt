==========================
HBIOS Management Functions
==========================

GET ($05):
  BC=Function/Subfunction			A=Result

  Subfunctions:

    CIOCNT ($00):
      BC=Function/Subfunction			A=Result
						E=Serial Unit Count

    DIOCNT ($10):
      BC=Function/Subfunction			A=Result
						E=Disk Unit Count

    BIOSVER ($F0):
      BC=Function/Subfunction			A=Result
						DE=BIOS Version
						L=Platform

SET ($06):
  BC=Function/Subfunction			A=Result





================
Serial Functions
================

IN ($00):
  BC=Function/Unit			A=Result
					E=Byte Input

  Wait for a single character to be available at the specified device and return the character in E. Function
  will wait indefinitely for a character to be available.

OUT ($01):
  BC=Function/Unit			A=Result
  E=Character to Output

  Wait for device/unit to be ready to send a character, then send the character specified in E.

IST ($02):
  BC=Function/Unit			A=Result
					*E=# Bytes Pending

OST ($03):
  BC=Function/Unit			A=Result
					*E=# Buffer Bytes Available

INIT ($04):
  BC=Function/Unit			A=Result
  DE=Line Characteristics

QUERY ($05)
  BC=Function/Unit			A=Result
					DE=Line Characteristics

DEVICE ($06):
  BC=Function/Unit			A=Result
					D=Device Type
					E=Physical Unit

==============
Disk Functions
==============

STATUS ($10):
  BC=Function/Unit			A=Result

  Return current status result code of specified unit.  Does not clear
  the status.

RESET ($11):
  BC=Function/Unit			A=Result
  
  Reset the physical interface associated with the specified unit.  Flag all units
  associated with the interface for unit initialization at next I/O call.  Clear
  media identified unless locked.  Reset result code of all associated units.

SEEK ($12):
  BC=Function/Unit			A=Result
  D:7=Address Type (0=CHS, 1=LBA)
  CHS: D:0-6=Head,E=Sector,HL=Track
  LBA: DE:HL

  Update target CHS or LBA for next I/O request on designated unit.
  Physical seek is typically deferred until subsequent I/O operation.

READ ($13) / WRITE ($14) / VERIFY ($15):
  BC=Function/Unit			A=Result
  HL=Buffer Address
  E=Block Count

  Read, write, or verify sectors starting at current target sector.  Current
  target sector is incremented on each successful operation.  On error,
  target sector is sector where error occurred.

FORMAT ($16):
  BC=Function/Unit			A=Result
  CHS: D=Head, HL=Cylinder
  E=Fill Byte

  Format the designated track using the current media_id.  Many devices
  do not support a true format operation.  If so, format should write
  sectors with designated fill byte.

  *** Need to specify interleave/sector id's somehow.

DEVICE ($17)
  BC=Function/Unit			A=Result
					D=Device Type
					E=Physical Unit

  Report the device type (Floppy, IDE, SD, etc.) and physical unit number.  Call
  does not perform any I/O and succeeds even if the device is in an error state.
  It does not reset the unit status.

MEDIA ($18):
  BC=Function/Unit			A=Result
  E0:=Enable Media Discovery		E=Media ID (legacy)

  Report the media definition for media in specified unit.  If bit 0 of E is
  set, then perform media discovery or verification.  If no media in device,
  return no media error.

DEFMED ($19):
  BC=Function/Unit			A=Result
					E=Media ID (legacy)

  Define media in unit.

CAPACITY ($1A):
  BC=Function/Unit			DE:HL=Blocks on Device
					BC=Block Size
					A=Result

  Return device capacity information.
  If media is unknown, return error (no media)

GEOMETRY ($1B):
  BC=Function/Unit			HL=Cylinders
					D:0-6=Heads
					D:7=LBA Capable
					E=Sectors
					BC=Block Size
					A=Result

  Return device geometry information.
  If media is unknown, return error (no media)

INFO ($1F):
    BC=Function/Sub-function		A=Result

  C=0: Report total unit count in system:
    BC=Function/Sub-function		A=Result
					B=Count



A: RAM0		B: ROM0		C:



Unit 	Device	Board	Part	Slice	Cap
-------	-------	-------	-------	-------	-------
#0	RAM	MK4			384K
#1	ROM	MK4			384K
#2	FD0	DIO3			3.5" DS/HD
#3	IDE0	DIO3		0	8M



Unit 0: RAMDISK on MK4 (384K)
Unit 1: ROMDISK on MK4 (384K)
Unit 2: FD0 on DISKIO3 (3.5")
Unit 3: FD1 on DISKIO3 (5.25")
Unit 4: IDE0 on DISKIO3 (4096M)

A: RAM0		MK4 RAM Disk, 384K
B: ROM0		MK4 ROM Disk, 384K
C: FD0		DiskIO3 Floppy Disk 0, 3.5" DS/HD
D: FD1		DiskIO3 Floppy Disk 1, 5.25" DS/DD
E: IDE0:0	MK4 IDE Hard Disk 0, Slice 0, 8M
F: IDE0:1	MK4 IDE Hard Disk 0, Slice 1, 8M
G: PRPSD0:0	PropIO SD Card, Slice 0






0: RAM-  RAMdrive on the Z180 SBC Mark IV board
LBASupported    UserAddressableSectors 832

1: ROM-  ROMdrive on the Z180 SBC Mark IV board
LBASupported    UserAddressableSectors 768

2: IDE-  SanDisk SDCFHSNJC-004G
s/n:       DMZ031215013440   fmw:  HDX 7.08
CHS: 7751:16:63     nSectors 7813008     MaxBlkTransfer 1
LBASupported    UserAddressableSectors 7813120

3: IDE-  SanDisk SDCFHSNJC-004G
s/n:       BKZ031215015432   fmw:  HDX 7.08
CHS: 7751:16:63     nSectors 7813008     MaxBlkTransfer 1
LBASupported    UserAddressableSectors 7813120

4:  SD-  SD  SU02G
s/n:           139401536   fmw:  8.0   d/c:  2013-07
LBASupported    UserAddressableSectors 1931264

Boot UNA unit number or ROM? [R,X,0..4] (R):

N8VEM UNA CP/M (Will Sowerbutts, 2014-08-01 git cbed09)

Unit Disk  Driver   Capacity  Slices   Start LBA  Flags
0    RAM0  Memory    416.0KB       1  0x00000000  (formatted)
1    ROM0  Memory    384.0KB       1  0x00000000
2    IDE0  Dual-IDE    3.7GB     469  0x00000000  MBR FGN
3    IDE1  Dual-IDE    3.7GB     469  0x00000000  MBR FGN
4    SD0   CSIO-SD   943.0MB       0  0x00000000  MBR FGN

Drive A: assigned to RAM0 slice 0
Drive B: assigned to ROM0 slice 0
Drive C: assigned to IDE0 slice 0
Drive D: assigned to IDE1 slice 0

Loading Residual CP/M at 0xE100 ... done.
CP/M 2.2 Copyright 1979 (c) by Digital Research

---

<VDA>_INIT:
  - ADD OURSELVES TO VDA_TBL
  - ADD OURSELVES TO CIO_TBL & RECORD <VDA>_CIOUNIT
  - INIT HARDWARE
  - GOTO <VDA>_INI

<VDA>_INI:
  - CALL <VDA>_RES
  - INITIALIZE EMULATION BY CALLING EMU_INIT (PASS IN C=EMU_TYPE & DE=VDA_DISPATCH ADDRESS)
    - EMU_INIT RETURNS ADDRESS OF CIO DISPATCHER ADDRESS FOR SUBSEQUENT FORWARDING
  - RECORD EMULATORS CIO DISPATCHER ADDRESS IN <VDA>_CIODISPATCH

<VDA>_RES:
  - RESET HARDWARE

EMU_INIT:
  - CALL <EMU>_INIT BASED ON VALUE IN C

<EMU>_INIT:
  - RECORD DE IN VDA_DISPADR
  - INITIALIZE/RESET EMULATION ENGINE
  - RETURN EMULATOR CIO DISPATCH ADDRESS IN DE





-------------------------- 
md
hdsk
rf
ide
sd
ppide
fd
prp
ppp
