;
;==================================================================================================
;   HDSK DISK DRIVER
;==================================================================================================
;
HDSK_UNITCNT	.EQU	2	; TWO VIRTUAL HARD DISKS
;
; IO PORT ADDRESSES
;
HDSK_IO		.EQU	$FD
;
HDSK_CMDNONE	.EQU	0
HDSK_CMDRESET	.EQU	1
HDSK_CMDREAD	.EQU	2
HDSK_CMDWRITE	.EQU	3
HDSK_CMDPARAM	.EQU	4
;
; STATUS
;
HDSKRC_OK	.EQU	0
;
;
;
HDSK_INIT:
	CALL	NEWLINE			; FORMATTING
	PRTS("HDSK: UNITS=$")
	LD	A,HDSK_UNITCNT
	CALL	PRTDECB
;
; SETUP THE DISPATCH TABLE ENTRIES
;
	LD	B,HDSK_UNITCNT	; LOOP CONTROL
	LD	C,0		; PHYSICAL UNIT INDEX
HDSK_INIT0:
	PUSH	BC		; SAVE LOOP CONTROL
	LD	B,C		; PHYSICAL UNIT
	LD	C,DIODEV_HDSK	; DEVICE TYPE
	LD	DE,0		; UNIT DATA BLOB ADDRESS
	CALL	DIO_ADDENT	; ADD ENTRY, BC IS NOT DESTROYED
	POP	BC		; RESTORE LOOP CONTROL
	INC	C		; NEXT PHYSICAL UNIT
	DJNZ	HDSK_INIT0	; LOOP UNTIL DONE
;
	XOR	A
	DEC	A		; INITIAL STATUS IS NOT READY $FF
	LD	(HDSK_STAT),A	; SAVE IT
	XOR	A		; INIT SUCCEEDED
	RET			; RETURN
;
;
;
HDSK_DISPATCH:
	; SAVE THE TARGET DEVICE/UNIT LOCALLY IN DRIVER
	LD	A,C		; DEVICE/UNIT FROM C
	AND	$0F		; ISOLATE UNIT NUM
	CP	2		; CHECK FOR MAX UNIT EXCEEDED
	LD	(HDSK_UNIT),A	; SAVE IT
	CALL	NC,PANIC	; PANIC IF TOO HIGH
;
	; DISPATCH ACCORDING TO DISK SUB-FUNCTION
	LD	A,B		; GET REQUESTED FUNCTION
	AND	$0F		; ISOLATE SUB-FUNCTION
	JP	Z,HDSK_STATUS	; SUB-FUNC 0: STATUS
	DEC	A
	JP	Z,HDSK_RESET	; SUB-FUNC 1: RESET
	DEC	A
	JP	Z,HDSK_SEEK	; SUB-FUNC 2: SEEK
	DEC	A
	JP	Z,HDSK_READ	; SUB-FUNC 3: READ SECTORS
	DEC	A
	JP	Z,HDSK_WRITE	; SUB-FUNC 4: WRITE SECTORS
	DEC	A
	JP	Z,HDSK_VERIFY	; SUB-FUNC 5: VERIFY SECTORS
	DEC	A
	JP	Z,HDSK_FORMAT	; SUB-FUNC 6: FORMAT TRACK
	DEC	A
	JP	Z,HDSK_DEVICE	; SUB-FUNC 7: DEVICE REPORT
	DEC	A
	JP	Z,HDSK_MEDIA	; SUB-FUNC 8: MEDIA REPORT
	DEC	A
	JP	Z,HDSK_DEFMED	; SUB-FUNC 9: DEFINE MEDIA
	DEC	A
	JP	Z,HDSK_CAP	; SUB-FUNC 10: REPORT CAPACITY
	DEC	A
	JP	Z,HDSK_GEOM	; SUB-FUNC 11: REPORT GEOMETRY
;
HDSK_VERIFY:
HDSK_FORMAT:
HDSK_DEFMED:
	CALL	PANIC		; INVALID SUB-FUNCTION
;
;
;
HDSK_STATUS:
	LD	A,(HDSK_STAT)	; LOAD STATUS
	OR	A		; SET FLAGS
	RET
;
;
;
HDSK_RESET:
	JP	HDSK_DSKRESET
;
; GET DISK CAPACITY
;   RETURN DE:HL=BLOCK COUNT, BC=BLOCK SIZE
;   SLICE C/H/S = 65/16/16 OR 16,640 TOTAL SECTORS
;   ASSUME 8 SLICES, SO 16640 X 8 = 133,120 TOTAL SECTORS
;
HDSK_CAP:
	LD	DE,133120 >> 16		; BLOCK COUNT MSW
	LD	HL,133120 & $FFFF	; BLOCK COUNT LSW
	LD	BC,512			; 512 BYTE SECTOR
	XOR	A			; SIGNAL SUCCESS
	RET
;
;
;
HDSK_GEOM:
	; FOR LBA, WE SIMULATE CHS ACCESS USING 16 HEADS AND 16 SECTORS
	; RETURN HS:CC -> DE:HL, SET HIGH BIT OF D TO INDICATE LBA CAPABLE
	CALL	HDSK_CAP		; GET TOTAL BLOCKS IN DE:HL, BLOCK SIZE TO BC
	LD	L,H			; DIVIDE BY 256 FOR # TRACKS
	LD	H,E			; ... HIGH BYTE DISCARDED, RESULT IN HL
	LD	D,$80 | 16		; HEADS / CYL = 16, SET LBA BIT
	LD	E,16			; SECTORS / TRACK = 16
	XOR	A			; SIGNAL SUCCESS
	RET
;
;
;
HDSK_DEVICE:
	LD	D,DIODEV_HDSK	; D := DEVICE TYPE
	LD	E,C		; E := PHYSICAL UNIT
	LD	C,%00000000	; C := ATTRIBUTES, NON-REMOVABLE HARD DISK
	XOR	A		; SIGNAL SUCCESS
	RET
;
;
;
HDSK_MEDIA:
	LD	E,MID_HD		; HARD DISK MEDIA
	LD	D,0			; D:0=0 MEANS NO MEDIA CHANGE
	XOR	A			; SIGNAL SUCCESS
	RET
;
;
;
HDSK_SEEK:
	BIT	7,D			; CHECK FOR LBA FLAG
	CALL	Z,HB_CHS2LBA		; CLEAR MEANS CHS, CONVERT TO LBA
	RES	7,D			; CLEAR FLAG REGARDLESS (DOES NO HARM IF ALREADY LBA)
	LD	BC,HSTLBA		; POINT TO LBA STORAGE
	CALL	ST32			; SAVE LBA ADDRESS
	XOR	A			; SIGNAL SUCCESS
	RET				; AND RETURN
;
;
;
HDSK_READ:
	LD	A,HDSK_CMDREAD
	JR	HDSK_RW
;
;
;
HDSK_WRITE:
	LD	A,HDSK_CMDWRITE
	JR	HDSK_RW
;
;
;
HDSK_RW:
	LD	(HDSK_CMD),A		; SET COMMAND BYTE
	LD	(HDSK_DMA),HL		; SAVE INITIAL DMA
	LD	A,E			; SECTOR COUNT TO A
	OR	A			; SET FLAGS
	RET	Z			; ZERO SECTOR I/O, RETURN W/ E=0 & A=0
	LD	B,A			; INIT SECTOR DOWNCOUNTER
	LD	C,0			; INIT SECTOR READ/WRITE COUNT
	LD	A,(HDSK_UNIT)		; GET UNIT
	;AND	$0F
	LD	(HDSK_DEV),A		; ... AND SAVE IT

	; RESET HDSK INTERFACE IF NEEDED
	LD	A,(HDSK_STAT)		; GET CURRENT STATUS
	OR	A			; SET FLAGS
	PUSH	BC			; SAVE COUNTERS
	CALL	NZ,HDSK_DSKRESET	; RESET IF NOT READY
	POP	BC			; RESTORE COUNTERS
	JR	NZ,HDSK_RW6		; ABORT ON FAILURE

HDSK_RW0:
	PUSH	BC			; SAVE COUNTERS
	XOR	A			; A = 0
	LD	(HDSK_RC),A		; CLEAR RETURN CODE

	; CONVERT LBA HHHH:LLLL (4 BYTES)
	; TO HDSK TRACK/SECTOR TTTT:SS (3 BYTES)
	; SAVING TO HDSK PARM BLOCK
	LD	A,(HSTLBA)		; LSB OF LBA
	LD	(HDSK_SEC),A		; ... SAVED TO SECTOR
	LD	HL,(HSTLBA+1)		; 2 MIDDLE BYTES OF LBA
	LD	(HDSK_TRK),HL		; ... SAVE TO TRACK
	
	; EXECUTE COMMAND
	LD	B,7		; SIZE OF PARAMETER BLOCK
	LD	HL,HDSK_PARMBLK	; ADDRESS OF PARAMETER BLOCK
	LD	C,$FD		; HDSK CMD PORT
	OTIR			; SEND IT
	
	; GET RESULT
	IN	A,(C)		; GET RESULT CODE
	LD	(HDSK_RC),A	; SAVE IT
	OR	A		; SET FLAGS
	
#IF (HDSKTRACE > 0)
	PUSH	AF		; SAVE RETURN CODE
#IF (HDSKTRACE == 1)
	CALL	NZ,HDSK_PRT	; DIAGNOSE ERRORS ONLY
#ENDIF
#IF (HDSKTRACE >= 2)
	CALL	HDSK_PRT	; DISPLAY ALL READ/WRITE RESULTS
#ENDIF
	POP	AF		; RESTORE RETURN CODE
#ENDIF

	JR	NZ,HDSK_RW5	; BAIL OUT ON ERROR

	; INCREMENT LBA
	LD	HL,HSTLBA
	PUSH	HL
	CALL	LD32
	CALL	INC32
	POP	BC
	CALL	ST32
	
	; INCREMENT DMA
	LD	HL,HDSK_DMA+1	; POINT TO MSB OF DMA
	INC	(HL)		; BUMP DMA BY
	INC	(HL)		; ... 512 BYTES
	
	XOR	A		; A := 0 SIGNALS SUCCESS

HDSK_RW5:

	POP	BC		; RECOVER COUNTERS
	JR	NZ,HDSK_RW6	; IF ERROR, GET OUT
	
	INC	C		; RECORD SECTOR COMPLETED
	DJNZ	HDSK_RW0	; LOOP AS NEEDED

HDSK_RW6:
	; RETURN WITH SECTORS READ IN E AND UPDATED DMA ADDRESS IN HL
	LD	E,C		; SECTOR READ COUNT TO E
	LD	HL,(HDSK_DMA)	; CURRENT DMA TO HL
	OR	A		; SET FLAGS BASED ON RETURN CODE
	RET			; AND RETURN, A HAS RETURN CODE
;
;
;
HDSK_DSKRESET:
	LD	B,32
	LD	A,HDSK_CMDRESET
HDSK_DSKRESET1:
	OUT	($FD),A
	DJNZ	HDSK_DSKRESET1

	XOR	A			; STATUS = OK
	LD	(HDSK_STAT),A		; SAVE IT

#IF (HDSKTRACE >= 2)
	CALL	NEWLINE
	LD	DE,HDSKSTR_PREFIX	
	CALL	WRITESTR
	CALL	PC_SPACE
	LD	DE,HDSKSTR_RESET
	CALL	WRITESTR
#ENDIF

	RET
;
;
;
HDSK_PRT:
	CALL	NEWLINE

	LD	DE,HDSKSTR_PREFIX	
	CALL	WRITESTR
	
	CALL	PC_SPACE
	LD	DE,HDSKSTR_CMD
	CALL	WRITESTR
	LD	A,(HDSK_CMD)
	CALL	PRTHEXBYTE

	CALL	PC_SPACE
	CALL	PC_LBKT
	LD	A,(HDSK_CMD)
	LD	DE,HDSKSTR_NONE
	CP	HDSK_CMDNONE
	JP	Z,HDSK_PRTCMD
	LD	DE,HDSKSTR_RESET
	CP	HDSK_CMDRESET
	JP	Z,HDSK_PRTCMD
	LD	DE,HDSKSTR_READ
	CP	HDSK_CMDREAD
	JP	Z,HDSK_PRTCMD
	LD	DE,HDSKSTR_WRITE
	CP	HDSK_CMDWRITE
	JP	Z,HDSK_PRTCMD
	LD	DE,HDSKSTR_PARAM
	CP	HDSK_CMDPARAM
	JP	Z,HDSK_PRTCMD
	LD	DE,HDSKSTR_UNKCMD
HDSK_PRTCMD:	
	CALL	WRITESTR
	CALL	PC_RBKT

	LD	A,(HDSK_CMD)
	CP	HDSK_CMDREAD
	JR	Z,HDSK_PRTRW
	CP	HDSK_CMDWRITE
	JR	Z,HDSK_PRTRW
	RET

HDSK_PRTRW:
	CALL	PC_SPACE
	LD	A,(HDSK_DEV)
	CALL	PRTHEXBYTE
	CALL	PC_SPACE
	LD	BC,(HDSK_TRK)
	CALL	PRTHEXWORD
	CALL	PC_SPACE
	LD	A,(HDSK_SEC)
	CALL	PRTHEXBYTE
	CALL	PC_SPACE
	LD	BC,(HDSK_DMA)
	CALL	PRTHEXWORD

	CALL	PC_SPACE
	LD	DE,HDSKSTR_ARROW
	CALL	WRITESTR

	CALL	PC_SPACE
	LD	DE,HDSKSTR_RC
	CALL	WRITESTR
	LD	A,(HDSK_RC)
	CALL	PRTHEXBYTE

	CALL	PC_SPACE
	CALL	PC_LBKT
	LD	A,(HDSK_RC)
	LD	DE,HDSKSTR_RCOK
	CP	HDSKRC_OK
	JP	Z,HDSK_PRTRC
	LD	DE,HDSKSTR_RCUNK

HDSK_PRTRC:	
	CALL	WRITESTR
	CALL	PC_RBKT

	RET
;
;
;
HDSKSTR_PREFIX	.TEXT	"HDSK:$"
HDSKSTR_CMD	.TEXT	"CMD=$"
HDSKSTR_RC	.TEXT	"RC=$"
HDSKSTR_ARROW	.TEXT	"-->$"
HDSKSTR_NONE	.TEXT	"NONE$"
HDSKSTR_RESET	.TEXT	"RESET$"
HDSKSTR_READ	.TEXT	"READ$"
HDSKSTR_WRITE	.TEXT	"WRITE$"
HDSKSTR_PARAM	.TEXT	"PARAM$"
HDSKSTR_UNKCMD	.TEXT	"UNKCMD$"
HDSKSTR_RCOK	.TEXT	"OK$"
HDSKSTR_RCUNK	.TEXT	"UNKNOWN ERROR$"
;
;==================================================================================================
;   HDSK DISK DRIVER - DATA
;==================================================================================================
;
HDSK_STAT	.DB	0
HDSK_RC		.DB	0
;
HDSK_UNIT	.DB	0
;
HDSK_PARMBLK:
HDSK_CMD	.DB	0	; COMMAND (HDSK_READ, HDSK_WRITE, ...)
HDSK_DEV	.DB	0	; 0..7, HARD DISK UNIT
HDSK_SEC	.DB	0	; 0..255 SECTOR
HDSK_TRK	.DW	0	; 0..2047 TRACK
HDSK_DMA	.DW	0	; DEFINES WHERE RESULT IS PLACED IN MEMORY
